[["tidyverse.html", "Introdução ao R com aplicações em biodiversidade e conservação Capítulo 1 Tidyverse 1.1 Contextualização 1.2 tidyverse 1.3 here 1.4 readr, readxl e writexl 1.5 tibble 1.6 magrittr (pipe - %&gt;%) 1.7 tidyr 1.8 dplyr 1.9 stringr 1.10 forcats 1.11 lubridate 1.12 purrr 1.13 Exercícios 1.14 Para se aprofundar", " Introdução ao R com aplicações em biodiversidade e conservação 2021-05-27 Capítulo 1 Tidyverse 1.1 Contextualização Como todo idioma, a linguagem R vem passando por transformações nos últimos anos. Grande parte dessas mudanças estão dentro do paradigma da Ciência de Dados (Data Science), uma nova área de conhecimento que vem se moldando a partir do desenvolvimento da sociedade em torno da era digital e da grande quantidade de dados gerados e disponíveis pela internet, de onde advém os pilares das inovações tecnológicas: Big Data, Machine Learning e Internet of Things. A grande necessidade de computação para desenvolver esse novo paradigma colocaram o R e o python como as principais linguagens de programação frente a esses novos desafios. Apesar de não serem as únicas ferramentas utilizadas para esse propósito, elas rapidamente se tornaram uma das melhores escolhas, dado vários fatores como: serem livres, possuírem grandes comunidades contribuidoras, serem linguagens de interpretação (orientadas a objeto) e relativamente fáceis de serem aprendidas e aplicadas. Essas mudanças e adaptações da linguagem R para a Ciência de Dados começaram a ser implementadas principalmente devido a um pesquisador: Hadley Wickham, que iniciou sua contribuição à comunidade R com o desenvolvimento do já consagrado pacote ggplot2 (Wickham 2016) para a composição de gráficos no R (ver mais no capítulo @ref(#graficos)), baseado na gramática de gráficos (Wilkinson and Wills 2005). Depois disso, Wickham dedicou-se ao desenvolvimento do pensamento de uma nova abordagem dentro da manipulação de dados, denominada de Tidy Data (Dados organizados) (Wickham 2014), na qual focou na limpeza e organização de dados. A ideia, relativamente simples, postula que dados estão tidy quando: 1) variáveis estão nas colunas, 2) observações estão nas linhas e 3) valores estão nas células, sendo que para esse último, não deve haver mais de um valor por célula (Figura 1.2). A partir dessas ideias, o tidyverse foi operacionalizado no R como uma coleção de pacotes que atuam no workflow comum da ciência de dados: importação, manipulação, exploração, visualização, análise e comunicação de dados e análises (Wickham et al. 2019) (Figura 1.1). O principal objetivo do tidyverse é aproximar a linguagem para melhorar a interação entre ser humano e computador sobre dados, de modo que os pacotes compartilham uma filosofia de design de alto nível e gramática, além da estrutura de dados de baixo nível (Wickham et al. 2019). Figura 1.1: Modelo das ferramentas necessárias em um projeto típico de ciência de dados: importar, organizar, entender (transformar, visualizar, modelar) e comunicar, envolto à essas ferramentas está a programação. Adaptado de: Wickham and Grolemund (2017). As principais leituras sobre o tema no R são os artigos (Wickham 2014) e (Wickham et al. 2019), e o livro (Wickham and Grolemund 2017), disponível on-line neste link, além do site que possui muito mais informações. 1.2 tidyverse Uma vez instalado e carregado, o pacote tidyverse disponibiliza um conjunto de ferramentas através de vários pacotes. Esses pacotes compartilham uma filosofia de design, gramática e estruturas. Podemos entender o tidyverse como um “dialeto novo” para a linguagem R, onde tidy quer dizer organizado, arrumado, ordenado, e verse é universo. A seguir, listamos os principais pacotes e suas especificações. readr: importa dados tabulares (.csv e .txt) tibble: implementou o “tibble,” com melhorias na classe data frame tidyr: facilita a transformação de dados para tidy dplyr: facilita a manipulação de dados stringr: facilita a manipulação de caracteres forcats: facilita a manipulação de fatores ggplot2: visualização de dados purrr: programação funcional Além desses principais, fazemos também a menção de outros pacotes que estão dentro dessa abordagem, e que trataremos ainda neste capítulo, em outro momento do livro, ou que você leitor(a) deve se familiarizar. readxl e writexl: importa e exporta dados tabulares (.xlsx) janitor: examinar e limpar dados sujos DBI: interface de banco de dados R haven: importa e exporta dados do SPSS, Stata e SAS httr: ferramentas para trabalhar com URLs e HTTP rvest: coletar facilmente (raspe) páginas da web xml2: trabalhar com arquivos XML jsonlite: um analisador e gerador JSON simples e robusto para R hms: hora do dia lubridate: facilita o tratamento de datas magrittr: provê os operadores pipe (%&gt;%, %$%, %&lt;&gt;%) glue: facilita combinar dados e caracteres rmarkdown: cria documentos de análise dinâmica que combinam código, saída renderizada (como figuras) e texto knitr: projetado para ser um mecanismo transparente para geração de relatórios dinâmicos com R shiny: framework de aplicativo Web para R flexdashboard: painéis interativos para R here: facilita a definição de diretórios usethis: automatiza tarefas durante a configuração e desenvolvimento de projetos (Git, ‘GitHub’ e Projetos RStudio) data.table: pacote que fornece uma versão de alto desempenho do data.frame (importar, manipular e expotar) reticulate: pacote que fornece ferramentas para integrar Python e R sparklyr: interface R para Apache Spark broom: converte objetos estatísticos em tibbles organizados modelr: funções de modelagem que funcionam com o pipe tidymodels: coleção de pacotes para modelagem e aprendizado de máquina usando os princípios do tidyverse Para instalar os pacotes do tidyverse, basta instalar o pacote tidyverse. # Instalar o pacote tidyverse install.packages(&quot;tidyverse&quot;) Quando carregamos o pacote tidyverse podemos notar uma mensagem indicando quais pacotes foram carregados, suas respectivas versões e os conflitos com outros pacotes. # Carregar o pacote tidyverse library(tidyverse) Podemos ainda listar todos os pacotes do tidyverse com a função tidyverse::tidyverse_packages(). # Listar todos os pacotes do tidyverse tidyverse::tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dbplyr&quot; &quot;dplyr&quot; &quot;dtplyr&quot; ## [7] &quot;forcats&quot; &quot;googledrive&quot; &quot;googlesheets4&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; ## [13] &quot;httr&quot; &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;pillar&quot; ## [19] &quot;purrr&quot; &quot;readr&quot; &quot;readxl&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [25] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; &quot;tidyverse&quot; Também podemos verificar se os pacotes estão atualizados, senão, podemos atualizá-los com a função tidyverse::tidyverse_update(). # Verificar e atualizar os pacotes do tidyverse tidyverse::tidyverse_update() ## All tidyverse packages up-to-date Todas as funções dos pacotes tidyverse usam fonte minúscula e _ (underscore) para separar os nomes internos das funções, seguindo a mesma sintaxe do python (“Snake Case”). Neste sentido de padronização, é importante destacar ainda que existe um guia próprio para que os scripts sigam a recomendação de padronização, o The tidyverse style guide, criado pelo Hadley Wickham. Para os desenvolvedores, existe o Tidyverse design guide criado pelo Tidyverse team. # Funções no formato snake case read_csv() read_xlsx() as_tibble() left_join() group_by() Por fim, para evitar possíveis conflitos de funções com o mesmo nome entre pacotes, recomendamos fortemente o hábito de usar as funções precedidas do operador :: e o respectivo pacote. Assim, garante-se que a função utilizada é referente ao pacote daquela função. Segue um exemplo com as funções apresentadas anteriormente. # Funções seguidas de seus respectivos pacotes readr::read_csv() readxl::read_xlsx() tibble::as_tibble() dplyr::left_join() dplyr::group_by() Seguindo essas ideias do novo paradigma da Ciência de Dados, outro conjunto de pacotes foi desenvolvido, chamado de tidymodels que atuam no workflow da análise de dados em ciência de dados: separação e reamostragem, pré-processamento, ajuste de modelos e métricas de performasse de ajustes. Por razões de espaço e especificidade, não entraremos em detalhes desse pacote. Seguindo o workflow da Figura 1.1, iremos ver nos itens das próximas seções como esses passos são realizados com funções de cada pacote. 1.3 here Dentro do workflow do tidyverse, devemos sempre trabalhar com Projetos do RStudio, um tema que focamos com mais detalhes no Capítulo XX. Junto com o projeto, também podemos fazer uso do pacote here. Ele permite construir caminhos para os arquivos do projeto de forma mais simples e com maior reprodutibilidade. Esse pacote cobre o ponto que discutimos na seção YY do capítulo XX, dado que muitas vezes mudar o diretório com a função setwd() tende a ser demorado, principalmente quando se trata de um script em que várias pessoas estão trabalhando em diferentes computadores e sistemas operacionais. Além disso, ele elimina a questão da fragilidade dos scripts, pois geralmente um script está com os diretórios conectados exatamente a um lugar e a um momento. Por fim, ele também simplifica o trabalho com subdiretórios, facilitando importar ou exportar arquivos para subpastas. Seu uso é relativamente simples: uma vez criado e aberto o RStudio pelo Projeto do RStudio, o diretório automaticamente é definido para o diretório do projeto. Depois disso, podemos usar a função here::here() para definir os subdiretórios onde estão os dados. O exemplo da aplicação fica para a seção seguinte, quando iremos de fato importar um arquivo para o R. Logo abaixo, mostramos como instalar e carregar o pacote here. # Instalar install.packages(&quot;here&quot;) # Carregar library(here) 1.4 readr, readxl e writexl Dado que possuímos um conjunto de dados e que geralmente esse conjunto de dados estará no formato tabular com umas das extensões: .csv, .txt ou .xlsx, usaremos o pacote readr ou readxl para importar esses dados para o R. Esses pacotes leem e escrevem grandes arquivos de forma mais rápida, além de fornecerem medidores de progresso de importação e exportação, e imprimir a informação dos modos das colunas quando faz a importação. Outro ponto bastante positivo é que também classificam automaticamente o modo dos dados de cada coluna, i.e., se uma coluna possui dados numéricos ou apenas texto, essa informação será considerada para classificar o modo da coluna toda. A classe do objeto atribuído quando lido por esses pacotes é automaticamente um tibble, que veremos melhor na seção seguinte. Todas as funções deste pacote são listadas na página de referência do pacote. Usamos as funções readr::read_csv() e readr::write_csv() para importar e exportar arquivos .csv do R, respectivamente. Para dados com a extensão .txt, podemos utilizar as funções readr::read_tsv() ou ainda readr::read_delim(). Para arquivos tabulares com a extensão .xlsx, temos de instalar dois pacotes adicionais: readxl e writexl, dos quais usaremos as funções readxl::read_excel(), readxl::read_xlsx() ou readxl::read_xls() para importar dados, atentado para o fato de podermos indicar a aba com os dados com o argumento sheet, e writexl::write_xlsx() para exportar. # Instalar install.packages(c(&quot;readxl&quot;, &quot;writexl&quot;)) # Carregar library(readxl) library(writexl) Se o arquivo .csv foi criado com separador de decimais sendo . e separador de colunas sendo ,, usamos as funções normalmente. Caso seja criado com separador de decimais sendo , e separador de colunas sendo ;, usaríamos a função readr::read_csv2() para importar e readr::write_csv2() para exportar nesse formato. Para exemplificar como importar dados no formato tidyverse, vamos importar novamente os dados de comunidades de anfíbios da Mata Atlântica (Atlantic Amphibians, Vancine et al. 2018), que fizemos o download na seção XX. Estamos usando a função readr::read_csv(), indicando os diretórios com a função here::here(), e a classe do arquivo é tibble. # Importar locais aa_locais &lt;- readr::read_csv( here::here(&quot;dados&quot;, &quot;tabelas&quot;, &quot;ATLANTIC_AMPHIBIANS_sites.csv&quot;) ) ## ## ── Column specification ──────────────────────────────────────────────────────────────────────────── ## cols( ## .default = col_character(), ## reference_number = col_double(), ## species_number = col_double(), ## month_start = col_double(), ## year_start = col_double(), ## month_finish = col_double(), ## year_finish = col_double(), ## effort_months = col_double(), ## latitude = col_double(), ## longitude = col_double(), ## altitude = col_double(), ## temperature = col_double(), ## precipitation = col_double() ## ) ## ℹ Use `spec()` for the full column specifications. Para se aprofundar no tema, recomendamos a leitura do capítulo 11 Data import de Wickham &amp; Grolemund (2017). 1.5 tibble O tibble (tbl_sf) é uma versão aprimorada do data frame (data.frame). Ele é a classe aconselhada para que as funções do tidyverse funcionem melhor sobre conjuntos de dados tabulares importados para o R. Geralmente, quando utilizamos funções tidyverse para importar dados para o R, é essa classe que os dados adquirem depois de importados. Além da importação de dados, podemos criar um tibble no R usando a função tibble::tibble(), semelhante ao uso da função data.frame(). Podemos ainda converter um data.frame para um tibble usando a função tibble::as_tibble(). Entretanto, em alguns momentos precisaremos da classe data.frame para algumas funções específicas, e podemos converter um tibble para data.frame usando a função tibble::as_data_frame(). Existem duas diferenças principais no uso do tibble e do data.frame: impressão e subconjunto. Objetos da classe tibbles possuem um método de impressão que mostra a contagem do número de linhas e colunas, e apenas as primeiras 10 linhas e todas as colunas que cabem na tela no console, além dos modos ou tipos das colunas. Dessa forma, cada coluna ou variável, pode ser do modo numbers (int ou dbl), character (chr), logical (lgl), factor (fctr), date + time (dttm) e date (date), além de outras inúmeras possibilidades. Todas as funções deste pacote são listadas na página de referência do pacote. # Tibble - impressão aa_locais ## # A tibble: 1,163 x 25 ## id reference_number species_number record sampled_habitat active_methods passive_methods ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 amp1001 1001 19 ab fo,ll as pt ## 2 amp1002 1002 16 co fo,la,ll as pt ## 3 amp1003 1002 14 co fo,la,ll as pt ## 4 amp1004 1002 13 co fo,la,ll as pt ## 5 amp1005 1003 30 co fo,ll,br as &lt;NA&gt; ## 6 amp1006 1004 42 co tp,pp,la,ll,is &lt;NA&gt; &lt;NA&gt; ## 7 amp1007 1005 23 co sp as &lt;NA&gt; ## 8 amp1008 1005 19 co sp,la,sw as,sb,tr &lt;NA&gt; ## 9 amp1009 1005 13 ab fo &lt;NA&gt; pt ## 10 amp1010 1006 1 ab fo &lt;NA&gt; pt ## # … with 1,153 more rows, and 18 more variables: complementary_methods &lt;chr&gt;, period &lt;chr&gt;, ## # month_start &lt;dbl&gt;, year_start &lt;dbl&gt;, month_finish &lt;dbl&gt;, year_finish &lt;dbl&gt;, ## # effort_months &lt;dbl&gt;, country &lt;chr&gt;, state &lt;chr&gt;, state_abbreviation &lt;chr&gt;, municipality &lt;chr&gt;, ## # site &lt;chr&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, coordinate_precision &lt;chr&gt;, altitude &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, precipitation &lt;dbl&gt; Para o subconjunto, como vimos anteriormente, para selecionar colunas e linhas de objetos bidimensionais podemos utilizar os operadores [] ou [[]], associado com números separados por vírgulas ou o nome da coluna entre aspas, e o operador $ para extrair uma coluna pelo seu nome. Comparando um data.frame a um tibble, o último é mais rígido na seleção das colunas: eles nunca fazem correspondência parcial e gerarão um aviso se a coluna que você está tentando acessar não existir. # Tibble - subconjunto aa_locais$ref ## Warning: Unknown or uninitialised column: `ref`. ## NULL Por fim, podemos “espiar” os dados utilizando a função tibble::glimpse() para ter uma noção geral de número de linhas, colunas, e conteúdo de todas as colunas. Essa é função tidyverse da função R Base str(). # Espiar os dados tibble::glimpse(aa_locais[, 1:10]) ## Rows: 1,163 ## Columns: 10 ## $ id &lt;chr&gt; &quot;amp1001&quot;, &quot;amp1002&quot;, &quot;amp1003&quot;, &quot;amp1004&quot;, &quot;amp1005&quot;, &quot;amp1006&quot;, &quot;a… ## $ reference_number &lt;dbl&gt; 1001, 1002, 1002, 1002, 1003, 1004, 1005, 1005, 1005, 1006, 1006, 10… ## $ species_number &lt;dbl&gt; 19, 16, 14, 13, 30, 42, 23, 19, 13, 1, 1, 2, 4, 4, 6, 5, 8, 2, 5, 1,… ## $ record &lt;chr&gt; &quot;ab&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;a… ## $ sampled_habitat &lt;chr&gt; &quot;fo,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo,ll,br&quot;, &quot;tp,pp,la,l… ## $ active_methods &lt;chr&gt; &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, NA, &quot;as&quot;, &quot;as,sb,tr&quot;, NA, NA, NA, NA, … ## $ passive_methods &lt;chr&gt; &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, NA, NA, NA, NA, &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;… ## $ complementary_methods &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ period &lt;chr&gt; &quot;mo,da,tw,ni&quot;, &quot;mo,da,tw,ni&quot;, &quot;mo,da,tw,ni&quot;, &quot;mo,da,tw,ni&quot;, &quot;mo,da,n… ## $ month_start &lt;dbl&gt; 9, 12, 12, 12, 7, NA, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5… Para se aprofundar no tema, recomendamos a leitura do capítulo 10 Tibbles de Wickham &amp; Grolemund (2017). 1.6 magrittr (pipe - %&gt;%) O operador pipe %&gt;% permite o encadeamento de várias funções, eliminando a necessidade de criar objetos para armazenar resultados intermediários. Dessa forma, pipes são uma ferramenta poderosa para expressar uma sequência de múltiplas operações. O operador pipe %&gt;% vem do pacote magrittr, entretanto, todos os pacotes no tidyverse automaticamente tornam o pipe disponível. Essa função torna os códigos em R mais simples, pois realizamos múltiplas operações em uma única linha. Ele captura o resultado de uma declaração e o torna a entrada da próxima declaração, então podemos pensar como “EM SEGUIDA FAÇA” ao final de cada linha de código. Todas as funções deste pacote são listadas na página de referência do pacote. A principal vantagem do uso dos pipes é facilitar o debuging (achar erros) nos códigos, porque seu uso torna a linguagem R mais próxima do que falamos e pensamos, uma vez que evita o uso de funções dentro de funções (funções compostas, lembra-se do fog e gof? Evitamos eles aqui também…). Digitar %&gt;% é um pouco chato, dessa forma, existe um atalho para sua inserção nos scripts: Ctrl + Shift + M. Para deixar esse tópico menos estranho a quem possa ver essa operação pela primeira vez, vamos fazer alguns exemplos. # Base r - sem pipe sqrt(sum(1:100)) ## [1] 71.06335 # Tidyverse - com pipe 1:100 %&gt;% sum() %&gt;% sqrt() ## [1] 71.06335 Essas operações ainda estão simples, vamos torná-las mais complexas com várias funções compostas. É nesses casos que a propriedade organizacional do uso do pipe emerge: podemos facilmente ver o encadeamento de operações, onde cada função é disposta numa linha. # Fixar amostragem set.seed(42) # Base r - sem pipe ve &lt;- sum(sqrt(sort(log10(rpois(100, 10))))) ve ## [1] 99.91426 # Fixar amostragem set.seed(42) # Tidyverse - com pipe ve &lt;- rpois(100, 10) %&gt;% log10() %&gt;% sort() %&gt;% sqrt() %&gt;% sum() ve ## [1] 99.91426 O uso do pipe vai se tornar especialmente útil quando seguirmos para os pacotes das próximas duas seções: tidyr e dplyr. Com esses pacotes faremos operações em linhas e colunas de nossos dados tabulares, então podemos encadear uma série de funções para manipulação, limpeza e análise de dados. Há ainda três outras variações do pipe que podem ser úteis em alguns momentos, mas que para funcionar precisam que o pacotemagrittr seja carregado: %T&gt;%: retorna o lado esquerdo em vez do lado direito %$%: “explode” as variáveis em um quadro de dados %&lt;&gt;%: permite atribuição usando pipes Para se aprofundar no tema, recomendamos a leitura do capítulo 18 Pipes de Wickham &amp; Grolemund (2017). A partir da versão do R 4.1 (18/05/2021), o operador pipe se tornou nativo. Entretanto, o operador foi atualizado para |&gt;, podendo ser inserido com o mesmo atalho Ctrl + Shift + M. 1.7 tidyr Os conjuntos de dados tidy (organizados) são mais fáceis de manipular, modelar e visualizar. Um conjunto de dados está no formato tidy ou não, dependendo de como linhas, colunas e células são combinadas com observações, variáveis e valores. Nos dados tidy, as variáveis estão nas colunas, observações estão nas linhas e valores estão nas células, sendo que para esse último, não deve haver mais de um valor por célula (Figura 1.2). Cada variável em uma coluna Cada observação em uma linha Cada valor como uma célula Figura 1.2: As três regras que tornam um conjunto de dados tidy. Adaptado de: Wickham and Grolemund (2017). Todas as funções deste pacote são listadas na página de referência do pacote. Para realizar diversas transformações nos dados, a fim de ajustá-los ao formato tidy, existe uma série de funções, para diversas: unir, separar, valores faltantes (NA), pivotar (formato longo para largo), além de outras funções específicas. unite(): junta dados de múltiplas colunas em uma coluna separate(): separa caracteres em múltiplas colunas separate_rows(): separa caracteres em múltiplas colunas e linhas drop_na(): retira linhas com NA do conjunto de dados replace_na(): substitui NA do conjunto de dados pivot_wider(): transforma um conjunto de dados longo (long) para largo (wide) pivot_longer(): transforma um conjunto de dados largo (wide) para longo (long) 1.7.1 palmerpenguins Para exemplificar o funcionamento dessas funções, usaremos os dados de medidas de pinguins chamados palmerpenguins, disponíveis no pacote palmerpenguins. # Instalar o pacote install.packages(&quot;palmerpenguins&quot;) Esses dados foram coletados e disponibilizados pela Dra. Kristen Gorman e pela Palmer Station, Antarctica LTER, membro da Long Term Ecological Research Network. O pacote palmerpenguins contém dois conjuntos de dados. Um é chamado de penguins, e é uma versão simplificada dos dados brutos. O segundo conjunto de dados é penguins_raw e contém todas as variáveis e nomes originais baixados. Ambos os conjuntos de dados contêm dados para 344 pinguins, de três espécies diferentes, coletados em três ilhas no arquipélago de Palmer, na Antártica. Destacamos também a versão traduzida desses dados para o português, disponível no pacote dados. Vamos utilizar principalmente o conjunto de dados penguins_raw, que é a versão dos dados brutos. # Carregar o pacote palmerpenguins library(palmerpenguins) # Ajuda dos dados ?penguins ?penguins_raw 1.7.2 glimpse() Primeiramente, vamos observar os dados e utilizar a função tibble::glimpse() para ter uma noção geral. # Visualizar os dados penguins_raw ## # A tibble: 344 x 17 ## studyName `Sample Number` Species Region Island Stage `Individual ID` `Clutch Complet… `Date Egg` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 PAL0708 1 Adelie… Anvers Torge… Adul… N1A1 Yes 2007-11-11 ## 2 PAL0708 2 Adelie… Anvers Torge… Adul… N1A2 Yes 2007-11-11 ## 3 PAL0708 3 Adelie… Anvers Torge… Adul… N2A1 Yes 2007-11-16 ## 4 PAL0708 4 Adelie… Anvers Torge… Adul… N2A2 Yes 2007-11-16 ## 5 PAL0708 5 Adelie… Anvers Torge… Adul… N3A1 Yes 2007-11-16 ## 6 PAL0708 6 Adelie… Anvers Torge… Adul… N3A2 Yes 2007-11-16 ## 7 PAL0708 7 Adelie… Anvers Torge… Adul… N4A1 No 2007-11-15 ## 8 PAL0708 8 Adelie… Anvers Torge… Adul… N4A2 No 2007-11-15 ## 9 PAL0708 9 Adelie… Anvers Torge… Adul… N5A1 Yes 2007-11-09 ## 10 PAL0708 10 Adelie… Anvers Torge… Adul… N5A2 Yes 2007-11-09 ## # … with 334 more rows, and 8 more variables: Culmen Length (mm) &lt;dbl&gt;, Culmen Depth (mm) &lt;dbl&gt;, ## # Flipper Length (mm) &lt;dbl&gt;, Body Mass (g) &lt;dbl&gt;, Sex &lt;chr&gt;, Delta 15 N (o/oo) &lt;dbl&gt;, ## # Delta 13 C (o/oo) &lt;dbl&gt;, Comments &lt;chr&gt; # Espiar os dados dplyr::glimpse(penguins_raw) ## Rows: 344 ## Columns: 17 ## $ studyName &lt;chr&gt; &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;P… ## $ `Sample Number` &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2… ## $ Species &lt;chr&gt; &quot;Adelie Penguin (Pygoscelis adeliae)&quot;, &quot;Adelie Penguin (Pygoscelis a… ## $ Region &lt;chr&gt; &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;… ## $ Island &lt;chr&gt; &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;To… ## $ Stage &lt;chr&gt; &quot;Adult, 1 Egg Stage&quot;, &quot;Adult, 1 Egg Stage&quot;, &quot;Adult, 1 Egg Stage&quot;, &quot;A… ## $ `Individual ID` &lt;chr&gt; &quot;N1A1&quot;, &quot;N1A2&quot;, &quot;N2A1&quot;, &quot;N2A2&quot;, &quot;N3A1&quot;, &quot;N3A2&quot;, &quot;N4A1&quot;, &quot;N4A2&quot;, &quot;N5A… ## $ `Clutch Completion` &lt;chr&gt; &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Yes&quot;, … ## $ `Date Egg` &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16, 2007-11-16, 2007-11… ## $ `Culmen Length (mm)` &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 37.8, 37.8… ## $ `Culmen Depth (mm)` &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 17.1, 17.3… ## $ `Flipper Length (mm)` &lt;dbl&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186, 180, 182, 191,… ## $ `Body Mass (g)` &lt;dbl&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, 4250, 3300, 3700… ## $ Sex &lt;chr&gt; &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;FEMALE&quot;, NA, &quot;FEMALE&quot;, &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;MALE&quot;, … ## $ `Delta 15 N (o/oo)` &lt;dbl&gt; NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.18718, 9.46060, NA, 9.… ## $ `Delta 13 C (o/oo)` &lt;dbl&gt; NA, -24.69454, -25.33302, NA, -25.32426, -25.29805, -25.21799, -24.8… ## $ Comments &lt;chr&gt; &quot;Not enough blood for isotopes.&quot;, NA, NA, &quot;Adult not sampled.&quot;, NA, … 1.7.3 unite() Primeiramente, vamos exemplificar como juntar e separar colunas. Vamos utilizar a função tidyr::unite() para unir as colunas. Há diversos parâmetros para alterar como assa função funciona, entretanto, é importante destacar três deles: col nome da coluna que vai receber as colunas unidas, sep indicando o caracteree separador das colunas unidas, e remove para uma resposta lógica se as colunas unidas são removidas ou não. Vamos unir as colunas “Region” e “Island” na nova coluna “region_island.” # Unir colunas penguins_raw_unir &lt;- tidyr::unite(data = penguins_raw, col = &quot;region_island&quot;, Region:Island, sep = &quot;, &quot;, remove = FALSE) 1.7.4 separate() De forma contrária, podemos utilizar as funções tidyr::separate() e tidyr::separate_rows() para separar elementos de uma coluna em mais colunas. Respectivamente, a primeira função separa uma coluna em novas colunas conforme a separação, e a segunda função separa uma coluna, distribuindo os elementos também nas linhas. Novamente, há diversos parâmetros para mudar o comportamento dessas funções, mas destacaremos aqui quatro deles: col coluna a ser separada, into os nomes das novas colunas, sep indicando o caractere separador das colunas, e remove para uma resposta lógica se as colunas separadas são removidas ou não. Vamos separar a coluna “Stage” nas colunas “stage” e “egg_stage.” # Separar colunas penguins_raw_separar &lt;- tidyr::separate(data = penguins_raw, col = Stage, into = c(&quot;stage&quot;, &quot;egg_stage&quot;), sep = &quot;, &quot;, remove = FALSE) # Separar colunas em novas linhas penguins_raw_separar_linhas &lt;- tidyr::separate_rows(data = penguins_raw, Stage, sep = &quot;, &quot;) 1.7.5 drop_na() e replace_na() Valores faltantes (NA) é um tipo especial de elemento que discutimos na seção YY do Capítulo XX, e são relativamente comuns em conjuntos de dados. Em Base R, vimos algumas formas de lidar com esse tipo de elemento. No formato tidyverse, existem várias formas de lidar com eles, mas aqui focaremos nas funções tidyr::drop_na() e tidyr::replace_na(), para retirar linhas e substitui-los, respectivamente. # Remover todas as linhas com NAs penguins_raw_todas_na &lt;- tidyr::drop_na(data = penguins_raw) # Remover linhas de colunas específicas com NAs penguins_raw_colunas_na &lt;- tidyr::drop_na(data = penguins_raw, any_of(&quot;Comments&quot;)) # Substituir NAs por outro valor penguins_raw_subs_na &lt;- tidyr::replace_na(data = penguins_raw, list(Comments = &quot;Unknown&quot;)) 1.7.6 pivotagem - pivot_longer() e pivot_wider() Por fim, trataremos da pivotagem ou remodelagem de dados. Veremos como mudar o formato do nosso conjunto de dados de longo (long) para largo (wide) e vice-versa. Essa é uma operação semelhante à “Tabela Dinâmica” das planilhas eletrônicas. Consiste em usar uma coluna para distribuir seus valores em outras colunas, de modo que os valores dos elementos são preenchidos corretamente, reduzindo assim o número de linhas. Essa operação é bastante comum em Ecologia de Comunidades, quando queremos transformar uma lista de espécies em uma matriz de comunidades, com várias espécies nas colunas. Para realizar essa operação, usarmos a função tidyr::pivot_wider(). Dos diversos parâmetros que podem compor essa função, dois deles são fundamentais: names_from que indica a coluna de onde os nomes serão usados e values_from a coluna com os valores. # Selecionar colunas penguins_raw_sel_col &lt;- penguins_raw[, c(2, 3, 13)] # Pivotar para largo penguins_raw_pivot_wider &lt;- tidyr::pivot_wider(data = penguins_raw_sel_col, names_from = Species, values_from = `Body Mass (g)`) De modo oposto, podemos partir de um conjunto de dados largo (wide), ou seja, com várias colunas, e queremos que essas colunas preencham uma única coluna, e que os valores antes espalhados nessas várias colunas sejam adicionados um embaixo do outro, numa única coluna. Para essa operação, podemos utilizar a função tidyr::pivot_longer(). Novamente, dos diversos parâmetros que podem compor essa função, três deles são fundamentais: cols indicando as colunas que serão usadas para serem pivotadas, names_to que indica a coluna de onde os nomes serão usados e values_to a coluna com os valores. # Selecionar colunas penguins_raw_sel_col &lt;- penguins_raw[, c(2, 3, 10:13)] # Pivotar para largo penguins_raw_pivot_longer &lt;- tidyr::pivot_longer(data = penguins_raw_sel_col, cols = `Culmen Length (mm)`:`Body Mass (g)`, names_to = &quot;medidas&quot;, values_to = &quot;valores&quot;) Para se aprofundar no tema, recomendamos a leitura do capítulo 12 Tidy data de Wickham &amp; Grolemund (2017). 1.8 dplyr O dplyr é um pacote que facilita a manipulação de dados, com uma gramática simples e flexível (por exemplo, como filtragem, reordenamento, seleção, entre outras). Ele foi construído com o intuito de obter uma forma mais rápida e expressiva de tratar os dados. O tibble é a versão de data frame mais conveniente para se usar com pacote dplyr. Todas as funções deste pacote são listadas na página de referência do pacote. 1.8.1 Gramática Sua gramática simples contém funções verbais para manipulação de dados, baseada em: Verbos: mutate(), select(), filter(), arrange(), summarise(), slice(), rename(), etc. Replicação: across(), if_any(), if_all(), where(), starts_with(), ends_with(), contains(), etc. Agrupamento: group_by() e ungroup() Junções: inner_join(), full_join(), left_join(), right_join(), etc. Combinações: bind_rows() e bind_cols() Resumos, contagem e seleção: n(), n_distinct(), first(), last(), nth(), etc. Existe uma série de funções para realizar a manipulação dos dados, com diversas finalidades: manipulação de uma tabela, manipulação de duas tabelas, replicação, agrupamento, funções de vetores, além de muitas outras funções específicas. relocate(): muda a ordem das colunas rename(): muda o nome das colunas select(): seleciona colunas pelo nome ou posição pull(): seleciona uma coluna como vetor mutate(): adiciona novas colunas ou resultados em colunas existentes arrange(): reordena as linhas com base nos valores de colunas filter(): seleciona linhas com base em valores de colunas slice(): seleciona linhas de diferente formas distinct(): remove linhas com valores repetidos com base nos valores de colunas count(): conta observações para um grupo group_by(): agrupa linhas pelos valores das colunas summarise(): resume os dados através de funções considerando valores das colunas *_join(): funções que juntam dados de duas tabelas através de uma coluna chave 1.8.2 Sintaxe Todas as funções seguem a mesma sintaxe, de modo que o tibble é sempre o primeiro argumento dessas funções, seguido de um pipe e pelo nome da função. Isso permite o encadeamento de várias operações consecutivas. tibble operador pipe nome da função verbal com os argumentos entre parênteses outras funções verbais… As funções verbais não precisam modificar necessariamente o tibble original, sendo que as operações de manipulações podem e devem ser atribuídas a um novo objeto. tb_dplyr &lt;- tb %&gt;% funcao_verbal1(argumento1, argumento2, ...) %&gt;% funcao_verbal2(argumento1, argumento2, ...) %&gt;% funcao_verbal3(argumento1, argumento2, ...) Além de data.frames e tibbles, a manipulação pelo formato dplyr torna o trabalho com outros formatos de classes e dados acessíveis e eficientes como data.table, SQL e Apache Spark, para os quais existem pacotes específicos. dtplyr: manipular conjuntos de dados data.table dbplyr: manipular conjuntos de dados SQL sparklyr: manipular conjuntos de dados no Apache Spark 1.8.3 palmerpenguins Para nossos exemplos, vamos utilizar novamente os dados de pinguins palmerpenguins. Esses dados estão disponíveis no pacote palmerpenguins. Vamos utilizar principalmente o conjunto de dados penguins, que é a versão simplificada dos dados brutos penguins_raw. # carrega o pacote palmerpenguins library(palmerpenguins) 1.8.4 relocate() Primeiramente, vamos reordenar as colunas com a função dplyr::relocate(), onde simplesmente listamos as colunas que queremos mudar de posição e para onde elas devem ir. Para esse último passo há dois argumentos: .before que indica qual a coluna que as colunas realocadas devem se mover antes, e o argumento .after indicando onde devem se mover depois. Ambos podem ser informados com os nomes ou posições dessas colunas com números. # Reordenar colunas - nome penguins_relocate_col &lt;- penguins %&gt;% dplyr::relocate(sex, year, .after = island) # Reordenar colunas - posição penguins_relocate_ncol &lt;- penguins %&gt;% dplyr::relocate(sex, year, .after = 2) 1.8.5 rename() Podemos ainda renomear colunas facilmente com a função dplyr::rename(), onde primeiramente informamos o nome que queremos que a coluna tenha, seguido do operador = e a coluna do nosso dado (“nova_coluna = antiga_coluna”). Também podemos utilizar a função dplyr::rename_with(), que faz a mudança do nome em múltiplas colunas, que pode depender ou não de resultados booleanos. # Renomear as colunas penguins_rename &lt;- penguins %&gt;% dplyr::rename(bill_length = bill_length_mm, bill_depth = bill_depth_mm, flipper_length = flipper_length_mm, body_mass = body_mass_g) # mudar o nome de todas as colunas penguins_rename_with &lt;- penguins %&gt;% dplyr::rename_with(toupper) 1.8.6 select() Outra operação bastante usual dentro da manipulação de dados tabulares é a seleção de colunas. Podemos fazer essa operação com a função dplyr::select(), que seleciona colunas pelo nome ou pela sua posição. Aqui há uma série de possibilidades de seleção de colunas, desde utilizar operadores como : para selecionar intervalos de colunas, ! para tomar o complemento (todas menos as listadas), além de funções como dplyr::starts_with(), dplyr::ends_with(), dplyr::contains() para procurar colunas com um padrão de texto. # Selecionar colunas por posição penguins_select_position &lt;- penguins %&gt;% dplyr::select(3:6) # Selecionar colunas por nomes penguins_select_names &lt;- penguins %&gt;% dplyr::select(bill_length_mm:body_mass_g) # Selecionar colunas por padrão penguins_select_contains &lt;- penguins %&gt;% dplyr::select(contains(&quot;_mm&quot;)) 1.8.7 pull() Quando usamos a função dplyr::select(), mesmo que para uma coluna, o retorno é sempre um tibble. Caso precisemos que essa coluna se torne um vetor dentro do encadeamento dos pipes, usamos a função dplyr::pull() que extrai uma única coluna como vetor. # Coluna como vetor penguins_select_pull &lt;- penguins %&gt;% dplyr::pull(bill_length_mm) 1.8.8 mutate() Uma das operações mais úteis dentre as operações para colunas é adicionar ou atualizar os valores de colunas. Para essa operação, usaremos a função dplyr::mutate(). Podemos ainda usar os argumentos .before e .after para indicar onde a nova coluna deve ficar, além do parâmetro .keep com diversas possibilidades de manter colunas depois de usar a função dplyr::mutate(). Por fim, é fundamental destacar o uso das funções de replicação: dplyr::across(), dplyr::if_any() e dplyr::if_all(), para os quais a função fará alterações em múltiplas colunas de uma vez, dependendo de resultados booleanos. # Adicionar colunas penguins_mutate &lt;- penguins %&gt;% dplyr::mutate(body_mass_kg = body_mass_g/1e3, .before = sex) # Modificar várias colunas penguins_mutate_across &lt;- penguins %&gt;% dplyr::mutate(across(where(is.factor), as.character)) 1.8.9 arrange() Além de operações em colunas, podemos fazer operações em linhas. Vamos começar com a reordenação das linhas com base nos valores das colunas. Para essa operação, usamos a função dplyr::arrange(). Podemos reordenar por uma ou mais colunas de forma crescente ou de forma decrescente usando a função desc() ou o operador -. Da mesma forma que na função dplyr::mutate(), podemos usar as funções de replicação para ordenar as linhas para várias colunas de uma vez, dependendo de resultados booleanos. # Reordenar linhas - crescente penguins_arrange &lt;- penguins %&gt;% dplyr::arrange(body_mass_g) # Reordenar linhas - decrescente penguins_arrange_desc &lt;- penguins %&gt;% dplyr::arrange(desc(body_mass_g)) # Reordenar linhas - decrescente penguins_arrange_desc_m &lt;- penguins %&gt;% dplyr::arrange(-body_mass_g) # Reordenar linhas - multiplas colunas penguins_arrange_across &lt;- penguins %&gt;% dplyr::arrange(across(where(is.numeric))) 1.8.10 filter() Uma das principais e mais usuais operações que podemos realizar em linhas é a seleção de linhas através do filtro por valores de uma ou mais colunas, utilizando a função dplyr::filter(). Para realizar os filtros utilizaremos grande parte dos operadores relacionais e lógicos que listamos na Tabela ??, especialmente os lógicos para combinações de filtros em mais de uma coluna. Além desses operadores, podemos utilizar a função is.na() para filtros em elementos faltantes, e as funções dplyr::between() e dplyr::near() para filtros entre valores, e para valores próximos com certa tolerância, respectivamente. Por fim, podemos usar as funções de replicação para filtro das linhas para mais de uma coluna, dependendo de resultados booleanos. # Filtrar linhas penguins_filter &lt;- penguins %&gt;% dplyr::filter(species == &quot;Adelie&quot;) # Filtrar linhas penguins_filter_two &lt;- penguins %&gt;% dplyr::filter(species == &quot;Adelie&quot; &amp; sex == &quot;female&quot;) # Filtrar linhas penguins_filter_in &lt;- penguins %&gt;% dplyr::filter(species %in% c(&quot;Adelie&quot;, &quot;Gentoo&quot;), sex == &quot;female&quot;) # Filtrar linhas - NA penguins_filter_na &lt;- penguins %&gt;% dplyr::filter(!is.na(sex) == TRUE) # Filtrar linhas - intervalos penguins_filter_between &lt;- penguins %&gt;% dplyr::filter(between(body_mass_g, 3000, 4000)) # Filtrar linhas por várias colunas penguins_filter_if &lt;- penguins %&gt;% dplyr::filter(if_all(where(is.integer), ~ . &gt; 200)) 1.8.11 slice() Além da seleção de linhas por filtros, podemos fazer a seleção das linhas por intervalos, indicando quais linhas desejamos, usando a função dplyr::slice(), e informando o argumento n para o número da linha ou intervalo das linhas. Essa função possui variações no sufixo muito interessantes: dplyr::slice_head() e dplyr::slice_tail() seleciona as primeiras e últimas linhas, dplyr::slice_min() e dplyr::slice_max() seleciona linhas com os maiores e menores valores de uma coluna, e dplyr::slice_sample() seleciona linhas aleatoriamente. # Seleciona linhas penguins_slice &lt;- penguins %&gt;% dplyr::slice(n = c(1, 3, 300:n())) # Seleciona linhas - head penguins_slice_head &lt;- penguins %&gt;% dplyr::slice_head(n = 5) # Seleciona linhas - max penguins_slice_max &lt;- penguins %&gt;% dplyr::slice_max(body_mass_g, n = 5) # Seleciona linhas - sample penguins_slice_sample &lt;- penguins %&gt;% dplyr::slice_sample(n = 30) 1.8.12 distinct() A última operação que apresentaremos para linhas é a retirada de linhas com valores repetidos com base nos valores de colunas, utilizando a função dplyr::distinct(). Essa função por padrão retorna apenas a coluna utilizada para retirar as linhas com valores repetidos, sendo necessário acrescentar o argumento .keep_all = TRUE para retornar todas as colunas. Por fim, podemos usar as funções de replicação para retirar linhas com valores repetidos para mais de uma coluna, dependendo de resultados booleanos. # Retirar linhas com valores repetidos penguins_distinct &lt;- penguins %&gt;% dplyr::distinct(body_mass_g) # Retirar linhas com valores repetidos - manter as outras colunas penguins_distinct_keep_all &lt;- penguins %&gt;% dplyr::distinct(body_mass_g, .keep_all = TRUE) # Retirar linhas com valores repetidos para várias colunas penguins_distinct_keep_all_across &lt;- penguins %&gt;% dplyr::distinct(across(where(is.integer)), .keep_all = TRUE) 1.8.13 count() Agora entraremos no assunto de resumo das observações. Podemos fazer contagens resumos dos nossos dados, utilizando para isso a função dplyr::count(). Essa função contará valores de uma ou mais colunas, geralmente para variáveis categóricas, semelhante à função Base R table(), mas num contexto tidyverse. # Contagens de valores para uma coluna penguins_count &lt;- penguins %&gt;% dplyr::count(species) # Contagens de valores para mais de uma coluna penguins_count_two &lt;- penguins %&gt;% dplyr::count(species, island) 1.8.14 group_by() Uma grande parte das operações feitas nos dados são realizadas em grupos definidos por valores de colunas ou variáveis categóricas. A função dplyr::group_by() transforma um tibble em um tibble agrupado, onde as operações são realizadas “por grupo.” Essa função é utilizada geralmente junto com a função dplyr::summarise(), que veremos logo em seguida. O agrupamento não altera a aparência dos dados (além de informar como estão agrupados). A função dplyr::ungroup() remove o agrupamento. Podemos ainda usar funções de replicação para fazer os agrupamentos para mais de uma coluna, dependendo de resultados booleanos. # Agrupamento penguins_group_by &lt;- penguins %&gt;% dplyr::group_by(species) # agrupamento várias colunas penguins_group_by_across &lt;- penguins %&gt;% dplyr::group_by(across(where(is.factor))) 1.8.15 summarise() Como dissemos, muitas vezes queremos resumir nossos dados, principalmente para ter uma noção geral das variáveis (colunas) ou mesmo começar a análise exploratória resumindo variáveis contínuas por grupos de variáveis categóricas. Dessa forma, ao utilizar a função dplyr::summarise() teremos um novo tibble com os dados resumidos, que é a agregação ou resumo dos dados através de funções. Da mesma forma que outras funções, podemos usar funções de replicação para resumir valores para mais de uma coluna, dependendo de resultados booleanos. # Resumo penguins_summarise &lt;- penguins %&gt;% dplyr::group_by(species) %&gt;% summarize(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE), body_mass_g_sd = sd(body_mass_g, na.rm = TRUE)) # Resumo para várias colunas penguins_summarise_across &lt;- penguins %&gt;% dplyr::group_by(species) %&gt;% summarize(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) 1.8.16 bind_rows() e bind_cols() Muitas vezes teremos de combinar duas ou mais tabelas de dados. Podemos utilizar as funções Base R rbind() e cbind(), como vimos. Entretanto, pode ser interessante avançar para as funções dplyr::bind_rows() e dplyr::bind_cols() do formato tidyverse. A ideia é muito semelhante: a primeira função combina dados por linhas e a segunda por colunas. Entretanto, há vantagens no uso dessas funções, como a identificação das linhas pelo argumento .id para a primeira função, e a conferência do nome das colunas pelo argumento .name_repair para a segunda função. # Selecionar as linhas para dois tibbles penguins_01 &lt;- dplyr::slice(penguins, 1:5) penguins_02 &lt;- dplyr::slice(penguins, 51:55) # Combinar as linhas penguins_bind_rows &lt;- dplyr::bind_rows(penguins_01, penguins_02, .id = &quot;id&quot;) # Combinar as colunas penguins_bind_cols &lt;- dplyr::bind_cols(penguins_01, penguins_02, .name_repair = &quot;unique&quot;) 1.8.17 *_join() Finalmente, veremos o último conjunto de funções do pacote dplyr, a junção de tabelas. Nessa operação, fazemos a combinação de pares de conjunto de dados tabulares por uma ou mais colunas chaves. Há dois tipos de junções: junção de mutação e junção de filtragem. A junção de mutação primeiro combina as observações por suas chaves e, em seguida, copia as variáveis (colunas) de uma tabela para a outra. É fundamental destacar a importância da coluna chave, que é indicada pelo argumento by. Essa coluna deve conter elementos que sejam comuns às duas tabelas para que haja a combinação dos elementos. Existem quatro tipos de junções, que são realizadas pelas funções: dplyr::inner_join(), dplyr::left_join(), dplyr::full_join() e dplyr::right_join(), e que podem ser representadas na Figura 1.3. Figura 1.3: Diferentes tipos de joins, representados com um diagrama de Venn. Adaptado de: Wickham and Grolemund (2017). Considerando a nomenclatura de duas tabelas de dados por x e y, temos: inner_join(x, y): mantém apenas as observações em x e em y left_join(x, y): mantém todas as observações em x right_join(x, y): mantém todas as observações em y full_join(x, y): mantém todas as observações em x e em y Aqui, vamos demostrar apenas a função dplyr::left_join(), combinando um tibble de coordenadas geográficas das ilhas com o conjunto de dados do penguins. # Adicionar uma coluna chave de ids penguin_islands &lt;- tibble( island = c(&quot;Torgersen&quot;, &quot;Biscoe&quot;, &quot;Dream&quot;, &quot;Alpha&quot;), longitude = c(-64.083333, -63.775636, -64.233333, -63), latitude = c(-64.766667, -64.818569, -64.733333, -64.316667) ) # Junção - left penguins_left_join &lt;- dplyr::left_join(penguins, penguin_islands, by = &quot;island&quot;) Já a junção de filtragem combina as observações da mesma maneira que as junções de mutação, mas afetam as observações (linhas), não as variáveis (colunas). Existem dois tipos. semi_join(x, y): mantém todas as observações em x que têm uma correspondência em y anti_join(x, y): elimina todas as observações em x que têm uma correspondência em y Semi-joins são úteis para corresponder tabelas de resumo filtradas de volta às linhas originais, removendo as linhas que não estavam antes do join. Anti-joins são úteis para diagnosticar incompatibilidades de junção, por exemplo, ao verificar os elementos que não combinam entre duas tabelas de dados. 1.8.18 Operações de conjuntos e comparação de dados Temos ainda operações de conjuntos e comparação de dados. union(x, y): retorna todas as linhas que aparecem em x, y ou mais dos conjuntos de dados interesect(x, y): retorna apenas as linhas que aparecem em x e em y setdiff(x, y): retorna as linhas que aparecem x, mas não em y setequal(x, y): retorna se x e y são iguais e quais suas diferenças Para se aprofundar no tema, recomendamos a leitura do capítulo 13 Relational data de Wickham &amp; Grolemund (2017). 1.9 stringr O pacote stringr fornece um conjunto de funções para a manipulação de caracteres ou strings. O pacote concentra-se nas funções de manipulação mais importantes e comumente usadas. Para funções mais específicas, recomenda-se usar o pacote stringi, que fornece um conjunto mais abrangente de funções. As funções do stringr podem ser agrupadas em algumas operações para tarefas específicas como correspondência de padrões, retirar e acrescentar espaços em branco, mudar maiúsculas e minúsculas, além de outras operações. Todas as funções deste pacote são listadas na página de referência do pacote. Demonstraremos algumas funções para algumas operações mais comuns, utilizando um vetor de um elemento, com o string “penguins.” Podemos explorar o comprimento de strings com a função stringr::str_length(). # Comprimento stringr::str_length(string = &quot;penguins&quot;) ## [1] 8 Extrair um string por sua posição usando a função stringr::str_sub() ou por um padrão com stringr::str_extract(). # Extrair pela posição stringr::str_sub(string = &quot;penguins&quot;, end = 3) ## [1] &quot;pen&quot; # Extrair por padrão stringr::str_extract(string = &quot;penguins&quot;, pattern = &quot;p&quot;) ## [1] &quot;p&quot; Substituir strings por outros strings com stringr::str_replace(). # Substituir stringr::str_replace(string = &quot;penguins&quot;, pattern = &quot;i&quot;, replacement = &quot;y&quot;) ## [1] &quot;penguyns&quot; Separar strings por um padrão com a função stringr::str_split(). # Separar stringr::str_split(string = &quot;p-e-n-g-u-i-n-s&quot;, pattern = &quot;-&quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] &quot;p&quot; &quot;e&quot; &quot;n&quot; &quot;g&quot; &quot;u&quot; &quot;i&quot; &quot;n&quot; &quot;s&quot; Inserir espaços em brancos pela esquerda, direita ou ambos com a função stringr::str_pad(). # Inserir espacos em branco stringr::str_pad(string = &quot;penguins&quot;, width = 10, side = &quot;left&quot;) ## [1] &quot; penguins&quot; stringr::str_pad(string = &quot;penguins&quot;, width = 10, side = &quot;right&quot;) ## [1] &quot;penguins &quot; stringr::str_pad(string = &quot;penguins&quot;, width = 10, side = &quot;both&quot;) ## [1] &quot; penguins &quot; Também podemos remover espaços em branco da esquerda, direita ou ambos, utilizando stringr::str_trim(). # Remover espacos em branco stringr::str_trim(string = &quot; penguins &quot;, side = &quot;left&quot;) ## [1] &quot;penguins &quot; stringr::str_trim(string = &quot; penguins &quot;, side = &quot;right&quot;) ## [1] &quot; penguins&quot; stringr::str_trim(string = &quot; penguins &quot;, side = &quot;both&quot;) ## [1] &quot;penguins&quot; Podemos também alterar minúsculas e maiúsculas em diferentes posições do string, com várias funções. # Alterar minúsculas e maiúsculas stringr::str_to_lower(string = &quot;Penguins&quot;) ## [1] &quot;penguins&quot; stringr::str_to_upper(string = &quot;penguins&quot;) ## [1] &quot;PENGUINS&quot; stringr::str_to_sentence(string = &quot;penGuins&quot;) ## [1] &quot;Penguins&quot; stringr::str_to_title(string = &quot;penGuins&quot;) ## [1] &quot;Penguins&quot; Podemos ainda ordenar os elementos de um vetor por ordem alfabética de forma crescente ou decrescente, usando stringr::str_sort(). # Ordenar stringr::str_sort(x = letters) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; ## [25] &quot;y&quot; &quot;z&quot; stringr::str_sort(x = letters, dec = TRUE) ## [1] &quot;z&quot; &quot;y&quot; &quot;x&quot; &quot;w&quot; &quot;v&quot; &quot;u&quot; &quot;t&quot; &quot;s&quot; &quot;r&quot; &quot;q&quot; &quot;p&quot; &quot;o&quot; &quot;n&quot; &quot;m&quot; &quot;l&quot; &quot;k&quot; &quot;j&quot; &quot;i&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; &quot;e&quot; &quot;d&quot; &quot;c&quot; ## [25] &quot;b&quot; &quot;a&quot; Podemos ainda utilizar essas funções em complemento com o pacote dplyr, para alterar os strings de colunas ou nome das colunas. # Alterar valores das colunas penguins_stringr_valores &lt;- penguins %&gt;% dplyr::mutate(species = stringr::str_to_lower(species)) # Alterar nome das colunas penguins_stringr_nomes &lt;- penguins %&gt;% dplyr::rename_with(stringr::str_to_title) Para se aprofundar no tema, recomendamos a leitura do capítulo 14 Strings de Wickham &amp; Grolemund (2017). 1.10 forcats O pacote forcats fornece um conjunto de ferramentas úteis para facilitar a manipulação de fatores. Como dito anteriormente, usamos fatores geralmente quando temos dados categóricos, que são variáveis que possuem um conjunto de valores fixos e conhecidos. As funções são utilizadas principalmente para: mudar a ordem dos níveis, mudar os valores dos níveis, adicionar e remover níveis, combinar múltiplos níveis, além de outras operações. Todas as funções deste pacote são listadas na página de referência do pacote. Vamos utilizar ainda os dados penguins e penguins_raw para exemplificar o uso do pacote forcats. # Carregar o pacote palmerpenguins library(palmerpenguins) Primeiramente, vamos converter dados de string para fator, utilizando a função forcats::as_factor(). # String forcats::as_factor(penguins_raw$Species) %&gt;% head() ## [1] Adelie Penguin (Pygoscelis adeliae) Adelie Penguin (Pygoscelis adeliae) ## [3] Adelie Penguin (Pygoscelis adeliae) Adelie Penguin (Pygoscelis adeliae) ## [5] Adelie Penguin (Pygoscelis adeliae) Adelie Penguin (Pygoscelis adeliae) ## 3 Levels: Adelie Penguin (Pygoscelis adeliae) ... Chinstrap penguin (Pygoscelis antarctica) Podemos facilmente mudar o nome dos níveis utilizando a função forcats::fct_recode(). # Mudar o nome dos níveis forcats::fct_recode(penguins$species, a = &quot;Adelie&quot;, c = &quot;Chinstrap&quot;, g = &quot;Gentoo&quot;) %&gt;% head() ## [1] a a a a a a ## Levels: a c g Para inverter os níveis, usamos a função forcats::fct_rev(). # Inverter os níveis forcats::fct_rev(penguins$species) %&gt;% head() ## [1] Adelie Adelie Adelie Adelie Adelie Adelie ## Levels: Gentoo Chinstrap Adelie Uma operação muito comum com fatores é mudar a ordem dos níveis. Quando precisamos especificar a ordem dos níveis, podemos fazer essa operação manualmente com a função forcats::fct_relevel(). # Especificar a ordem dos níveis forcats::fct_relevel(penguins$species, &quot;Chinstrap&quot;, &quot;Gentoo&quot;, &quot;Adelie&quot;) %&gt;% head() ## [1] Adelie Adelie Adelie Adelie Adelie Adelie ## Levels: Chinstrap Gentoo Adelie Como vimos, a reordenação dos níveis pode ser feita manualmente. Mas existem outras formas automáticas de reordenação seguindo algumas regras, para as quais existem funções específicas. forcats::fct_inorder(): pela ordem em que aparecem pela primeira vez forcats::fct_infreq(): por número de observações com cada nível (decrescente, i.e., o maior primeiro) forcats::fct_inseq(): pelo valor numérico do nível # Níveis pela ordem em que aparecem forcats::fct_inorder(penguins$species) %&gt;% head() ## [1] Adelie Adelie Adelie Adelie Adelie Adelie ## Levels: Adelie Gentoo Chinstrap # Ordem (decrescente) de frequência forcats::fct_infreq(penguins$species) %&gt;% head() ## [1] Adelie Adelie Adelie Adelie Adelie Adelie ## Levels: Adelie Gentoo Chinstrap Por fim, podemos fazer a agregação de níveis raros em um nível utilizando a função forcats::fct_lump(). # Agregalção de níveis raros em um nível forcats::fct_lump(penguins$species) %&gt;% head() ## [1] Adelie Adelie Adelie Adelie Adelie Adelie ## Levels: Adelie Gentoo Other Podemos ainda utilizar essas funções em complemento com o pacote dplyr para fazer manipulações de fatores nas colunas de tibbles. # Transformar várias colunas em fator penguins_raw_multi_factor &lt;- penguins_raw %&gt;% dplyr::mutate(across(where(is.character), forcats::as_factor)) Para se aprofundar no tema, recomendamos a leitura do capítulo 15 Factors de Wickham &amp; Grolemund (2017). 1.11 lubridate O pacote lubridate fornece um conjunto de funções para a manipulação de dados de data e horário. Dessa forma, esse pacote facilita a manipulação dessa classe de dado no R, pois geralmente esses dados não são intuitivos e mudam dependendo do tipo de objeto de data e horário. Além disso, os métodos que usam datas e horários devem levar em consideração fusos horários, anos bissextos, horários de verão, além de outras particularidades. Existem diversas funções nesse pacote, sendo as mesmas focadas em: transformações de data/horário, componentes, arredondamentos, durações, períodos, intervalos, além de muitas outras funções específicas. Todas as funções deste pacote são listadas na página de referência do pacote. Apesar de estar inserido no escopo do tidyverse, este pacote não é instalado com os demais, requisitando sua instalação solo. # Instalar install.packages(&quot;lubridate&quot;) # Carregar library(lubridate) Existem três tipos de dados data/horário: Data: tempo em dias, meses e anos &lt;date&gt; Horário: tempo dentro de um dia &lt;time&gt; Data-horário: tempo em um instante (data mais tempo) &lt;dttm&gt; Para trabalhar exclusivamente com horários, podemos utilizar o pacote hms. É fundamental também destacar que algumas letras terão um significado temporal, sendo abreviações de diferentes períodos em inglês: year (ano), month (mês), weak (semana), day (dia), hour (hora), minute (minuto), e second (segundo). Para acessar a informação da data e horários atuais podemos utilizar as funções lubridate::today() e lubridate::now(). # Extrair a data nesse instante lubridate::today() ## [1] &quot;2021-05-27&quot; # Extrair a data e tempo nesse instante lubridate::now() ## [1] &quot;2021-05-27 01:37:47 -03&quot; Além dessas informações instantâneas, existem três maneiras de criar um dado de data/horário. De um string De componentes individuais de data e horário De um objeto de data/horário existente Os dados de data/horário geralmente estão no formato de strings. Podemos transformar os dados especificando a ordem dos seus componentes, ou seja, a ordem em que ano, mês e dia aparecem no string, usando as letras y (ano), m (mês) e d (dia) na mesma ordem, por exemplo, lubridate::dmy(). # Strings e números para datas lubridate::dmy(&quot;03-03-2021&quot;) ## [1] &quot;2021-03-03&quot; Essas funções também aceitam números sem aspas, além de serem muito versáteis e funcionarem em outros diversos formatos. # Strings e números para datas lubridate::dmy(&quot;03-Mar-2021&quot;) lubridate::dmy(03032021) lubridate::dmy(&quot;03032021&quot;) lubridate::dmy(&quot;03/03/2021&quot;) lubridate::dmy(&quot;03.03.2021&quot;) Além da data, podemos especificar horários atrelados a essas datas. Para criar uma data com horário adicionamos um underscore (_) e os h (hora), m (minuto) e s (segundo) ao nome da função, além do argumento tz para especificar o fuso horário (tema tratado mais adiante nessa seção). # Especificar horários e fuso horário lubridate::dmy_h(&quot;03-03-2021 13&quot;) ## [1] &quot;2021-03-03 13:00:00 UTC&quot; lubridate::dmy_hm(&quot;03-03-2021 13:32&quot;) ## [1] &quot;2021-03-03 13:32:00 UTC&quot; lubridate::dmy_hms(&quot;03-03-2021 13:32:01&quot;) ## [1] &quot;2021-03-03 13:32:01 UTC&quot; lubridate::dmy_hms(&quot;03-03-2021 13:32:01&quot;, tz = &quot;America/Sao_Paulo&quot;) ## [1] &quot;2021-03-03 13:32:01 -03&quot; Podemos ainda ter componentes individuais de data/horário em múltiplas colunas. Para realizar essa transformação, podemos usar as funções lubridate::make_date() e lubridate::make_datetime(). # Dados com componentes individuais dados &lt;- tibble::tibble( ano = c(2021, 2021, 2021), mes = c(1, 2, 3), dia = c(12, 20, 31), hora = c(2, 14, 18), minuto = c(2, 44, 55) ) # Data de componentes individuais dados %&gt;% dplyr::mutate(data = lubridate::make_datetime(ano, mes, dia, hora, minuto)) ## # A tibble: 3 x 6 ## ano mes dia hora minuto data ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2021 1 12 2 2 2021-01-12 02:02:00 ## 2 2021 2 20 14 44 2021-02-20 14:44:00 ## 3 2021 3 31 18 55 2021-03-31 18:55:00 Por fim, podemo criar datas modificando entre data/horário e data, utilizando as funções lubridate::as_datetime() e lubridate::as_date(). # Data para data-horário lubridate::as_datetime(today()) ## [1] &quot;2021-05-27 UTC&quot; # Data-horário para data lubridate::as_date(now()) ## [1] &quot;2021-05-27&quot; Uma vez que entendemos como podemos criar dados de data/horário, podemos explorar funções para acessar e definir componentes individuais. Para essa tarefa existe uma grande quantidade de funções para acessar de partes específicas de datas e horários. year(): acessa o ano month(): acessa o mês month(): acessa o dia yday(): acessa o dia do ano mday(): acessa o dia do mês wday(): acessa o dia da semana hour(): acessa as horas minute(): acessa os minutos second(): acessa os segundos # Extrair lubridate::year(now()) ## [1] 2021 lubridate::month(now()) ## [1] 5 lubridate::month(now(), label = TRUE) ## [1] May ## Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec lubridate::day(now()) ## [1] 27 lubridate::wday(now()) ## [1] 5 lubridate::wday(now(), label = TRUE) ## [1] Thu ## Levels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat lubridate::second(now()) ## [1] 48.03987 Além de acessar componentes de datas e horários, podemos usar essas funções para fazer a inclusão de informações de datas e horários. # Data data &lt;- dmy_hms(&quot;04-03-2021 01:04:56&quot;) # Incluir lubridate::year(data) &lt;- 2020 lubridate::month(data) &lt;- 01 lubridate::hour(data) &lt;- 13 Mais convenientemente, podemos utilizar a função update() para alterar vários valores de uma vez. # Incluir vários valores update(data, year = 2020, month = 1, mday = 1, hour = 1) ## [1] &quot;2020-01-01 01:04:56 UTC&quot; Muitas vezes precisamos fazer operações com datas, como a aritmética com datas: subtração, adição e divisão. Para tanto, é preciso entender três classes importantes que representam intervalos de tempo. Durações: representam um número exato de segundos Períodos: representam unidades humanas como semanas e meses Intervalos: representam um ponto inicial e final Quando fazemos uma subtração de datas, criamos um objeto da classe difftime. Essa classe pode ser um pouco complicada de trabalhar, então dentro do lubridate, podemos usar funções que convertem essa classe em duração, da classe Duration. As durações sempre registram o intervalo de tempo em segundos, com alguma unidade de tempo maior entre parênteses. Há uma série de funções para tratar dessa classe. duration(): cria data em duração as.duration(): converte datas em duração dyears(): duração de anos dmonths(): duração de meses dweeks(): duração de semanas ddays(): duração de dias dhours(): duração de horas dminutes(): duração de minutos dseconds(): duração de segundos # Subtração de datas tempo_estudando_r &lt;- lubridate::today() - lubridate::dmy(&quot;30-11-2011&quot;) # Conversão para duração tempo_estudando_r_dur &lt;- lubridate::as.duration(tempo_estudando_r) # Criando durações lubridate::duration(90, &quot;seconds&quot;) ## [1] &quot;90s (~1.5 minutes)&quot; lubridate::duration(1.5, &quot;minutes&quot;) ## [1] &quot;90s (~1.5 minutes)&quot; lubridate::duration(1, &quot;days&quot;) ## [1] &quot;86400s (~1 days)&quot; # Transformação da duração lubridate::dseconds(100) ## [1] &quot;100s (~1.67 minutes)&quot; lubridate::dminutes(100) ## [1] &quot;6000s (~1.67 hours)&quot; lubridate::dhours(100) ## [1] &quot;360000s (~4.17 days)&quot; lubridate::ddays(100) ## [1] &quot;8640000s (~14.29 weeks)&quot; lubridate::dweeks(100) ## [1] &quot;60480000s (~1.92 years)&quot; lubridate::dyears(100) ## [1] &quot;3155760000s (~100 years)&quot; Podemos ainda utilizar as durações para fazer operações aritméticas com datas como adição, subtração e multiplicação. # Somando durações a datas lubridate::today() + lubridate::ddays(1) ## [1] &quot;2021-05-28&quot; # Subtraindo durações de datas lubridate::today() - lubridate::dyears(1) ## [1] &quot;2020-05-26 18:00:00 UTC&quot; # Multiplicando durações 2 * dyears(2) ## [1] &quot;126230400s (~4 years)&quot; Além das durações, podemos usar períodos, que são extensões de tempo não fixados em segundos como as durações, mas flexíveis, com o tempo em dias, semanas, meses ou anos, permitindo uma interpretação mais intuitiva das datas. Novamente, há uma série de funções para realizar essas operações. period(): cria data em período as.period(): converte datas em período seconds(): período em segundos minutes(): período em minutos hours(): período em horas days(): período em dias weeks(): período em semanas months(): período em meses years(): período em anos # Criando períodos period(c(90, 5), c(&quot;second&quot;, &quot;minute&quot;)) ## [1] &quot;5M 90S&quot; period(c(3, 1, 2, 13, 1), c(&quot;second&quot;, &quot;minute&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;)) ## [1] &quot;20d 2H 1M 3S&quot; # Transformação de períodos lubridate::seconds(100) ## [1] &quot;100S&quot; lubridate::minutes(100) ## [1] &quot;100M 0S&quot; lubridate::hours(100) ## [1] &quot;100H 0M 0S&quot; lubridate::days(100) ## [1] &quot;100d 0H 0M 0S&quot; lubridate::weeks(100) ## [1] &quot;700d 0H 0M 0S&quot; lubridate::years(100) ## [1] &quot;100y 0m 0d 0H 0M 0S&quot; Além disso, podemos fazer operações com os períodos, somando e subtraindo. # Somando datas lubridate::today() + lubridate::weeks(10) ## [1] &quot;2021-08-05&quot; # Subtraindo datas lubridate::today() - lubridate::weeks(10) ## [1] &quot;2021-03-18&quot; # Criando datas recorrentes lubridate::today() + lubridate::weeks(0:10) ## [1] &quot;2021-05-27&quot; &quot;2021-06-03&quot; &quot;2021-06-10&quot; &quot;2021-06-17&quot; &quot;2021-06-24&quot; &quot;2021-07-01&quot; &quot;2021-07-08&quot; ## [8] &quot;2021-07-15&quot; &quot;2021-07-22&quot; &quot;2021-07-29&quot; &quot;2021-08-05&quot; Por fim, intervalos são períodos de tempo limitados por duas datas, possuindo uma duração com um ponto de partida, que o faz preciso para determinar uma duração. Intervalos são objetos da classe Interval. Da mesma forma que para duração e períodos, há uma série de funções para realizar essas operações. interval(): cria data em intervalo %--%: cria data em intervalo as.interval(): converte datas em intervalo int_start(): acessa ou atribui data inicial de um intervalo int_end(): acessa ou atribui data final de um intervalo int_length(): comprimento de um intervalo em segundos int_flip(): inverte a ordem da data de início e da data de término em um intervalo int_shift(): desloca as datas de início e término de um intervalo int_aligns(): testa se dois intervalos compartilham um ponto final int_standardize(): garante que todos os intervalos sejam positivos int_diff(): retorna os intervalos que ocorrem entre os elementos de data/horário int_overlaps(): testa se dois intervalos se sobrepõem %within%: testa se o primeiro intervalo está contido no segundo # Criando duas datas - início de estudos do R e nascimento do meu filho r_inicio &lt;- lubridate::dmy(&quot;30-11-2011&quot;) filho_nascimento &lt;- lubridate::dmy(&quot;26-09-2013&quot;) r_hoje &lt;- lubridate::today() # Criando intervalos - interval r_intervalo &lt;- lubridate::interval(r_inicio, r_hoje) # Criando intervalos - interval %--% filho_intervalo &lt;- filho_nascimento %--% lubridate::today() # Operações com intervalos lubridate::int_start(r_intervalo) ## [1] &quot;2011-11-30 UTC&quot; lubridate::int_end(r_intervalo) ## [1] &quot;2021-05-27 UTC&quot; lubridate::int_length(r_intervalo) ## [1] 299462400 lubridate::int_flip(r_intervalo) ## [1] 2021-05-27 UTC--2011-11-30 UTC lubridate::int_shift(r_intervalo, duration(days = 30)) ## [1] 2011-12-30 UTC--2021-06-26 UTC Uma operação de destaque é verificar a sobreposição entre dois intervalos. # Verificar sobreposição - int_overlaps lubridate::int_overlaps(r_intervalo, filho_intervalo) ## [1] TRUE # Verificar se intervalo está contido r_intervalo %within% filho_intervalo ## [1] FALSE filho_intervalo %within% r_intervalo ## [1] TRUE Podemos ainda calcular quantos períodos existem dentro de um intervalo, utilizando as operações de / e %/%. # Períodos dentro de um intervalo - anos r_intervalo / lubridate::years() ## [1] 9.487671 r_intervalo %/% lubridate::years() ## [1] 9 # Períodos dentro de um intervalo - dias e semandas filho_intervalo / lubridate::days() ## [1] 2800 filho_intervalo / lubridate::weeks() ## [1] 400 Ainda podemos fazer transformações dos dados para períodos e ter todas as unidades de data e tempo que o intervalo compreende. # Tempo total estudando R lubridate::as.period(r_intervalo) ## [1] &quot;9y 5m 27d 0H 0M 0S&quot; # Idade do meu filho lubridate::as.period(filho_intervalo) ## [1] &quot;7y 8m 1d 0H 0M 0S&quot; Por fim, fusos horários tendem a ser um fator complicador quando precisamos analisar informações instantâneas de tempo (horário) de outras partes do planeta, ou mesmo fazer conversões dos horários. No lubridate há funções para ajudar nesse sentido. Para isso, podemos utilizar a função lubridate::with_tz(), e no argumento tzone informar o fuso horário para a transformação do horário. Podemos descobrir o fuso horário que o R está considerando com a função Sys.timezone(). # Fuso horário no R Sys.timezone() ## [1] &quot;America/Sao_Paulo&quot; No R há uma listagem dos nomes dos fusos horários que podemos utilizar no argumento tzone para diferentes fusos horários. # Verificar os fuso horários length(OlsonNames()) ## [1] 607 head(OlsonNames()) ## [1] &quot;Africa/Abidjan&quot; &quot;Africa/Accra&quot; &quot;Africa/Addis_Ababa&quot; &quot;Africa/Algiers&quot; ## [5] &quot;Africa/Asmara&quot; &quot;Africa/Asmera&quot; Podemos nos perguntar que horas são em outra parte do globo ou fazer as conversões facilmente no lubridate. # Que horas são em... lubridate::with_tz(lubridate::now(), tzone = &quot;America/Sao_Paulo&quot;) ## [1] &quot;2021-05-27 01:37:48 -03&quot; lubridate::with_tz(lubridate::now(), tzone = &quot;GMT&quot;) ## [1] &quot;2021-05-27 04:37:48 GMT&quot; lubridate::with_tz(lubridate::now(), tzone = &quot;Europe/Berlin&quot;) ## [1] &quot;2021-05-27 06:37:48 CEST&quot; # Altera o fuso sem mudar a hora lubridate::force_tz(lubridate::now(), tzone = &quot;GMT&quot;) ## [1] &quot;2021-05-27 01:37:48 GMT&quot; Para se aprofundar no tema, recomendamos a leitura do capítulo 16 Dates and times de Wickham &amp; Grolemund (2017). 1.12 purrr O pacote purrr implementa a Programação Funcional no R, fornecendo um conjunto completo e consistente de ferramentas para trabalhar com funções e vetores. A programação funcional é um assunto bastante extenso, sendo mais conhecido no R pela família de funções purrr::map(), que permite substituir muitos loops for por um código mais sucinto e fácil de ler. Não focaremos aqui nas outras funções. Todas as funções deste pacote são listadas na página de referência do pacote. Um loop for pode ser entendido como uma iteração: um bloco de códigos é repetido mudando um contador de uma lista de possibilidades. Vamos exemplificar com uma iteração bem simples, onde imprimiremos no console os valores de 1 a 10, utilizando a função for(), um contador i em um vetor de dez números 1:10 que será iterado, no bloco de códigos definido entre {}, usando a função print() para imprimir os valores. A ideia é bastante simples: a função for() vai atribuir o primeiro valor da lista ao contador i, esse contador será utilizado em todo o bloco de códigos. Quando o bloco terminar, o segundo valor é atribuído ao contador i e entra no bloco de códigos, repetindo esse processo até que todos os elementos da lista tenham sido atribuídos ao contador. # Loop for for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Com essa ideia em mente, a programação funcional utilizando a função purrr::map(). O mesmo for ficaria dessa forma. # Loop for com map purrr::map(.x = 1:10, .f = print) Nessa estrutura, temos: map(.x, .f) .x: um vetor, lista ou data frame .f: uma função Num outro exemplo, aplicaremos a função sum() para somar os valores de vários elementos de uma lista. # Função map x &lt;- list(1:5, c(4, 5, 7), c(1, 1, 1), c(2, 2, 2, 2, 2)) purrr::map(x, sum) ## [[1]] ## [1] 15 ## ## [[2]] ## [1] 16 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 10 Há diferente tipos de retornos da família purrr::map(). map(): retorna uma lista map_chr(): retorna um vetor de strings map_dbl(): retorna um vetor numérico (double) map_int(): retorna um vetor numérico (integer) map_lgl(): retorna um vetor lógico map_dfr(): retorna um data frame (por linhas) map_dfc(): retorna um data frame (por colunas) # Variações da função map purrr::map_dbl(x, sum) ## [1] 15 16 3 10 purrr::map_chr(x, paste, collapse = &quot; &quot;) ## [1] &quot;1 2 3 4 5&quot; &quot;4 5 7&quot; &quot;1 1 1&quot; &quot;2 2 2 2 2&quot; Essas funcionalidades já eram conhecidas no Base R pelas funções da família apply: apply(), lapply(), sapply(), vapply(), mapply(), rapply() e tapply(). Essas funções formam a base de combinações mais complexas e ajudam a realizar operações com poucas linhas de código, para diferentes retornos. Temos ainda duas variantes da função map(): purrr::map2() e purrr::pmap(), para duas ou mais listas, respectivamente. Como vimos para a primeira função, existem várias variações do sufixo para modificar o retorno da função. # Listas x &lt;- list(3, 5, 0, 1) y &lt;- list(3, 5, 0, 1) z &lt;- list(3, 5, 0, 1) # Função map2 purrr::map2_dbl(x, y, prod) ## [1] 9 25 0 1 # Função pmap purrr::pmap_dbl(list(x, y, z), prod) ## [1] 27 125 0 1 Essas funções podem ser usadas em conjunto para implementar rotinas de manipulação e análise de dados com poucas linhas de código, mas que não exploraremos em sua completude aqui. Listamos dois exemplos simples. # Resumo dos dados penguins %&gt;% dplyr::select(where(is.numeric)) %&gt;% tidyr::drop_na() %&gt;% purrr::map_dbl(mean) # Análise dos dados penguins %&gt;% dplyr::group_split(island, species) %&gt;% purrr::map(~ lm(bill_depth_mm ~ bill_length_mm, data = .x)) %&gt;% purrr::map(summary) %&gt;% purrr::map(&quot;r.squared&quot;) Para se aprofundar no tema, recomendamos a leitura do capítulo 21 Iteration de Wickham &amp; Grolemund (2017). 1.13 Exercícios Reescreva as operações abaixo utilizando pipes %&gt;%. log10(cumsum(1:100)) sum(sqrt(abs(rnorm(100)))) sum(sort(sample(1:10, 10000, rep = TRUE))) Use a função download.file() e unzip() para baixar e extrair o arquivo do data paper de médios e grandes mamíferos: ATLANTIC MAMMALS. Em seguinda, importe para o R, usando a função readxl::read_excel(). Use a função tibble::glimpse() para ter uma noção geral dos dados importados no item anterior. Compare os dados de penguins (palmerpenguins::penguins_raw e palmerpenguins::penguins). Monte uma série de funções dos pacotes tidyr e dplyr para fazer limpar os dados e fazer com que o primeiro dado seja igual ao segundo. Usando os dados de penguins (palmerpenguins::penguins), calcule a correlação de Pearson entre comprimento e profundidade do bico para cada espécie e para todas as espécies. Compare os índices de correlação para exemplificar o Paradoxo de Simpsom. Oficialmente a pandemia de COVID-19 começou no Brasil com o primeiro caso no dia 26 de fevereiro de 2020. Calcule quantos anos, meses, dias, semanas, horas, minutos e segundos se passou desde então. Calcule também quanto tempo se passou até você ser vacinado. 1.14 Para se aprofundar Listamos a seguir livros que recomendamos para seguir com sua aprendizagem em R e tidyverse. Português Curso-R. 2021. Ciência de Dados em R. [https://livro.curso-r.com/] Faria PD, Parga JPFA. 2020. Introdução à Linguagem R: seus fundamentos e sua prática. [https://www.researchgate.net/publication/345985082_Introducao_a_Linguagem_R_seus_fundamentos_e_sua_pratica] Oliveira PF, Guerra S, Mcdonnell, R. 2018. Ciência de dados com R – Introdução. IBPAD. [https://cdr.ibpad.com.br/] Inglês Grolemund G. 2017. The Essentials of Data Science: Knowledge Discovery Using R. Chapman and Hall/CRC. Holmes S, Huber W. 2019. Modern Statistics for Modern Biology. Cambridge University Press. [https://www.huber.embl.de/msmb/] Irizarry RA. 2019. Introduction to Data Science: Data Analysis and Prediction Algorithms with R. Chapman and Hall/CRC. [https://rafalab.github.io/dsbook/] Ismay C., Kim AY. 2019. Statistical Inference via Data Science: A ModernDive into R and the Tidyverse. Chapman and Hall/CRC. [https://moderndive.com/] Peng DP. 2020. R Programming for Data Science. [https://bookdown.org/rdpeng/rprogdatascience/] Wickham H, Grolemund G. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. [https://r4ds.had.co.nz/] Wright C, Ellis S, Hicks S &amp; Peng R D. 2021. Tidyverse Skills for Data Science in R. [https://jhudatascience.org/tidyversecourse/] Zumel N, Mount J. 2014. Practical Data Science with R Paperback. Manning. References "],["references.html", "References", " References "]]
