[["intro-r.html", "Capítulo 5 Introdução à linguagem R 5.1 Introdução 5.2 R e RStudio 5.3 Funcionamento da linguagem R 5.4 Estrutura e manipulação de objetos 5.5 Tidyverse 5.6 Exercícios 5.7 Material de R", " Capítulo 5 Introdução à linguagem R 5.1 Introdução O objetivo desta seção é apresentar aspectos básicos da linguagem R para que qualquer pessoa possa realizar todos os passos para a análise de dados nessa linguagem. Nela, abordaremos as questões mais básicas sobre a linguagem como: 1) R e RStudio, 2) funcionamento da linguagem, 3) estrutura e manipulação de objetos, 4) tidyverse e 5) principal material de R. Todo processo de aprendizagem torna-se mais efetivo quando a teoria é combinada com a prática, então recomendamos fortemente que você leitor, acompanhe os códigos e exercícios deste livro, ao mesmo tempo que os executa em seu computador, e não só os leia passivamente. Por motivos de espaço, não abordaremos todas as questões relacionadas ao uso da linguagem R nesta seção. Logo, aconselhamos que o leitor consulte o material sugerido no final dessa seção para se aprofundar. 5.2 R e RStudio Com o R é possível manipular e analisar dados, visualizar gráficos e escrever desde pequenas linhas de códigos até programas inteiros. O R é a versão em código aberto de uma linguagem de programação criada por John M. Chambers (Stanford University, CA, EUA), nos anos 1980 no Bell Labs, chamada de S, que contou com três versões: Old S (1976-1987), New S (1988-1997) e S4 (1998), utilizada na IDE S-PLUS (1988-2008). Essa linguagem tornou-se bastante popular e vários produtos comerciais que a usam estão disponíveis, como o S-PLUS, SPSS, STATA e SAS. No final dos anos 1990, Robert Gentleman e Ross Ihaka (Auckland University, NZ), iniciaram o desenvolvimento da versão free da linguagem S, com o seguinto histórico: Desenvolvimento (1997-2000), Versão 1 (2000-2004), Versão 2 (2004-2013), Versão 3 (2013-2020) e Versão 4 (2020). Para mais detalhes do histório de desenvolvimento do S e R, consultar Wickham (2013), sendo que atualmente a linguagem R é mantida por uma rede de colaboradores denominada R Core Team. A origem do nome R é desconhecida, mas reza que ao lançarem o nome da linguagem os autores se valeram da letra que vinha antes do S, uma vez que a linguagem R foi baseada nela, e utilizaram a letra “R.” Um aspecto digno de nota é que a linguagem R, ao contrário de outras linguagem como Fortran e C que são compiladas, é uma linguagem interpretada, o que a faz ser mais fácil de programar, pois processa linhas de comando e as transforma em linguagem de máquina (código binário que o computador efetivamente lê), apesar desse fato diminuir a velocidade de processamento. Para começarmos a trabalhar com o R é necessário baixá-lo na página do R Project. Então, acesse esse site, e em seguida, clique no link download R, que o levará à pagina do CRAN Mirros (Comprehensive R Archive Network). Escolha a página espelho do Brasil mais próxima de você para baixar o programa. Escolha agora o sistema operacional do seu computador (passos adicionais existem para diferentes distribuições Linux), para Windows, clique em base para finalmente chegar à página de download com a versão mais recente do R. Reserve algum tempo posteriormente para explorar esta página do R-Project. Existem vários livros dedicados a diversos assuntos baseados no R. Além disso, estão disponíveis manuais em diversas línguas para serem baixados gratuitamente. Como o R é um software livre, não existe a possibilidade de o usuário entrar em contato com um serviço de suporte de usuários, muito comuns em softwares pagos. Ao invés disso, existem várias listas de emails que fornecem suporte à comunidade de usuários. Nós, particularmente, recomendamos o ingresso nas seguintes listas: R-help, R-sig-ecology, e R-br. Este último representa um grupo de usuários brasileiro do programa R. Apesar de podemos utilizar o R com a IDE (Ambiente de Desenvolvimento Integrado - Integrated Development Environment) RGui que vem com a instalação da linguagem, para usuários Windows (Figura 5.1) ou no próprio terminal para usuários Linux e MacOS, existem alguns IDEs específicos para facilitar nosso uso dessa linguagem. Figura 5.1: Interface do RGui. Os números indicam: (1) R Script, (2) R Console, e (3) R Graphics. Entretanto, desde 2011, um IDE se tornou mais popular na comunidade: o RStudio (Figura 5.2). O RStudio possui algumas características que o tornam tão popular: várias janelas de visualização, marcação e preenchimento automático do script, integração com controle de versão, dentre outras opções. Para fazer o download do RStudio, acessamos o site, e escolhemos o instalador com base em nosso sistema operacional. Um último ponto técnico importante: para evitar possíveis erros, é interessante instalar primeiro a linguagem R, seguida do IDE RStudio. 5.3 Funcionamento da linguagem R Nesta seção veremos o principais conceitos para entender como a linguagem funciona ou como geralmente utilizamos o IDE RStudio no dia-a-dia, para executar nossas rotinas utilizando a linguagem R. Veremos então: 1) console, 2) script (editor/roteiro), 3) objetos (variáveis), 4) operadores, 5 ) funções, 6) pacotes, 7) ambiente (environment/workspace), 8) ajuda (help) e 9) citações. Antes de iniciarmos propriamente dito, é fundamental entendermos alguns pontos sobre as janelas e o funcionamento delas no RStudio (Figura 5.2). Figura 5.2: Interface do RStudio. Os números indicam: (1) janelas com abas de Script e R Markdown; (2) janela com abas de Console, Terminal e Jobs; (3) janela com abas de Environment, History, Conections e Tutorial; e (4) janela com abas de Files, Plots, Packages, Help e Viewer. Detalhando algumas dessas janelas, temos: Console: é onde os códigos são rodados e vemos as saídas Editor/Script: é onde escrevemos nossos códigos em R ou R Markdown Environment: painel com todos os objetos criados na sessão History: painel com o histórico dos comandos rodados Files: painel que mostra os arquivos no diretório de trabalho Plots: painel onde os gráficos são apresentados Packages: painel que lista os pacotes Help: painel onde a documentação das funções é exibida No RStudio, alguns atalhos são fundamentais para aumentar nossa produtividade: f1: abre o painel de Help ctrl + Enter: roda a linha selecionada no script ctrl + Shift + N: abre um novo script ctrl + S: salva um script ctrl + Z: desfaz uma operação ctrl + shift + Z: refaz uma operação alt + -: insere um sinal de atribuição (&lt;-) ctrl + Shift + M: insere um operador pipe (%&gt;%) ctrl + Shift + C: comenta uma linha no script - insere um (#) ctrl + Shift + R: insere uma sessão (# ———————-) ctrl + Shift + H: abre uma janela para selecionar o diretório de trabalho ctrl + Shift + f10: reinicia o console ctrl + L: limpa os comandos do console alt + Shift + K: abre uma janela com todos os atalhos disponíveis 5.3.1 Console O console é onde a versão da linguagem R instalada é carregada para executar os códigos da linguagem (Figura 5.2 (2)). Na janela do console irá aparecer o símbolo &gt; seguida de uma barra vertical | que fica piscando, onde iremos digitar ou enviar nossos códigos do script. Podemos fazer um pequeno exercício: vamos digitar 2 + 2, seguido da tecla Enter para que essa operação seja executada. 10 + 2 ## [1] 12 O resultado retorna o valor 12, precedido de um valor entre colchetes. Esses colchetes demonstram a posição do elemento numa sequência de valores. Se fizermos essa outra operação 1:42, o R vai criar uma sequência unitária de valores de 1 a 42. A depender da largura da janela do console, vai aparecer um número diferente entre colchete indicando sua posição na sequência: antes do 1 vai aparecer o [1], depois quando a sequência for quebrada, vai aparecer o número correspondente da posição do elemento, no nosso caso [26]. 1:42 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Podemos ver o hitórico dos código executados no Console na aba History (Figura 5.2 (3)). 5.3.2 Scripts Scripts são rascunhos dos códigos, e onde de fato os códigos são escritos e depois enviados ao console (Figura 5.2 (1)). Scripts são arquivos de texto simples, criados com a extensão (terminação) .R. Para criar um script basta ir em File &gt; New File &gt; R Script, ou clicando no ícone logo abaixo de File, ou ainda usando o atalho ctrl + shift + N. Uma vez escrito os códigos no script, podemos rodar esses códigos de duas formas: 1) todo o script de uma vez, clicando em Source ou usando o atalho ctrl + shift + enter; 2) a linha onde o cursos estiver posicionado, independente de sua posição naquela linha, clicando em Run ou usando o atalho ctrl + enter. Devemos sempre salvar nossos scripts, tomando por via de regra: primeiro criar o arquivo e depois ir salvando versão desse mesmo arquivo. Há diversos motivos para criar um script: continuar o desenvolvimento do mesmo em outro momento ou em outro computador, preservar trabalhos passados, ou ainda compartilhar seus códigos com outra pessoa. Para criar ou salvar um script basta ir em File &gt; Save, escolher um diretório e nome para o script, e salvar. Podemos ainda utilizar o atalho ctrl + S. Em relação aos scripts, ainda há os comentários, representados pelos símbolos # (hash) ou #' (hash-linha). Comentários não são lidos pelo console do R e são utilizados geralmente para descrever informações sobre dados ou funções, ou ainda para suprimir linhas de código. É interessante ter no início de cada script um cabeçalho identificando o objetivo ou análise, autor e data. #&#39; --- #&#39; title: capitulo 04 - introducao ao r #&#39; author: mauricio vancine #&#39; date: 2021-02-26 #&#39; --- Além disso, podemos usar comentários para adicionar informações sobre os códigos. # comentarios # o r nao le o codigo depois do # (hash) 42 # essas palavras nao sao executadas, apenas o 42 ## [1] 42 Um ponto muito importante é escrever os comentários sempre em inglês para tornar seu código mais reprodutível possível. Por fim, outro ponto fundamental é ter boas práticas de estilo de código. Quanto mais organizado e padronizado estiver os scripts, mais fácil de entendê-los e de procurar possíveis erros. Existem dois guias de boas práticas para adequadar seus scripts: Hadley Wickham e Google. 5.3.3 Operadores No R, temos cinco tipos de operadores: aritméticos, relacionais, lógicos, atribuição e diversos. Todos são descritos na Tabela 5.1. Tabela 5.1: Operadores no R. Operador Tipo Descrição + Aritmético Adição - Aritmético Subtração * Aritmético Multiplicação / Aritmético Divisão %% Aritmético Resto da divisão %/% Aritmético Divisão inteira ^ ou ** Aritmético Expoente &gt; Relacional Maior &lt; Relacional Menor &gt;= Relacional Maior ou igual &lt;= Relacional Menor ou igual == Relacional Igualdade != Relacional Diferença ! Lógico Lógico NÃO &amp; Lógico Lógico elementar E | Lógico Lógico elementar OU &amp;&amp; Lógico Lógico E || Lógico Lógico OU &lt;- ou = Atribuição Atribuição à esquerda &lt;&lt;- Atribuição Super atribuição à esquerda -&gt; Atribuição Atribuição à direita -&gt;&gt; Atribuição Super atribuição à direita : Diversos Sequência unitária %in% Diversos Elementos que pertencem a um vetor %*% Diversos Multiplar matriz com sua transposta %&gt;% Diversos pipe %–% Diversos Intervalo de datas Como exemplo, podemos fazer operações simples usando os operadores aritméticos. # operacoes aritmeticas 10 + 2 # adicao ## [1] 12 10 * 2 # multiplicacao ## [1] 20 Precisamos ficar atentos à dominância dos operadores aritméticos: ^ &gt;&gt; * ou / &gt;&gt; + ou -. Veja no exemplo abaixo como o uso dos parênteses mudam os resultados. # sem especificar - segue a ordem dos operadores 1 * 2 + 2 / 2 ^ 2 ## [1] 2.5 # especificando - segue a ordem dos parenteses ((1 * 2) + (2 / 2)) ^ 2 ## [1] 9 5.3.4 Objetos Objetos são palavras às quais são atribuídos dados. Essa atribuição possibilita a manipulação de dados ou resultados de análises. Iremos utilizar os símbolos &lt; (menor), seguido de - (menos), sem espaço, dessa forma &lt;-. Também podemos utilizar o símbolo de igual (=), mas não recomendamos, por não fazer parte das boas práticas de escrita de códigos em R. Podemos inserir essa combinação de símbolos com o atalho alt + -. Para demonstrar, vamos atribuir o valor 10 à palavra obj_10, e chamar esse objeto novamente para verificar seu conteúdo. # atribuicao - simbolo (&lt;-) obj_10 &lt;- 10 obj_10 ## [1] 10 Todos os objetos criados numa sessão do R ficam listados na aba Environment (Figura 5.2 (3)). Além disso, o RStudio possui a função auto complete, ou seja, podemos digitar as primeiras letras de um objeto (ou função) e em seguida apertar Tab para que o RStudio liste tudo que começar com essas letras. Dois pontos importantes sobre atribuições: primeiro, o R sobrescreve os valores dos objetos com o mesmo nome, deixando o objeto com o valor da segunda atribuição. # sobrescreve o valor dos objetos obj &lt;- 100 obj ## [1] 100 # obj agora vale 2 obj &lt;- 2 obj ## [1] 2 Segundo, o R tem limitações ao nomear objetos: nome de objetos só podem começar por letras (a-z ou A-Z) ou pontos (.) nome de objetos só podem conter letras (a-z ou A-Z), números (0-9), underscores (_) ou pontos (.) R é case-sensitive, i.e., ele difere letras maiúsculas de minúsculas. Assim, um objeto chamado “resposta” é diferente do objeto “RESPOSTA” devemos evitar acentos ou cedilha (ç) para facilitar a memorização dos objetos nome de objetos não podem ser iguais a nomes especies (break, else, FALSE, for, function, if, Inf, NA, NaN, next, repeat, return, TRUE, while) Podemos ainda utilizar objetos para fazer operações e criar novos objetos. Isso pode parecer um pouco confuso para os iniciantes na linguagem, mas é fundamental aprender essa lógica para passar para os próximos passos. # definir dois objetos va1 &lt;- 10 va2 &lt;- 2 # operacoes com objetos e atribuicao adi &lt;- va1 + va2 adi ## [1] 12 5.3.5 Funções Funções são códigos preparados para realizar uma tarefa de modo simples. Outra forma de entender uma função é: comandos que realizam operações em argumentos. A estrutura de uma função é muito similar à sintaxe usada em planilhas eletrônicas, sendo composta por: nome_da_funcao(argumento1, argumento2) Nome da função: remete ao que ela faz Parênteses: limitam a função Argumentos: onde a função irá atuar Vírgulas: separam os argumentos Os argumentos de uma função podem ser de dois tipos: Valores ou objetos: a função irá alterar os valores em si ou os valores atribuídos aos objetos Parâmetros: valores fixos que informam um método ou a realização de uma operação. Informa-se o nome desse argumento, seguido de “=” e um número, texto ou TRUE ou FALSE Alguns exemplos de argumentos como valores ou objetos. # funcoes - argumentos como valores # soma sum(10, 2) ## [1] 12 # funcoes - argumentos como objetos # soma sum(va1, va2) ## [1] 12 Alguns exemplos de argumentos como parâmetros. Note que apesar do valor do argumento ser o mesmo (10), seu efeito no resultado muda drasticamente. Aqui também é importante destacar um ponto: 1 podemos informar os argumentos sequencialmente, sem explicitar seus nomes, ou 2) independente da ordem, mas explicitando seus nomes. Entretanto, como no exemplo abaixo, devemos informar o nome do argumento (i.e., parâmetro), para que seu efeito seja o que desejamos. # funcoes - argumentos como parametros # repeticao - repita todos os elementos rep(x = 1:5, times = 10) ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 ## [39] 4 5 1 2 3 4 5 1 2 3 4 5 # repeticao - repita cada um dos elementos rep(x = 1:5, each = 10) ## [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 ## [39] 4 4 5 5 5 5 5 5 5 5 5 5 Um ponto fundamental, e que deve ser entendido nesse ponto, é o fluxo de atribuições do resultado da operação de funções a novos objetos. No desenvolvimento de qualquer script, grande parte da estrutura do mesmo será dessa forma: atribuição de dados &gt; operações com funções &gt; atribuição dos resultados a novos objetos &gt; operações com funções desses novos objetos &gt; atribuição dos resultados a novaos objetos….Ao entender esse funcionamento, começamos a entender como devemos pensar na organização do nosso script para montar as análises de que precisamos. # atribuicao dos resultados # repeticao rep_times &lt;- rep(x = 1:5, times = 10) rep_times ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 ## [39] 4 5 1 2 3 4 5 1 2 3 4 5 # somar e atribuir rep_times_soma &lt;- sum(rep_times) rep_times_soma ## [1] 150 # raiz e atribuir rep_times_soma_raiz &lt;- sqrt(rep_times_soma) rep_times_soma_raiz ## [1] 12.24745 Por fim, é fundamental também entender a origem das funções que usamos no R. Todas as funções são advindas de pacotes. Esses pacotes possuem duas origens. pacotes já instalados por padrão e que são carregados quando abrimos o R (R Base) pacotes que instalamos e carregamos com funções 5.3.6 Pacotes Pacotes são conjunto extras de funções para executar tarefas específicas, além do R Base. Existe literalmente milhares de pacotes para as mais diversas tarefas: estatística, ecologia, geografia, sensoriamento remoto, econometria, ciências sociais, gráficos, machine learning etc. Podemos verificar este vasto conjunto de pacotes pelo link que lista por nome os pacotes oficiais, ou seja, que passaram pelo crivo do CRAN. Existem ainda muito mais pacotes em desenvolvimento, geralmente disponibilizados em repositórios do GitHub ou GitLab. Primeiramente, com uma sessão do R sem carregar nenhum pacote extra, podemos verificar pacotes carregados pelo R Base utilizando a função search(). # verificar pacotes carregados search() Podemos ainda verificar todos pacotes instalados em seu computador com a função library(). # verificar pacotes instalados library() No R, quando tratamos de pacotes, devemos destacar dois conceitos: instalar um pacote e carregar um pacote. A instalação de pacotes possui algumas características: Instala-se apenas uma vez Precisa estar conectado à internet O nome do pacote precisa estar entre aspas Função (CRAN): install.packages() Vamos instalar o pacote vegan diretamente do CRAN, que possui funções para realizar uma série de análise em ecologia. Para isso, podemos ir em Tools &gt; Install Packages…, ou ir na aba Packages (Figura 5.2 (4)), procurar um pacote ou simplesmente clicar em “Install.” Podemos ainda utilizar a função install.packages(). # instalar pacotes install.packages(&quot;vegan&quot;) Uma vez instalado um pacote, não há necessidade de instalá-lo novamente. Entretanto, todas as vezes que iniciarmos uma sessão no R, precisamos carregar os pacotes com as funções que precisamos utilizar. O carregamento de pacotes possui algumas características: Carrega-se toda vez que se abre uma nova sessão do R Não precisa estar conectado à internet O nome do pacote não precisa estar entre aspas Funções: library() ou require() Vamos carregar o pacote vegan que instalamos anteriormente. Podemos ir na aba Packages (Figura 5.2 (4)) e ticar o pacote que queremos carregar ou utilizar a função library(). # carregar pacotes library(vegan) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-7 Como dissemos anteriormente, alguns pacotes em desenvlvimento encontram-se disponíveis em repositórios do GitHub ou GitLab. Para instalar pacotes do GitHub, por exemplo, precisamos instalar e carregar o pacote devtools. # instalar pacote devtools install.packages(&quot;devtools&quot;) # carregar pacote devtools library(devtools) Uma vez instalado e carregado este pacote, podemos instalar o pacote do GitHub, utilizando a função devtools::install_github(). Precisamos atentar para usar essa forma “nome_usuario/nome_repositorio,” retirados do link do repositório de interesse. Como exemplo, podemos instalar mesmo pacote vegan do repositório do GitHub vegandevs/vegan, e depois utilizar a função library() para carregá-lo normalmente. # instalar pacote do github devtools::install_github(&quot;vegandevs/vegan&quot;) # carregar pacote do github library(&quot;vegan&quot;) A maioria dos pacotes vem com bancos de dados que podem ser acessados pela função data(). Esses bancos de dados podem ser usados para testar as funções do pacote. Se estiver com dúvida na maneira como você deve preparar a planilha para realizar uma análise específica, entre no help da função e veja os conjuntos de dados que estão no exemplo desta função. Como exemplo, vamos carregar os dados dune do pacote vegan. # carregar dados de um pacote library(vegan) data(dune) dune[1:6, 1:6] ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere ## 1 1 0 0 0 0 0 ## 2 3 0 0 2 0 3 ## 3 0 4 0 7 0 2 ## 4 0 8 0 2 0 2 ## 5 2 0 0 0 4 2 ## 6 2 0 0 0 3 0 Se por algum motivo precisarmos desinstalar um pacote, podemos utilizar a função remove.packages(). Já para descarregar um pacote, podemos usar a função detach(). detach(&quot;package:vegan&quot;, unload = TRUE) E um último ponto fundamental de pacotes, diz respeito à atualização dos mesmos. Os pacotes são atualizados com frequência, e infelizmente ou felizmente (pois as atualizações podem oferecer algumas quebras entre pacotes), não se atualizam sozinhos. Muitas vezes, a instalação de um pacote pode depender da versão dos pacotes dependentes, e geralmente uma janela se abre que todos os pacotes dependentes sejam atualizados. Podemos ir na aba Packages (Figura 5.2 (4)) e clicar em “Update” ou usar a função update.packages(ask = FALSE) para atualizá-los, entretanto, essa é uma função que costuma demorar para terminar de rodar. # atualizacao dos pacotes instalados update.packages(ask = FALSE) 5.3.7 Ajuda (Help) Um importante passo para melhorar a usuabilidade e ter mais familiaridade com a linguagem R é aprender a usar a ajuda de cada função. Para tanto, podemos utilizar a função help() ou o operador ?, depois de ter carregado o pacote, para abri uma nova aba (Figura 5.2 (4)) que possui diversas informações sobre a função de interesse. O arquivo de ajuda do R possui geralmente nove ou dez tópicos, que nos auxiliam muito no entendimento dos dados de entrada, argumento e que operações estão sendo realizadas: Description: resumo da função Usage: como utilizar a função e quais os seus argumentos Arguments: detalha os argumentos e como os mesmos devem ser especifidados Details: detalhes importantes para se usar a função Value: mostra como interpretar a saída (output) da função (os resultados) Note: notas gerais sobre a função Authors: autores da função References: referências bibliográficas para os métodos usados pra construir a função See also: funções relacionadas Examples: exemplos do uso da função. Às vezes pode ser útil copiar esse trecho e colar no R para ver como funciona e como usar a função. Vamos realizar um exemplo, buscando o help da função aov(). # help help(aov) ?aov Além das funções, podemos buscas detalhes de um pacote em específico, para uma página simples do help utilizando a função help() ou o operador ?. Entretanto, para uma opção que ofereça uma descrição detalhada e um índice de todas as funções do pacote, podemos utilizar a função library(), mas agora utilizando o argumento “help,” indicamos o pacote de interesse entre aspas. # help do pacote help(vegan) ?vegan # help detalhado library(help = &quot;vegan&quot;) Outra ferramenta de busca é a página rseek, na qual é possível buscar por um termo não só nos pacotes do R, mas também em listas de emails, manuais, páginas na internet e livros sobre o programa. 5.3.8 Ambiente (Environment) O ambiente Environment como vimos é onde os objetos criados são armazenados. É fundamental entender que um objeto é uma alocação de um pequeno espaço na memória RAM do seu computador, onde o R armazenará um valor ou o resultado de uma função, utilizando o nome que definimos. Sendo assim, se fizermos uma atribuição de um objeto maior que o tamanho da memória RAM, esse objeto não será alocado, e a atribuição não funcionará. Existem opções para contornar esse tipo de limitação, mas não abordaremos aqui. Entretanto, podemos utilizar a função object.size() para saber quanto espaço nosso objeto criado está alocando de memória RAM. O conceito de função é tratado na seção seguinte. # tamanho de um objeto object.size(adi) ## 56 bytes Podemos listar todos os objetos criados com a função ls() ou objects(). # listar todos os objetos ls() ## [1] &quot;adi&quot; &quot;dune&quot; &quot;obj&quot; ## [4] &quot;obj_10&quot; &quot;rep_times&quot; &quot;rep_times_soma&quot; ## [7] &quot;rep_times_soma_raiz&quot; &quot;va1&quot; &quot;va2&quot; Podemos ainda remover objetos criados com a função rm() ou remove(). Ou ainda fazer uma função composta para remove todos os objetos do Environment. # remover um objeto rm(adi) # remover todos os objetos criados rm(list = ls()) Quando usamos a função ls(), nenhum objeto é lista. # listar todos os objetos ls() ## character(0) Toda a vez que fechamos o R, os objetos criados são apagados! Dessa forma, em algumas ocasiões, por exemplo, análises estatísticas que demoram grande tempo para serem realizadas, pode ser interessante exportar esses objetos criados. Podemos fazer isso de duas formas. A primeira delas vamos em Session -&gt; Save Workspace As… e escolhemos o nome do arquivo com nossos objetos, por exemplo, “meus_objetos.RData.” Na segunda, podemos utilizar a função save.image(). # exportar objetos save.image(&quot;meus_objetos.RData&quot;) Podemos fechar o RStudio tranquilamente, e quando formos trabalhar novamente, carregar os objetos criados indo em Session -&gt; Load Workspace…, ou utilizar a função load(). # importar objetos load(&quot;meus_objetos.RData&quot;) 5.3.9 Citações Ao utilizar o R para realizar alguma análise em seus estudos ecológicos, é fundamental a citação do mesmo. Para saber como citar exatamente o R em artigos, existe uma função denominada citation(), que provê um formato genérico de citação e um BibTeX para arquivos LaTeX e R Markdown. # citacao do r citation() ## ## To cite R in publications use: ## ## R Core Team (2021). R: A language and environment for statistical ## computing. R Foundation for Statistical Computing, Vienna, Austria. ## URL https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2021}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite it ## when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for ## citing R packages. No resultado dessa função, há uma mensagem muito interessante: “See also ‘citation(“pkgname”)’ for citing R packages.” Dessa forma, aconselhamos os usuários de R a citar também os pacotes que utilizaram em suas análises para dar os devidos créditos aos desenvolvedores das funções implementadas nos pacotes. Como exemplo, vamos ver como fica a citação do pacote vegan. # citacao do pacote vegan citation(&quot;vegan&quot;) ## ## To cite package &#39;vegan&#39; in publications use: ## ## Jari Oksanen, F. Guillaume Blanchet, Michael Friendly, Roeland Kindt, ## Pierre Legendre, Dan McGlinn, Peter R. Minchin, R. B. O&#39;Hara, Gavin ## L. Simpson, Peter Solymos, M. Henry H. Stevens, Eduard Szoecs and ## Helene Wagner (2020). vegan: Community Ecology Package. R package ## version 2.5-7. https://CRAN.R-project.org/package=vegan ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {vegan: Community Ecology Package}, ## author = {Jari Oksanen and F. Guillaume Blanchet and Michael Friendly and Roeland Kindt and Pierre Legendre and Dan McGlinn and Peter R. Minchin and R. B. O&#39;Hara and Gavin L. Simpson and Peter Solymos and M. Henry H. Stevens and Eduard Szoecs and Helene Wagner}, ## year = {2020}, ## note = {R package version 2.5-7}, ## url = {https://CRAN.R-project.org/package=vegan}, ## } ## ## ATTENTION: This citation information has been auto-generated from the ## package DESCRIPTION file and may need manual editing, see ## &#39;help(&quot;citation&quot;)&#39;. 5.3.10 Principais erros de iniciantes Errar quando se está iniciando com R é muito comum e faz parte do aprendizado. Entretanto, os erros nunca devem ser encarados como uma forma de desestímulo para continuar tentando. Todos nós, autores desse livro, e provavelmente usuários muito experientes já passaram por um momento em que se quer desistir de tudo. Jovem aprendiz de R, a única diferença entre você que está iniciando agora e nós que usamos há mais tempo, são as horas de uso (e raiva). O que temos a mais é experiência para olhar o erro, lê-lo e conseguir interpretar. Dessa forma, o ponto mais importante de quem está iniciando é ter paciência, calma, bom humor, ler e entender a mensagem de erro. Iremos listar aqui o que consideramos os princiais erros dos iniciantes no R. 1. Esquecer de completar uma função ou bloco de comandos Esquecer de completar uma função ou bloco de comandos é algo bem comum. Geralmente esquecemos de fechar aspas \"\" ou parênteses (), mas felizmente geralmente o R nos informa isso, indicando um símbolo de +. ` sum(1, 2 + ## Error: &lt;text&gt;:3:0: unexpected end of input ## 1: sum(1, 2 ## 2: + ## ^ 2. Esquecer da vírgula Outro erro bastante comum é esquecer de acrescentar a vírgula , para separar argumentos dentro de uma função, principalmente se estamos compondo várias função acopladas, i.e., uma função dentro da outra. sum(1 2) ## Error: &lt;text&gt;:1:7: unexpected numeric constant ## 1: sum(1 2 ## ^ 3. Chamar um objeto errado Pode parecer simples, mas esse é de longo o erro que as pessoas mais me interrompiam no laboratório. Quando estamos mais avançados e temos um longo script, fomos atribundo diversos objetos e em algum momento atribuímos um nome do qual não lembramos. E aí, quando chamamos o objeto ele não existe e devolve um erro, que pode ser facilmente identificado, como o exemplo abaixo. obj &lt;- 10 OBJ ## Error in eval(expr, envir, enclos): object &#39;OBJ&#39; not found 4. Esquecer de carregar um pacote Esse também um erro recorrentes, mesmo para usuários mais experientes. Em scripts de análises complexas, que requerem vários pacotes, geralmente esquecemos de um ou outro… A melhor forma de evitar esse tipo de erro é listar o pacotes que vamos precisar usar logo no início do script. # carregar dados data(dune) # funcao do pacote vegan decostand(dune, &quot;hell&quot;) ## Error in decostand(dune, &quot;hell&quot;): could not find function &quot;decostand&quot; Geralmente a mensagem de erro será de que a função não foi encontrada ou algo nesse sentido. Carregando o pacote, esse erro é contornado. # carregar o pacote library(vegan) # carregar dados data(dune) # funcao do pacote vegan decostand(dune[1:6, 1:6], &quot;hell&quot;) ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere ## 1 1.0000000 0.0000000 0 0.0000000 0.0000000 0.0000000 ## 2 0.6123724 0.0000000 0 0.5000000 0.0000000 0.6123724 ## 3 0.0000000 0.5547002 0 0.7337994 0.0000000 0.3922323 ## 4 0.0000000 0.8164966 0 0.4082483 0.0000000 0.4082483 ## 5 0.5000000 0.0000000 0 0.0000000 0.7071068 0.5000000 ## 6 0.6324555 0.0000000 0 0.0000000 0.7745967 0.0000000 5. Usar o nome da função de forma errônea Esse erro não é tão comum, mas pode ser incômodo às vezes. Algumas funções possuem nomes no padrão “Camel Case,” i.e., com letras maiúsculas para no meio do nome da função. Isso às vezes pode confundir, ou ainda, as funções podem ou não ser separadas com ., como row.names() e colnames(). Na seção de tidyverse, veremos que houve uma padronização nos nomes das funções para “Snake Case,” i.e, todas as funções possuem letras minúsculas, com palavras separadas por underscore _. colsums(dune) ## Error in colsums(dune): could not find function &quot;colsums&quot; colSums(dune) ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere Bromhord Chenalbu ## 16 48 5 36 21 13 15 1 ## Cirsarve Comapalu Eleopalu Elymrepe Empenigr Hyporadi Juncarti Juncbufo ## 2 4 25 26 2 9 18 13 ## Lolipere Planlanc Poaprat Poatriv Ranuflam Rumeacet Sagiproc Salirepe ## 58 26 48 63 14 18 20 11 ## Scorautu Trifprat Trifrepe Vicilath Bracruta Callcusp ## 54 9 47 4 49 10 5.4 Estrutura e manipulação de objetos O conhecimento sobre a estrutura e manipulação de objetos é fundamental para ter domínio e entendimento do funcionamento da linguagem R. Nesta seção, trataremos da estrutura e manipulação de dados no R, no que ficou conhecido como modo R Base, em contrapartida ao tidyverse, tópico da próxima seção. Abordaremos temas chaves: 1) atributos de objetos, 2) manipulação de objetos unidimensionais e multidimensionais, 3) valores faltantes e especiais, 4) diretório de trabalho, 5) importar, conferir e exportar dados. 5.4.1 Atributo dos objetos Quando fazemos atribuições de dados no R (&lt;-), os objetos gerados possuem três características. Nome: palavra que o R reconhece os dados atribuídos Conteúdo: dados em si Atributos: modos (natureza) e estruturas (organização) Vamos explorar mais a fundo os modos e estruturas. Vale ressaltar que isso é uma simplificação, pois há muitas classes de objetos como funções e saídas de funções que possuem outros atributos. 5.4.1.1 Modo dos objetos A depender da natureza dos elementos que compõem os dados que foram atribuídos aos objetos, esses objetos podem ser, de forma simples um dos cinco: numérico do tipo inteiro (interger), numérico do tipo flutuante (double), texto (character), lógico (logical), e complexos (complex). A atribuição de números no R podem gerar dois tipos de modos: interger para números inteiros e double para números flutuantes ou com decimais. # numerico double obj_numerico_double &lt;- 1 # modo mode(obj_numerico_double) ## [1] &quot;numeric&quot; # tipo typeof(obj_numerico_double) ## [1] &quot;double&quot; A título de praticidade, ambos são incorporados como o modo numeric, com o tipo double, a menos que especifiquemos que seja inteiro com o a letra L depois do número. # numerico interger obj_numerico_inteiro &lt;- 1L # modo mode(obj_numerico_inteiro) ## [1] &quot;numeric&quot; # tipo typeof(obj_numerico_inteiro) ## [1] &quot;integer&quot; Além de números, podemos atribuir textos, utilizando para isso aspas \"\". # caracter obj_caracter &lt;- &quot;a&quot; # atencao para as aspas # modo mode(obj_caracter) ## [1] &quot;character&quot; Em algumas situações, precisamos indicar a ocorrência ou não de um evento. Para isso, utilizamos as palavras reservadas (TRUE e FALSE), chamadas de variáveis booleanas. Devemos nos ater para que essas palavras são com letras maiúsculas e sem aspas. # logico obj_logico &lt;- TRUE # maiusculas e sem aspas # modo mode(obj_logico) ## [1] &quot;logical&quot; Por fim, existe um modo pouco utilizado que cria números complexos (raiz de números negativos). # complexo obj_complexo &lt;- 1+1i # modo mode(obj_complexo) ## [1] &quot;complex&quot; Podemos fazer conversão entre esses modos com diversas funções. # conversoes entre modos as.numeric() as.integer() as.character() as.logical() as.complex() 5.4.2 Estrutura dos objetos Uma vez entendido a natureza dos modos dos elementos do objetos no R, podemos passar para o passo seguinte, e entender como esses elementos são estruturados dentro dos objetos. Essa estruturação irá nos contar sobre a organização dos elementos, com relação aos modos e dimensionalidade da disposição dos elementos (Figura 5.3). De modo bem simples, os elementos podem ser estruturados em cinco tipos: Vetores e fatores: homogênio (um modo) e unidimensional (uma dimensão) Um tipo especial de vetor são os fatores, usados para designar variáveis categóricas Matrizes: homogênio (um modo) e bidimensional (duas dimensões) Arrais: homogênio (um modo) e multidimensional (mais de duas dimensões) Data frames: heterogêneo (mais de um modo) e bidimensional (duas dimensões) Listas: heterogêneo (mais de um modo) e unidimensional (uma dimensão) Figura 5.3: Estruturas de dados mais comuns de R: vetores, matrizes, arrays, listas e data frames. Adaptado de: Grolemund (2014). 5.4.2.1 Vetor Vetores representam o encadeamento de elementos numa sequência unidimensionais. No Capítulo YY, vimos o conceito de variáveis aleatórias. No R, essas variáveis podem ser entendidas como vetores. Dessa forma essa estrutura de dados pode ser traduzida como medidas de uma variável quantitativa (discretas ou contínuas), variável binária (booleana - TRUE e FALSE) ou descrição (informações em texto). Há diversas formas de se criar um vetor no R: Concatenando elementos com a função c Criando sequências unitárias : ou com a função seq() Criando repetições com a função rep() “Colar” palavras com uma sequência numérica com a função paste() ou paste0() Amostrando aleatoriamente elementos com a função sample() # concatenar elementos numericos concatenar &lt;- c(15, 18, 20, 22, 18) # sequencia unitaria (x1:x2) sequencia &lt;- 1:10 # sequencia com diferentes espacamentos sequencia_esp &lt;- seq(from = 0, to = 100, by = 10) # repeticao repeticao &lt;- rep(x = c(TRUE, FALSE), times = 5) # cola palavra e sequencia numerica - sem separacao definida (&quot; &quot;) colar &lt;- paste(&quot;amostra&quot;, 1:5) # amostragem aleatória - sem reposição amostragem &lt;- sample(1:100, 10) Como os vetores são homogênios, i.e., só comportam um modo, quando combinamos mais de modo no mesmo objeto existe uma dominância de modos. Existe dessa forma uma coerção dos elementos combinados para todos fiquem iguais. Essa dominância segue essa ordem: DOMINANTE character &gt;&gt;&gt; double &gt;&gt;&gt; interger &gt;&gt;&gt; logical RECESSIVO Além disso, podemos utilizar as conversões listadas anteiormente para alterar os modos. Vamos exemplificar combinando os vetores criados anteriormente, e convertendo-os. # coercao c(colar, amostragem) ## [1] &quot;amostra 1&quot; &quot;amostra 2&quot; &quot;amostra 3&quot; &quot;amostra 4&quot; &quot;amostra 5&quot; &quot;43&quot; ## [7] &quot;25&quot; &quot;94&quot; &quot;91&quot; &quot;37&quot; &quot;35&quot; &quot;10&quot; ## [13] &quot;62&quot; &quot;77&quot; &quot;42&quot; # conversao as.numeric(repeticao) ## [1] 1 0 1 0 1 0 1 0 1 0 5.4.2.2 Fator O fator representa medidas de uma variável qualitativa, podendo ser nominal ou ordinal. É fundamental destacar que fatores no R devem ser entendidos como um vetor de interger, i.e., ele é composto por números inteiros representando os níveis da variável categórica. Para criar um fator no R, usamos uma função específica factor(), na qual podemos especificar os níveis com o argumento leval, ou fazemos uma conversão usando a função as.factor(). Trabalhar com fatores no R Base não é das tarefas mais agradáveis, mas mais adiante na seção XX usaremos a versão tidyverse usando o pacote forcats. # fatores nominal fator_nominal &lt;- factor(x = sample(c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;), 20, replace = TRUE), levels = c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;)) # fatores ordinal fator_ordinal &lt;- factor(x = sample(c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), 20, replace = TRUE), levels = c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), ordered = TRUE) # conversao fator &lt;- as.factor(x = sample(c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;), 20, replace = TRUE)) 5.4.2.3 Matriz A matrix representa os dados no formato de tabela, com linhas e colunas. As linhas representam unidades amostrais (locais, transectos, parcelas) e as coluncas representam variáveis quantitativas (discretas ou contínuas) ou descrições (informações em texto). Podemos criar matrizes no R de duas formas principais. A primeira delas dispondo elementos de um vetor em um certo número de linhas e colunas com a função matrix(), podendo preencher essa matriz com os elementos do vetor por linhas ou por colunas alterando o argumento byrow. # vetor ve &lt;- 1:12 # matrix - preenchimento por linhas - horizontal ma_row &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE) # matrix - preenchimento por colunas - vertical ma_col &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE) A segundo forma combinando vetores, utilizando a função rbind para combinar veores por linha, i.e., vetor embaixo do outro, e cbind para combinar vetores por coluna, i.e., vetor ao lado do outro. # criar dois vetores vec_1 &lt;- c(1, 2, 3) vec_2 &lt;- c(4, 5, 6) # combinar por linhas - vertical - um embaixo do outro ma_rbind &lt;- rbind(vec_1, vec_2) # combinar por colunas - horizontal - um ao lado do outro ma_cbind &lt;- cbind(vec_1, vec_2) 5.4.2.4 Arrai O arrai representa combinação de tabelas, com linhas, colunas e dimensões. Essa combinação pode ser feita em múltiplas dimensões, mas apesar disso, geralmente é mais comum o uso em Ecologia para três dimensões, por exemplo: linhas (unidades amostrais), colunas (espécies) e dimensão (tempo). Isso gera um “cubo mágico,” onde podemos comparar, nesse caso, comunidades ao longo do tempo. Podemos criar arrais no R dispondo elementos de um vetor em um certo número de linhas, colunas e dimensões com a função array(). Em nosso exemplo, vamos compor 10 comunidades de 20 espécies ao longo de cinco períodos. # arrai ar &lt;- array(data = sample(c(0, 1), 1e3, rep = TRUE), dim = c(10, 20, 5)) 5.4.2.5 Data frame O data frame representa dados no formato de tabela, com linhas e colunas, muito semelhante à matriz. Mas diferentemente das matrizes, os data frames comportam mais de um modo em suas colunas. Dessa forma, as linhas do data frame ainda representam unidades amostrais (locais, transectos, parcelas), mas as colunas agora podem representar descrições (informações em texto), variáveis quantitativas (discretas ou contínuas) e/ou variáveis qualitativas (nominais ou ordinais). A forma mais simples de criar data frames no R é através da combinação de vetores. Essa combinação é feita com a função data.frame(), e ocorre de forma horizontal, semelhante à função cbind(). Sendo assim, todos os vetores precisam ter o mesmo número de elementos, ou seja, mesmo comprimento. Podemos ainda nomear as colunas para cada vetor. # criar tres vetores vec_ch &lt;- c(&quot;sp1&quot;, &quot;sp2&quot;, &quot;sp3&quot;) vec_nu &lt;- c(4, 5, 6) vec_fa &lt;- factor(c(&quot;campo&quot;, &quot;floresta&quot;, &quot;floresta&quot;)) # data.frame - combinar por colunas - horizontal - um ao lado do outro df &lt;- data.frame(vec_ch, vec_nu, vec_fa) # data.frame - nomear as colunas df &lt;- data.frame(especies = vec_ch, abundancia = vec_nu, vegetacao = vec_fa) 5.4.2.6 Lista A lista é tipo especial de vetor, que aceita objetos como elementos. Ela é a estrutura de dados utilizada para agrupar objetos, e é geralmente a saída de muitas funções que fazem análises estatísticas. Podemos criar listas através da função list(). Essa função funciona de forma semelhante à função c() para a criação de vetores, mas agora estamos concatenando elementos. Podemos ainda nomear os elementos que estamos combinando. Um ponto interessante para entender data frames, é que eles são listas, em que todos os elementos (colunas) possuem o mesmo número de elementos, ou seja, mesmo comprimento. # lista lista &lt;- list(rep(1, 20), # vector factor(1, 1), # factor cbind(c(1, 2), c(1, 2))) # matrix # lista - nomear os elementos lista &lt;- list(vector = rep(1, 20), # vector factor = factor(1, 1), # factor matrix = cbind(c(1, 2), c(1, 2))) # matrix 5.4.2.7 Funções Uma última estrutura de objetos criados no R são as funções. Elas são objetos criados pelo usuário e reutilizados para fazer operações específicas. A criação de funções geralmente é um tópico tratado num segundo momento, quando o usuário de R adquire certo conhecimento da linguagem. Aqui abordarem apenas seu funcionamento básico, diferenciando sua estrutura para entendimento e sua diferenciação das demais estruturas. Vamos criar uma função simples que retorna a multiplicação de dois termos. # criar uma funcao multi &lt;- function(x, y){ mu &lt;- (x * y) return(mu) } # uso multi(42, 42) ## [1] 1764 5.4.3 Manipulação de objetos unidimensionais Vamos agora explorar formas de manipular elementos de objetos unidimensionais, ou seja vetores, fatores e listas. A primeira forma de manipulação é através da indexação, utilizando os operadores []. Com a indexação podemos acessar elementos de vetores e fatores por sua posição. Iremos utilizar números, sequência de números ou operação booleanas para retornar partes dos vetores ou factores. Podemos ainda retirar elementos dos vetores com o operação aritmético -. # fixar a amostragem set.seed(42) # amostrar 10 elementos de uma sequencia ve &lt;- sample(seq(0, 2, .05), 10) ve ## [1] 1.80 0.00 1.20 0.45 1.75 0.85 1.15 0.30 1.90 0.20 # seleciona o quinto elemento ve[5] ## [1] 1.75 # seleciona os elementos de 1 a 5 ve[1:5] ## [1] 1.80 0.00 1.20 0.45 1.75 # retira o decimo elemento ve[-10] ## [1] 1.80 0.00 1.20 0.45 1.75 0.85 1.15 0.30 1.90 # retira os elementos 2 a 9 ve[-(2:9)] ## [1] 1.8 0.2 Podemos ainda fazer uma seleção condicional do vetor. Ao utilizarmos operadores relacionais, teremos como resposta um vetor lógico. Esse vetor lógico pode ser utilizado dentro da indexação para seleção de elementos. # quais valores sao maiores que 1? ve &gt; 1 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE # valores acima de 1 ve[ve &gt; 1] ## [1] 1.80 1.20 1.75 1.15 1.90 Além da indexação, temos algumas função que nos auxiliam em algumas operações com objetos unidimensionais listadas na Tabela 5.2. Tabela 5.2: Funções para verificação e resumo de dados unidimensionais. Função Descrição max() Valor máximo min() Valor mínimo range() Amplitude length() Comprimento sum() Soma cumsum() Soma cumulativa prod() Produto sqrt() Raiz quadrada abs() Valor absoluto exp() Expoente log() Logaritmo natural log1p() Logaritmo natural mais 1 log(x + 1) log2() Logaritmo base 2 log10() Logaritmo base 10 mean() Média mean.weighted() Média ponderada var() Variância sd() Desvio Padrão mediam() Mediana quantile() Quantil quarters() Quartil round() Arredondamento sort() Ordenação order() Posição ordenada rev() Reverso unique() Únicos summary() Resumo estatístico scale() Padronização e centralização sub() Substitui caracteres grep() Posição de caracteres any() Algum valor? all() Todos os valores? which() Quais valores? subset() Subconjunto ifelse() Operação condicional Para listas, também podemos usar a indexação [] para acessar ou retirar elementos. # lista li &lt;- list(elem1 = 1, elem2 = 2, elem3 = 3) # acessar o primeiro elemento li[1] ## $elem1 ## [1] 1 # retirar o primeiro elemento li[-1] ## $elem2 ## [1] 2 ## ## $elem3 ## [1] 3 Podemos ainda usar a indexação dupla [[]] para acessar os valores dos elementos. # acessar o valor do primeiro elemento li[[1]] ## [1] 1 # acessar o valor do segundo elemento li[[2]] ## [1] 2 Para listas nomeadas, podemos ainda utilizar o operador $ para acessar elementos pelo nome. # acessar o primeiro elemento li$elem1 ## [1] 1 E ainda podemos utilizar funções para medir o comprimento dessa lista, listar os nomes dos elementos ou ainda renomear os elementos: length() e names(). # comprimento length(li) ## [1] 3 # nomes names(li) ## [1] &quot;elem1&quot; &quot;elem2&quot; &quot;elem3&quot; # renomear names(li) &lt;- paste0(&quot;elemento0&quot;, 1:3) li ## $elemento01 ## [1] 1 ## ## $elemento02 ## [1] 2 ## ## $elemento03 ## [1] 3 5.4.4 Manipulação de objetos multidimensionais Da mesma forma que para objetos unidimensionais, manipular elementos de objetos multidimensionais, ou seja matrizes, data frames e arrais. Novamente, a primeira forma de manipulação é através da indexação, utilizando os operadores []. Com a indexação podemos acessar elementos de matrizes, data frames e arrais por sua posição. Podemos ainda retirar elementos dos vetores com o operação aritmético -. Entretanto, agora temos mais de uma dimensão na estruturação dos elementos dentro dos objetos. Assim, utilizamos números, sequência de números ou operação booleanas para retornar partes desses objetos, mas as dimensões têm de ser explicitadas, e separadas por vírgulas, i.e., para acessar linhas e colunas, listamos respectivamente números antes e depois da vírgula. Essa indexação funciona para matrizes e data frames. Para arrais, especificamos as dimensões também separadas por vírgulas para acessar outras dimensões. # matriz ma &lt;- matrix(1:12, 4, 3) ma ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ma[3, ] # linha 3 ## [1] 3 7 11 ma[, 2] # coluna 2 ## [1] 5 6 7 8 ma[1, 2] # elemento da linha 1 e coluna 2 ## [1] 5 ma[1, 1:2] # elementos da linha 1 e coluna 1 e 2 ## [1] 1 5 ma[1, c(1, 3)] # elementos da linha 1 e coluna 1 e 3 ## [1] 1 9 Para data frames, além de utilizar números e/ou sequências de numeros dentro do operador [] simples, assim como podemos utilizar o operador [[]] duplo para retornar apenas o valores de uma colunas. Se as colunas estiverem nomeadas, podemos utilizar o nome da coluna de interesse entre aspas dentro dos operadores [] (retorna coluna) e [[]] (retorna apenas os valores), assim como ainda podemos utilizar o operador $. Essas últimas operações retornam um vetor, para o qual podemos fazer operações de vetores ou ainda atualizar o valor dessa coluna selecionada ou adicionar outra coluna. # criar tres vetores sp &lt;- paste(&quot;sp&quot;, 1:10, sep = &quot;&quot;) abu &lt;- 1:10 flo &lt;- factor(rep(c(&quot;campo&quot;, &quot;floresta&quot;), each = 5)) # data frame df &lt;- data.frame(sp, abu, flo) df ## sp abu flo ## 1 sp1 1 campo ## 2 sp2 2 campo ## 3 sp3 3 campo ## 4 sp4 4 campo ## 5 sp5 5 campo ## 6 sp6 6 floresta ## 7 sp7 7 floresta ## 8 sp8 8 floresta ## 9 sp9 9 floresta ## 10 sp10 10 floresta # [] - numeros df[, 1] ## [1] &quot;sp1&quot; &quot;sp2&quot; &quot;sp3&quot; &quot;sp4&quot; &quot;sp5&quot; &quot;sp6&quot; &quot;sp7&quot; &quot;sp8&quot; &quot;sp9&quot; &quot;sp10&quot; # [] - nome das colunas - retorna coluna df[&quot;flo&quot;] ## flo ## 1 campo ## 2 campo ## 3 campo ## 4 campo ## 5 campo ## 6 floresta ## 7 floresta ## 8 floresta ## 9 floresta ## 10 floresta # [[]] - nome das colunas - retorna apenas os valores df[[&quot;flo&quot;]] ## [1] campo campo campo campo campo floresta floresta floresta ## [9] floresta floresta ## Levels: campo floresta # $ funciona apenas para data frame df$sp ## [1] &quot;sp1&quot; &quot;sp2&quot; &quot;sp3&quot; &quot;sp4&quot; &quot;sp5&quot; &quot;sp6&quot; &quot;sp7&quot; &quot;sp8&quot; &quot;sp9&quot; &quot;sp10&quot; # operacao de vetors length(df$abu) ## [1] 10 # converter colunas df$abu &lt;- as.character(df$abu) mode(df$abu) ## [1] &quot;character&quot; # adicionar colunas set.seed(42) df$abu2 &lt;- sample(0:1, nrow(df), rep = TRUE) df ## sp abu flo abu2 ## 1 sp1 1 campo 0 ## 2 sp2 2 campo 0 ## 3 sp3 3 campo 0 ## 4 sp4 4 campo 0 ## 5 sp5 5 campo 1 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 ## 10 sp10 10 floresta 1 Podemos ainda fazer seleções condicionais para retornar linhas com valores que temos interesse, semelhante ao uso de filtro de uma planilha eletrônica. # selecionar linhas de uma matriz ou data frame df[df$abu &gt; 4, ] ## sp abu flo abu2 ## 5 sp5 5 campo 1 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 df[df$flo == &quot;floresta&quot;, ] ## sp abu flo abu2 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 ## 10 sp10 10 floresta 1 Além disso, há uma séria de funções para conferência e manipulação de dados que listamos na Tabela 5.3. Tabela 5.3: Funções para verificação e resumo de dados multidimensionais. Função Descrição head() Mostra as primeiras 6 linhas tail() Mostra as últimas 6 linhas nrow() Mostra o número de linhas ncol() Mostra o número de colunas dim() Mostra o número de linhas e de colunas rownames() Mostra os nomes das linhas (locais) colnames() Mostra os nomes das colunas (variáveis) str() Mostra as classes de cada coluna (estrutura) summary() Mostra um resumo dos valores de cada coluna rowSums() Calcula a soma das linhas (horizontal) colSums() Calcula a soma das colunas (vertical) rowMeans() Calcula a média das linhas (horizontal) colMeans() Calcula a média das colunas (vertical) str() Mostra a estrutura dos dados table() Tabulação cruzada 5.4.5 Valores faltantes e especiais Valores faltantes e especiais são valores reservados que representam dados faltantes, indefinições matemáticas, infinitos e objetos nulos. NA (Not Available): significa dado faltante/indisponível NaN (Not a Number): representa indefinições matemáticas Inf (Infinito): é um número muito grande ou um limite matemático NULL (Nulo): representa um objeto nulo, sendo útil para preenchimento de laços e outras aplicações de programação # data frame com elemento NA df &lt;- data.frame(var1 = c(1, 4, 2, NA), var2 = c(1, 4, 5, 2)) df ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 ## 4 NA 2 # resposta booleana para elementos na is.na(df) ## var1 var2 ## [1,] FALSE FALSE ## [2,] FALSE FALSE ## [3,] FALSE FALSE ## [4,] TRUE FALSE # algum elemento é na? any(is.na(df)) ## [1] TRUE # remover as linhas com nas df_sem_na &lt;- na.omit(df) df_sem_na ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 # substituir nas por 0 df[is.na(df)] &lt;- 0 df ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 ## 4 0 2 # nan - not a number 0/0 ## [1] NaN log(-1) ## [1] NaN # limite matematico 1/0 ## [1] Inf # numero grande 10^310 ## [1] Inf # objeto nulo nulo &lt;- NULL nulo ## NULL 5.4.6 Diretório de trabalho O diretório de trabalho é o endereço da pasta (ou diretório) de onde o R irá importar ou exportar os nossos dados. Podemos utilizar o próprio RStudio para tal tarefa, indo em Session &gt; Set Work Directory &gt; Choose Directory…, ou simplesmente utilizar o atalho ctrl + shift + H. Podemos ainda utilizar as funções do R para definir o diretório. Para tanto, podemos navegar com o aplicativo de gerenciador de arquivos (e.g. Windows Explorer) até nosso diretório de interesse, e copiar o endereço na barra superior. Voltamos para o R e colamos esse endereço entre aspas como um argumento da função setwd(). É fundamental destacar que em Sistemas Operacionais Windows é necessário inverter as barras (\\ por /). Aconselhamos ainda utilizar as funções getwd() para retornar o diretório definido na sessão do R, assim como as funções dir() ou list.files() para listagem dos arquivos no diretório, ambas medidas de conferência do diretório correto. # definir o diretorio de trabalho setwd(&quot;/home/mude/data/github/livro_r_ecologia/dados&quot;) # verificar o diretorio getwd() # listar os arquivos no diretorio dir() list.files() 5.4.7 Importar dados Uma das operações mais corriqueiras do R, antes de realizar alguma análise, é a de importar dados que foram tabulados numa planilha eletrônica e salvos no formato .csv, .txt ou .xlsx. Ao importar esse tipo de dado para o R, o formato que o mesmo assume, se nenhum parâmetro for especificado, é o da classes dataframe, prevendo que a planilha de dados possua colunas com diferentes modos. Existe diversas formas de importar dados para o R. Podemos importar utilizando o RStudio, indo na janela Environment (Figura 5.2 (3)) e clicar em “Importar Dataset.” Entretanto, aconselhamos o uso de funções que fiquem salvas em um script para aumentar a reprodutibilidade do script. Dessa forma, as três principais funções para importar os arquivos nos três principais extensões (.csv, .txt ou .xlsx) são, respectivamente: read.csv(), read.table() e `openxlsx::read.xlsx()``, sendo o último do pacote openxlsx. # instalar pacote openxlsx install.packages(&quot;openxlsx&quot;) library(openxlsx) Para exemplificar como importar dados, vamos usar os dados de comunidades de anfíbios da Mata Atlântica (Atlantic Amphibians, Vancine et al. 2018). Iremos fazer o download diretamente do site da fonte dos dados. Antes vamos antes escolher um diretório de trabalho com a função setwd(), e em seguida criar um diretório com a função dir.create() chamado “dados.” Em seguida, vamos mudar nosso diretóri para essa pasta, e criar mais um diretório chamado “tabelas,” e definir esse diretório para fazer o download. # escolher um diretorio setwd(&quot;/home/mude/data/github/livro_r_ecologia&quot;) # criar um diretorio &#39;dados&#39; dir.create(&quot;dados&quot;) # escolher diretorio &#39;dados&#39; setwd(&quot;dados&quot;) # criar um diretorio &#39;tabelas&#39; dir.create(&quot;tabelas&quot;) # escolher diretorio &#39;tabelas&#39; setwd(&quot;tabelas&quot;) Agora podemos fazer o download de um arquivo .zip e extrair as tabelas usando a função unzip() nesse mesmo diretório. # download download.file(url = &quot;https://esajournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fecy.2392&amp;file=ecy2392-sup-0001-DataS1.zip&quot;, destfile = &quot;atlantic_amphibians.zip&quot;, mode = &quot;wb&quot;) # unzip unzip(zipfile = &quot;atlantic_amphibians.zip&quot;) Agora podemos importar a tabela de dados com a função read.csv(), atribuindo ao objeto aa_locais. # importar tabela de locais aa_locais &lt;- read.csv(&quot;dados/tabelas/ATLANTIC_AMPHIBIANS_sites.csv&quot;) Esse arquivo foi criado com separador de decimais sendo . e separador de colunas sendo ,. Caso tivesse sido criado com separador de decimais sendo , e separador de colunas sendo ;, usaríamos a função read.csv2(). 5.4.8 Conferência de dados importados Uma vez importados os dados para o R, geralmente antes de inicarmos qualquer manejo, visualização ou análise de dados, fazemos a conferência desses dados. Para isso, podemos utilizar as funções listadas na Tabela 5.3. # primeiras linhas head(aa_locais) ## id reference_number species_number record sampled_habitat active_methods ## 1 amp1001 1001 19 ab fo,ll as ## 2 amp1002 1002 16 co fo,la,ll as ## 3 amp1003 1002 14 co fo,la,ll as ## 4 amp1004 1002 13 co fo,la,ll as ## 5 amp1005 1003 30 co fo,ll,br as ## 6 amp1006 1004 42 co tp,pp,la,ll,is &lt;NA&gt; ## passive_methods complementary_methods period month_start year_start ## 1 pt &lt;NA&gt; mo,da,tw,ni 9 2000 ## 2 pt &lt;NA&gt; mo,da,tw,ni 12 2007 ## 3 pt &lt;NA&gt; mo,da,tw,ni 12 2007 ## 4 pt &lt;NA&gt; mo,da,tw,ni 12 2007 ## 5 &lt;NA&gt; &lt;NA&gt; mo,da,ni 7 1988 ## 6 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA ## month_finish year_finish effort_months country state state_abbreviation ## 1 1 2002 16 Brazil Piau\\xed BR-PI ## 2 5 2009 17 Brazil Cear\\xe1 BR-CE ## 3 5 2009 17 Brazil Cear\\xe1 BR-CE ## 4 5 2009 17 Brazil Cear\\xe1 BR-CE ## 5 8 2001 157 Brazil Cear\\xe1 BR-CE ## 6 NA NA NA Brazil Cear\\xe1 BR-CE ## municipality site ## 1 Canto do Buriti Parque Nacional Serra das Confus\\xf5es ## 2 S\\xe3o Gon\\xe7alo do Amarante Dunas ## 3 S\\xe3o Gon\\xe7alo do Amarante Jardim Bot\\xe2nico\\xa0Municipal de\\xa0Bauru ## 4 S\\xe3o Gon\\xe7alo do Amarante Ta\\xedba ## 5 Baturit\\xe9 Serra de Baturit\\xe9 ## 6 Quebrangulo Reserva Biol\\xf3gica de Pedra Talhada ## latitude longitude coordinate_precision altitude temperature precipitation ## 1 -8.680000 -43.42194 gm 543 24.98 853 ## 2 -3.545527 -38.85783 dd 15 26.53 1318 ## 3 -3.574194 -38.88869 dd 29 26.45 1248 ## 4 -3.515250 -38.91880 dd 25 26.55 1376 ## 5 -4.280556 -38.91083 gm 750 21.35 1689 ## 6 -9.229167 -36.42806 &lt;NA&gt; 745 20.45 1249 # ultimas linhas tail(aa_locais) ## id reference_number species_number record sampled_habitat ## 1158 amp2158 1389 3 co &lt;NA&gt; ## 1159 amp2159 1389 9 co &lt;NA&gt; ## 1160 amp2160 1389 6 co &lt;NA&gt; ## 1161 amp2161 1389 1 co &lt;NA&gt; ## 1162 amp2162 1389 2 co &lt;NA&gt; ## 1163 amp2163 1389 2 co &lt;NA&gt; ## active_methods passive_methods complementary_methods period month_start ## 1158 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## 1159 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## 1160 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## 1161 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## 1162 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## 1163 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## year_start month_finish year_finish effort_months country state ## 1158 NA NA NA NA Argentina Misiones ## 1159 NA NA NA NA Argentina Misiones ## 1160 NA NA NA NA Argentina Misiones ## 1161 NA NA NA NA Argentina Misiones ## 1162 NA NA NA NA Argentina Misiones ## 1163 NA NA NA NA Argentina Misiones ## state_abbreviation municipality site ## 1158 AR-N Manuel Belgrano Comandante Andresito ## 1159 AR-N Posadas Posadas ## 1160 AR-N Montecarlo Montecarlo ## 1161 AR-N San Pedro Refugio Mocon\\xe1 ## 1162 AR-N Caingu\\xe1s Balneario Municipal Cu\\xf1\\xe1 Pir\\xfa ## 1163 AR-N Ober\\xe1 Chacra San Juan de Dios ## latitude longitude coordinate_precision altitude temperature ## 1158 -25.66944 -54.04556 gms 251 19.94 ## 1159 -27.45333 -55.89250 gms 105 21.30 ## 1160 -26.56889 -53.60889 gms 597 18.35 ## 1161 -27.14083 -53.92611 gms 202 19.92 ## 1162 -27.08722 -54.95278 gms 213 21.04 ## 1163 -27.47333 -55.17194 gms 254 20.67 ## precipitation ## 1158 1780 ## 1159 1768 ## 1160 1954 ## 1161 1850 ## 1162 1553 ## 1163 1683 # numero de linhas e colunas nrow(aa_locais) ## [1] 1163 ncol(aa_locais) ## [1] 25 dim(aa_locais) ## [1] 1163 25 # nome das linhas e colunas rownames(aa_locais) colnames(aa_locais) # estrutura dos dados str(aa_locais) # resumo dos dados summary(aa_locais) # verificar nas any(is.na(aa_locais)) which(is.na(aa_locais)) # remover as linhas com nas aa_locais_na &lt;- na.omit(aa_locais) 5.4.9 Exportar dados Uma vez realizado as operações de manipulações ou tendo dados que foram analisados e guardados num objeto no formato de data frame ou matriz, podemos exportar esses dados do R para o diretório que definimos anteriormente. Para tanto, podemos utilizar funções de escrita de dados, como write.csv(), write.table() e openxlsx::write.xlsx(). Dois pontos são fundamentais: 1. o nome do arquivo tem de estar entre aspas e no final dele deve constar a extensão que pretende que o arquivo tenha; 2. é interessante utilizar os argumentos row.names = FALSE e quote, para que o arquivo escrito não tenha o nome das linhas ou aspas em todas as células. # exportar dados na extensao .csv write.csv(aa_locais_na, &quot;ATLANTIC_AMPHIBIAN_sites_na.csv&quot;, row.names = FALSE, quote = FALSE) # exportar dados na extensao .txt write.table(aa_locais_na, &quot;ATLANTIC_AMPHIBIAN_sites_na.txt&quot;, row.names = FALSE, quote = FALSE) # exportar dados na extensao .xlsx openxlsx::write.xlsx(aa_locais_na, &quot;ATLANTIC_AMPHIBIAN_sites_na.xlsx&quot;, row.names = FALSE, quote = FALSE) 5.5 Tidyverse 5.5.1 Contextualização Como todo idioma, a linguagem R vem passando por transformações nos últimos anos. Grande parte dessas mudanças estão dentro do paradigma da Ciência de Dados (Data Science), uma nova área de conhecimento que vem se moldando acompanhando o desenvolvimento da sociedade em torno da era digital e da grande quantidade de dados gerados e disponíveis pela internet e computação, de onde advém os pilares das inovações tecnológicas: Big Data, Machine Learning, e Internet of Things. A grande necessidade de computação parapara desenvolver essa nova abordagem, colocaram o R e o Python como as principais linguagens de programação frente à esses novos desafios. Apesar de não serem as únicas utilizadas para esses propósitos, elas rapidamente se tornaram uma das melhores escolhas, dado vários fatores como: serem livres, possuir comunidade ativa, grande e contribuidora, serem linguagens de interpretação (orientadas à objeto), e relativamente fáceis de serem aprendidas. Essas mudanças e adaptações da linguagem R para a Ciência de Dados começaram à ser implementadas principalmente devido a um pesquisador, Hadley Wickham, que iniciou sua contribuição à comunidade R com o desenvolvimento do já consagrado pacote ggplot2 (Wickham 2009, Wickham 2016) para a composição de gráficos no R (ver mais no capítulo XX), baseado na gramática de gráficos (Wilkinson 2005). Depois disso, Wickham dedicou-se ao desenvolvimento do pensamento de uma nova abordagem dentro do manejo de dados, denominada de Tidy Data (Dados organizados) (Wickhan 2014), na qual focou na limpeza de dados. A ideia, relativamente simples, diz que dados estão tidy quando variáveis estão nas colunas, observações estão nas linhas e valores estão nas células, sendo que para esse último, não deve haver mais de um valor por célula (Figura 5.5). À partir dessas ideias, o tidyverse foi operacionalizado no R como uma coleção de pacotes R que atuam no workflow comum da ciência de dados: importação, manipulação, exploração, visualização, análise e comunicação de dados e análises (Wickhan et al. 2019) (Figura 5.4). O principal objetivo do Tidyverse é aproximar a linguagem para melhorar a interação entre ser humano e computador sobre dados, de modo que os pacotes compartilham uma filosofia de design de alto nível e gramática, além da estrutura de dados de baixo nível (Wickhan et al. 2019). Figura 5.4: Modelo das ferramentas necessárias em um projeto típico de ciência de dados: importar, organizar, entender (transformar, visualizar, modelar) e comunicar, envolto à essas ferramentas está a programação. Adaptado de: Wickhan &amp; Grolemund (2017). As principais leituras sobre o tema no R são os artigos Wickham (2014), Wickham et al. (2019), o livro Wickhan &amp; Grolemund (2017), disponível on-line neste link, além do site que possui muito mais informações. 5.5.2 tidyverse Uma vez instalado e carregado, o pacote tidyverse disponibiliza um conjunto de ferramentas através de vários pacotes. Esses pacotes compartilham uma filosofia de design, gramática e estruturas de dados. Podemos entender o tidyverse como um “dialeto novo” para a linguagem R, onde tidy quer dizer organizado, arrumado, ordenado, e verse é universo. readr: importa dados tabulares (.csv e .txt) tibble: implementou o “tibble,” com melhorias na classe dataframe tidyr: facilita a transformação de dados para tidy dplyr: facilita a manipulação de dados stringr: facilita a manipulação de caracteres forcats: facilita a manipulação de fatores ggplot2: visualização de dados purrr: programação funcional Além desses principais, fazemos a menção de outros pacotes que estão dentro dessa aborgagem, e que trataremos ainda neste capítulo, em outro momento do livro, ou que você leitor deve se familiarizar. readxl e writexl: importa e exporta dados tabulares (.xlsx) DBI: interface de banco de dados R haven: importa e exporta dados do SPSS, Stata e SAS httr: ferramentas para trabalhar com URLs e HTTP rvest: coletar facilmente (raspe) páginas da web xml2: trabalhar com arquivos XML jsonlite: um analisador e gerador JSON simples e robusto para R hms: hora do dia lubridate: facilita o tratamento de datas magrittr: provê os operadores pipe (%&gt;%, %$%, %&lt;&gt;%) glue: facilita combinar dados e caracteres rmarkdown: cria documentos de análise dinâmica que combinam código, saída renderizada (como figuras) e texto knitr: projetado para ser um mecanismo transparente para geração de relatórios dinâmicos com R shiny: framework de aplicativo Web para R flexdashboard: painéis interativos para R here: facilita a definição de diretórios usethis: automatiza tarefas durante a configuração e desenvolvimento de projetos (Git, ‘GitHub’ e Projetos RStudio) data.table: pacote que fornece uma versão de alto desempenho do data.frame (importar, manipular e expotar) reticulate: pacote que fornece ferramentas para integrar Python e R sparklyr: interface R para Apache Spark broom: converte objetos estatísticos em tibbles organizados modelr: funções de modelagem que funcionam com o pipe tidymodels: coleção de pacotes para modelagem e aprendizado de máquina usando os princípios do tidyverse Para instalar os pacotes do tidyverse, rode o comando abaixo: # instalar o pacote tidyverse install.packages(&quot;tidyverse&quot;) Quando carregamos o pacote tidyverse, notamos uma mensagem indicando quais pacotes foram carregados, suas repectivas versões e os conflitos com outros pacotes. # carregar o pacote tidyverse library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.0 ✓ dplyr 1.0.4 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Podemos ainda listar todos os pacotes do tidyverse com a função tidyverse::tidyverse_packages(). # listar todos os pacotes no tidyverse tidyverse::tidyverse_packages(include_self = TRUE) ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dbplyr&quot; &quot;dplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;pillar&quot; ## [16] &quot;purrr&quot; &quot;readr&quot; &quot;readxl&quot; &quot;reprex&quot; &quot;rlang&quot; ## [21] &quot;rstudioapi&quot; &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; ## [26] &quot;xml2&quot; &quot;tidyverse&quot; Também podemos verificar os pacotes para serem atualizados com a função tidyverse::tidyverse_update(). # listar e atualizar os pacotes no tidyverse tidyverse::tidyverse_update() ## The following packages are out of date: ## ## ● lubridate (1.7.9.2 -&gt; 1.7.10) ## ## Start a clean R session then run: ## install.packages(&quot;lubridate&quot;) Todas as funções dos pacotes tidyverse usão fonte minúscula e usam _ (underscore) para separar os nomes internos das funções, seguindo a mesma sintaxe do Python (“Snake Case”). Neste sentido de padronização, é importante destacar ainda que existe um guia próprio para que os scripts sigam a recomendação de padronização, o The tidyverse style guide, criado pelo Hadley Wickham. Para os desenvolvedores, existe o Tidyverse design guide criado pelo Tidyverse team. # funcoes no formato snake_case read_csv() read_xlsx() as_tibble() left_join() group_by() Por fim, para evitar possíveis conflitos de funções com o mesmo nome entre pacotes, recomendamos fortemente o hábito de usar as funções seguido do operador ::. Assim, garante-se que a função utilizada é referente ao pacote daquela função. Segue um exemplo com as funções apresentadas anteriormente. # funcoes seguidas de seus respectivos pacotes readr::read_csv() readxl::read_xlsx() tibble::as_tibble() dplyr::left_join() dplyr::group_by() Seguindo essas ideias de organização de dados, outro conjunto de pacotes foi desenvolvido, chamado de tidymodels que atuam no workflow da análise de dados em ciência de dados: separação e reamostragem, pre-processamento, ajuste de modelos e métricas de performace de ajustes. Por razões de espaço e especificidade, não entraremos em detalhes dessa abordagem. Seguindo o workflow da Figura 5.4, iremos ver nos itens das próximas seções como esses passos são realizados com funções de cada pacote. 5.5.3 here Dentro do workflow do tidyverse, devemos sempre trabalhar com Projetos do RStudio, um tema que focamos com mais detalhes na seção XX. Junto com o projeto, também podemos fazer uso do pacote here. Ele permite construir caminhos para os arquivos do projeto de forma mais simples e com maior reprodutibilidade. Esse pacote cobre o ponto que discutimos na seção XX, dado que muitas vezes mudar o diretório com a função setwd() tende a ser demorado, principalmente quando se trata de um script em que várias pessoas estão trabalhando em diferentes computadores e sistemas operacionais. Além disso, ele elimina a questão da fragilidade dos scripts, pois geralmente um script está com os diretórios conectados exatamente a um lugar e a um momento. Por fim, ele também simplifica o trabalho com subdiretórios, facilitando importar ou exportar arquivos de ou para subpastas. Seu uso é relativamente simples: uma vez criado e aberto o RStudio pelo Projeto do RStudio, o diretório automaticamente é definido para o diretório do projeto. Depois disso, podemos usar a função here::here() para definir os subdiretórios onde estão os dados. O exemplo da aplicação fica para a seção seguinte, quando iremos de fato importar um arquivo para o R. Logo abaixo, mostramos como instalar e carregar o pacote here. # instalar install.packages(&quot;here&quot;) # carregar library(here) 5.5.4 readr, readxl e writexl Dado que possuímos um conjuntos de dados e que geralmente esse conjunto de dados estará no formato tabular com umas das extensões: .csv, .txt ou .xlsx, iremos usar o pacote readr ou readxl para importar esses dados para o R. Esses pacotes leem e escrevem grandes arquivos de forma mais rápida, além de fornecem medidores de progresso de importação e exportação, e imprimir a informação dos modos das colunas quando faz a importação. Outro ponto bastante positivo, é que também classificam automaticamente o modo dos dados de cada coluna, i.e., se uma coluna possui dados numéricos ou apenas texto, essa informação será considerada para classificar a coluna toda. A classe do objeto atribuído quando lido por esses pacotes é automaticamente um “tibble,” que veremos melhor na seção seguinte. Usamos as funções readr::read_csv() e readr::write_csv() para importar e exportar arquivos .csv do R, respectivamente. Para dados com a extensão .txt, podemos utilizar as funções readr::read_tsv() ou ainda readr::read_delim(). Para arquivos tabulares com a extensão .xlsx, temos de instalar dois pacotes adicionais: readxl e writexl, dos quais usaremos as funções readxl::read_excel(), readxl::read_xlsx() ou readxl::read_xls() para importar dados, atentado para o data de podermos indicar a aba com os dados com o argumento sheet, e writexl::write_xlsx() para exportar. Se o arquivo .csv foi criado com separador de decimais sendo . e separador de colunas sendo ,, usamos as funções normalmente. Caso tivesse sido criado com separador de decimais sendo , e separador de colunas sendo ;, usaríamos as funções dessa forma: readr::read_csv2(). Para exemplificar como importar dados no formato tidyverse, vamos importar novamente os dados de comunidades de anfíbios da Mata Atlântica (Atlantic Amphibians, Vancine et al. 2018), que fizemos o download na seção XX. Estamos usando a função readr::read_csv(), indicando os diretórios com a função here::here(), e a classe do arquivo é “tibble.” # importar lugares aa_locais &lt;- readr::read_csv( here::here(&quot;dados&quot;, &quot;tabelas&quot;, &quot;ATLANTIC_AMPHIBIANS_sites.csv&quot;) ) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## .default = col_character(), ## reference_number = col_double(), ## species_number = col_double(), ## month_start = col_double(), ## year_start = col_double(), ## month_finish = col_double(), ## year_finish = col_double(), ## effort_months = col_double(), ## latitude = col_double(), ## longitude = col_double(), ## altitude = col_double(), ## temperature = col_double(), ## precipitation = col_double() ## ) ## ℹ Use `spec()` for the full column specifications. 5.5.5 tibble O tibble (tbl_sf) é uma versão aprimorada do data frame (data.frame). Ele é a classe aconselhada para que as funções do tidyverse funcionem melhor sobre conjuntos de dados tabulares importados para o R. Geralmente, quando utilizamos funções tidyverse para importar dados para o R, é essa classe que esses dados adquirem depois de importados. Além da importação de dados, podemos criar um tibble no R usando a função tibble::tibble(), semelhante ao uso da função data.frame(). Podemos ainda converter um data.frame para um tibble usando a função tibble::as_tibble(). Entretanto, em alguns momentos precisaremos da classe data.frame para algumas funções específicas, e podemos converter um tibble para data.frame usa-se a função tibble::as_data_frame(). Existem duas diferenças principais no uso do tibble e do data.frame: impressão e subconjunto. Objetos da classe tibbles possuem um método de impressão que mostra a contagem do número de linhas e colunas, e apenas as primeiras 10 linhas e todas as colunas que cabem na tela no console, além dos modos ou tipos das colunas. Dessa forma, cada coluna ou variável, pode ser do modo numbers (int ou dbl), character (chr), logical (lgl), factor (fctr), date + time (dttm) date e (date), além de outras inúmeras possibilidades. # tibble - impressao aa_locais ## # A tibble: 1,163 x 25 ## id reference_number species_number record sampled_habitat active_methods ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 amp1001 1001 19 ab fo,ll as ## 2 amp1002 1002 16 co fo,la,ll as ## 3 amp1003 1002 14 co fo,la,ll as ## 4 amp1004 1002 13 co fo,la,ll as ## 5 amp1005 1003 30 co fo,ll,br as ## 6 amp1006 1004 42 co tp,pp,la,ll,is &lt;NA&gt; ## 7 amp1007 1005 23 co sp as ## 8 amp1008 1005 19 co sp,la,sw as,sb,tr ## 9 amp1009 1005 13 ab fo &lt;NA&gt; ## 10 amp1010 1006 1 ab fo &lt;NA&gt; ## # … with 1,153 more rows, and 19 more variables: passive_methods &lt;chr&gt;, ## # complementary_methods &lt;chr&gt;, period &lt;chr&gt;, month_start &lt;dbl&gt;, ## # year_start &lt;dbl&gt;, month_finish &lt;dbl&gt;, year_finish &lt;dbl&gt;, ## # effort_months &lt;dbl&gt;, country &lt;chr&gt;, state &lt;chr&gt;, state_abbreviation &lt;chr&gt;, ## # municipality &lt;chr&gt;, site &lt;chr&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, ## # coordinate_precision &lt;chr&gt;, altitude &lt;dbl&gt;, temperature &lt;dbl&gt;, ## # precipitation &lt;dbl&gt; Para o subconjunto, como vimos anteriormente, para selecionar colunas e linhas de objetos bidimensionais podemos utilizar o operador [] ou [[]] associado com números separados por vírgulas ou o nome da coluna entre aspas, e o operador $ para extrair pelo nome da coluna. Comparando um data.frame a um tibbles, esses últimos são mais rígidos: eles nunca fazem correspondência parcial e irão gerar um aviso se a coluna que você está tentando acessar não existir. # tibble - subconjunto aa_locais$ref ## Warning: Unknown or uninitialised column: `ref`. ## NULL Por fim, podemos “espiar” os dados utilizando a função tibble::glimpse() para ter uma noção geral de número de linhas, colunas, e conteúdo de todas as colunas. Essa é função tidyverse da função R Base str(). tibble::glimpse(aa_locais[, 1:10]) ## Rows: 1,163 ## Columns: 10 ## $ id &lt;chr&gt; &quot;amp1001&quot;, &quot;amp1002&quot;, &quot;amp1003&quot;, &quot;amp1004&quot;, &quot;amp… ## $ reference_number &lt;dbl&gt; 1001, 1002, 1002, 1002, 1003, 1004, 1005, 1005, … ## $ species_number &lt;dbl&gt; 19, 16, 14, 13, 30, 42, 23, 19, 13, 1, 1, 2, 4, … ## $ record &lt;chr&gt; &quot;ab&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, &quot;co&quot;, … ## $ sampled_habitat &lt;chr&gt; &quot;fo,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo,la,ll&quot;, &quot;fo… ## $ active_methods &lt;chr&gt; &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, &quot;as&quot;, NA, &quot;as&quot;, &quot;as,sb,t… ## $ passive_methods &lt;chr&gt; &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, &quot;pt&quot;, NA, NA, NA, NA, &quot;pt&quot;, &quot;p… ## $ complementary_methods &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ period &lt;chr&gt; &quot;mo,da,tw,ni&quot;, &quot;mo,da,tw,ni&quot;, &quot;mo,da,tw,ni&quot;, &quot;mo… ## $ month_start &lt;dbl&gt; 9, 12, 12, 12, 7, NA, 4, 4, 4, 5, 5, 5, 5, 5, 5,… 5.5.6 magrittr (pipe - %&gt;%) O operador pipe %&gt;% permite o encadeamento de várias funções, eliminando a necessidade de criar objetos para armazenar resultados intermediários. Dessa forma, pipes são uma ferramenta poderosa para expressar uma sequência de múltiplas operações. O operador pipe %&gt;% vem do pacote magrittr, entretanto, todos os pacotes no tidyverse automaticamente tornam o pipe disponível. Essa função torna os códigos em R mais simples, pois realizamos múltiplas operações em uma única linha. Ele captura o resultado de uma declaração e o torna a entrada da próxima declaração, então podemos pensar como “EM SEGUIDA FAÇA” ao final de cada linha de código. A principal vantagem do uso dos pipes é facilitar o debuging (achar erros) nos códigos, porque seu uso torna a linguagem R mais próxima do que falamos e pensamos, uma vez que evita o uso de funções dentro de funções (funções compostas). Digitar %&gt;% é um pouco chato, dessa forma, existe um atalho para sua inserção nos scripts: ctrl + shift + M. Para deixar esse tópico menos estranho à quem está vendo esse operação pela primeira vez, vamos fazer alguns exemplos. # base r - sem pipe sqrt(sum(1:100)) ## [1] 71.06335 # tidyverse - com pipe 1:100 %&gt;% sum() %&gt;% sqrt() ## [1] 71.06335 Essas operações ainda estão simples, vamos complicá-las com várias funções compostas. É nesses casos que a propriedade orgazacional do uso do pipe emerge: podemos facilmente ver o encadeamento de operações, onde cada função é organizada numa linha. # fixar amostragem set.seed(42) # base r - sem pipe ve &lt;- sum(sqrt(sort(log10(rpois(100, 10))))) ve ## [1] 99.91426 # fixar amostragem set.seed(42) # tidyverse - com pipe ve &lt;- rpois(100, 10) %&gt;% log10() %&gt;% sort() %&gt;% sqrt() %&gt;% sum() ve ## [1] 99.91426 O uso do pipe vai se tornar especialmente útil quando seguirmos para os pacotes das próximas duas seções: tidyr e dplyr. Com esses pacotes iremos fazer operações em linhas e colunas de nossos dados tabulares, então podemos encademar uma série de funções para manipulação, limpeza e análise de dados. Há ainda três outras variações do pipe que podem ser úteis em alguns momentos, mas que para funcionar precisam que o pacote magrittr seja carregado: %T&gt;%: retorna o lado esquerdo em vez do lado direito %$%: “explode” as variáveis em um quadro de dados %&lt;&gt;%: permite atribuição usando pipes 5.5.7 tidyr Os conjuntos de dados tidy (organizados) são mais fáceis de manipular, modelar e visualizar. Um conjunto de dados está arrumado ou não, dependendo de como linhas, colunas e células são combinadas com observações, variáveis e valores. Nos dados tidy, as variáveis estão nas colunas, observações estão nas linhas e valores estão nas células, sendo que para esse último, não deve haver mais de um valor por célula (Figura 5.5). Cada variável em uma coluna Cada observação em uma linha Cada valor como uma célula Figura 5.5: As três regras que tornam um conjunto de dados tidy. Adaptado de: Wickhan &amp; Grolemund (2017). Para realizar diversas transformações nos dados a fim de ajustá-los ao formato tidy, existe uma série de funções, para diversas finalidades: unir e separar, valores faltantes (NA), e pivotar (formato longo para largo), além de outras funções específicas. tidyr::unite(): junta dados de múltiplas colunas em uma coluna tidyr::separate(): separa caracteres em múlplica colunas tidyr::separate_rows(): separa caracteres em múlplica colunas e linhas tidyr::drop_na(): retira linhas com NA do conjunto de dados tidyr::replace_na(): substitui NA do conjunto de dados tidyr::pivot_wider(): transformar conjunto de dados longo (long) para largo (wide) tidyr::pivot_longer(): transformar conjunto de dados largo (wide) para longo (long) Para exemplicar o funcionamento dessas funções, usaremos os dados de medidas de pinguins chamados palmerpenguins. Esses dados estão disponíveis no pacote palmerpenguins. # instalar o pacote install.packages(&quot;palmerpenguins&quot;) Esses dados foram coletados e disponibilizados pela Dra. Kristen Gorman e pela Palmer Station, Antarctica LTER, membro da Long Term Ecological Research Network. O pacote palmerpenguins contém dois conjuntos de dados. Um é chamado de penguins e é uma versão simplificada dos dados brutos. O segundo conjunto de dados é penguins_raw e contém todas as variáveis e nomes originais baixados. Ambos os conjuntos de dados contêm dados para 344 pinguins, de três espécies diferentes, coletados em três ilhas no arquipélago de Palmer, na Antártica. # carregar o pacote palmerpenguins library(palmerpenguins) # ajuda dos dados ?penguins ?penguins_raw Primeiramente, vamos observar os dados e utilizar a função tidyr::glimpse() para ter uma noção geral. # visualizar os dados penguins_raw ## # A tibble: 344 x 17 ## studyName `Sample Number` Species Region Island Stage `Individual ID` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PAL0708 1 Adelie Pengu… Anvers Torge… Adult,… N1A1 ## 2 PAL0708 2 Adelie Pengu… Anvers Torge… Adult,… N1A2 ## 3 PAL0708 3 Adelie Pengu… Anvers Torge… Adult,… N2A1 ## 4 PAL0708 4 Adelie Pengu… Anvers Torge… Adult,… N2A2 ## 5 PAL0708 5 Adelie Pengu… Anvers Torge… Adult,… N3A1 ## 6 PAL0708 6 Adelie Pengu… Anvers Torge… Adult,… N3A2 ## 7 PAL0708 7 Adelie Pengu… Anvers Torge… Adult,… N4A1 ## 8 PAL0708 8 Adelie Pengu… Anvers Torge… Adult,… N4A2 ## 9 PAL0708 9 Adelie Pengu… Anvers Torge… Adult,… N5A1 ## 10 PAL0708 10 Adelie Pengu… Anvers Torge… Adult,… N5A2 ## # … with 334 more rows, and 10 more variables: Clutch Completion &lt;chr&gt;, ## # Date Egg &lt;date&gt;, Culmen Length (mm) &lt;dbl&gt;, Culmen Depth (mm) &lt;dbl&gt;, ## # Flipper Length (mm) &lt;dbl&gt;, Body Mass (g) &lt;dbl&gt;, Sex &lt;chr&gt;, ## # Delta 15 N (o/oo) &lt;dbl&gt;, Delta 13 C (o/oo) &lt;dbl&gt;, Comments &lt;chr&gt; # espiar os dados tibble::glimpse(penguins_raw) ## Rows: 344 ## Columns: 17 ## $ studyName &lt;chr&gt; &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL0708&quot;, &quot;PAL… ## $ `Sample Number` &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1… ## $ Species &lt;chr&gt; &quot;Adelie Penguin (Pygoscelis adeliae)&quot;, &quot;Adelie P… ## $ Region &lt;chr&gt; &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;, &quot;Anvers&quot;… ## $ Island &lt;chr&gt; &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;Torgersen&quot;, &quot;Torgerse… ## $ Stage &lt;chr&gt; &quot;Adult, 1 Egg Stage&quot;, &quot;Adult, 1 Egg Stage&quot;, &quot;Adu… ## $ `Individual ID` &lt;chr&gt; &quot;N1A1&quot;, &quot;N1A2&quot;, &quot;N2A1&quot;, &quot;N2A2&quot;, &quot;N3A1&quot;, &quot;N3A2&quot;, … ## $ `Clutch Completion` &lt;chr&gt; &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;, … ## $ `Date Egg` &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16,… ## $ `Culmen Length (mm)` &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34… ## $ `Culmen Depth (mm)` &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18… ## $ `Flipper Length (mm)` &lt;dbl&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190,… ## $ `Body Mass (g)` &lt;dbl&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 34… ## $ Sex &lt;chr&gt; &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;FEMALE&quot;, NA, &quot;FEMALE&quot;, &quot;MALE&quot;… ## $ `Delta 15 N (o/oo)` &lt;dbl&gt; NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.18… ## $ `Delta 13 C (o/oo)` &lt;dbl&gt; NA, -24.69454, -25.33302, NA, -25.32426, -25.298… ## $ Comments &lt;chr&gt; &quot;Not enough blood for isotopes.&quot;, NA, NA, &quot;Adult… Primeiramente, vamos exemplificar como juntar e serparar colunas. Vamos utilizar a função tidyr::unite() para unir as colunas “Region” e “Island.” Há diversos parâmetros para alterar como a funções funciona, entretanto, é importante destacar trŝ deles: col nome da coluna que vai receber as colunas unidas, sep indicando o caracter separador das colunas unidas, e remove para uma resposta lógica se as colunas unidas são removidas ou não. Vamos unir as colunas “Region” e “Island” na nova coluna “region_island,” # unir colunas penguins_raw_unir &lt;- tidyr::unite(data = penguins_raw, col = &quot;region_island&quot;, Region:Island, sep = &quot;, &quot;, remove = FALSE) De forma contrária podemos utilizar as funções tidyr::separate() e tidyr::separate_rows() para separar elementos de uma coluna em mais colunas. Respectivamente, a primeira função separa uma colunas em novas colunas conforme a separação e a segunda função separa uma coluna, distribuindo os elementos também nas linhas. Novamente, há diversos parâmetros, mas destacaremos quatro deles: col coluna a ser separada, into os nomes das novas colunas, sep indicando o caracter separador das colunas, e remove para uma resposta lógica se as colunas unidas são removidas ou não. Vamos separar a coluna “Stage” nas colunas “stage” e “egg_stage.” # separar colunas penguins_raw_separar &lt;- tidyr::separate(data = penguins_raw, col = Stage, into = c(&quot;stage&quot;, &quot;egg_stage&quot;), sep = &quot;, &quot;, remove = FALSE) # separar colunas penguins_raw_separar_linhas &lt;- tidyr::separate_rows(data = penguins_raw, Stage, sep = &quot;, &quot;) Valores faltantes (NA) é um tipo especial de elemento que discutimos na seção XX, e são relativamente comuns em grandes conjuntos de dados. Em Base R vimos algumas formas de lidar com esse tipo de elemento. No formato tidyverse existem várias formas de lidar com eles, mas aqui focaremos nas funções tidyr::drop_na() e tidyr::replace_na(), para retirar linhas e substitui-los, respectivamente. # remover todas as linhas com nas penguins_raw_todas_na &lt;- tidyr::drop_na(data = penguins_raw) # remover linhas de colunas especificas com nas penguins_raw_colunas_na &lt;- tidyr::drop_na(data = penguins_raw, any_of(&quot;Comments&quot;)) # substituir nas por outro valor penguins_raw_subs_na &lt;- tidyr::replace_na(data = penguins_raw, list(Comments = &quot;Unknown&quot;)) Por fim, trataremos de pivotagem ou remodelagem de dados. Veremos como mudar o formato do nosso conjunto de dados de longo (long) para largo (wide) e vice-versa. Essa é uma operação semelhante à “Tabela Dinâmica” das planilhas eletrônicas. Consiste em usar uma coluna para virar outras colunas, de modo que os valores são preenchidos corretamente, reduzindo assim o número de linhas, isso na transformação de longo (long) para largo (wide). Essa operação é bastante comum em Ecologia de Comunidades, quando queremos transformar uma lista de espécies em uma matriz de comunidades, com várias espécies nas colunas. Para realizar essa operação, usarmos a função tidyr::pivot_wider(). Dos diversos parâmetros que podem compor essa função, dois deles são fundamentais: names_from que indica a coluna de onde os nomes serão usados e values_from a coluna com os valores. # selecionar colunas penguins_raw_sel_col &lt;- penguins_raw[, c(2, 3, 13)] # pivotar para largo penguins_raw_pivot_wider &lt;- tidyr::pivot_wider(data = penguins_raw_sel_col, names_from = Species, values_from = `Body Mass (g)`) De modo oposto, podemos partir de um conjunto de dados largo (wide), ou seja, com várias colunas, e queremos que essas colunas preecham uma única coluna, e que os valores antes espalhados nessas várias colunas sejam adicionados um embaixo do outro. Para essa operação, podemos utilizar a função tidyr::pivot_longer(). Novamente, dos diversos parâmetros que podem compor essa função, trÊs deles são fundamentais: cols indicando as colunas que serão usandas para serem pivotadas, names_to que indica a coluna de onde os nomes serão usados e values_to a coluna com os valores. # selecionar colunas penguins_raw_sel_col &lt;- penguins_raw[, c(2, 3, 10:13)] # pivotar para largo penguins_raw_pivot_longer &lt;- tidyr::pivot_longer(data = penguins_raw_sel_col, cols = `Culmen Length (mm)`:`Body Mass (g)`, names_to = &quot;medidas&quot;, values_to = &quot;valores&quot;) 5.5.8 dplyr O dplyr é um pacote que facilita a manipulação de dados, com uma gramática de manipulação de dados simples e flexível (por exemplo, como filtragem, reordenamento, seleção, entre outras). Ele foi construído com o intuito de obter uma forma mais rápida e expressiva de tratar os dados. O tibble é a versão de data frame mais conveniente para se usar com pacote dplyr. Sua gramática simples contém funções verbais para manipulação de dados, baseada em: Verbos: mutate(), select(), filter(), arrange(), summarise(), slice(), rename(), etc. Sufixos: *_at(), *_if(), *_all(). Agrupamento: group_by() e ungroup(). Junções: inner_join(), full_join(), left_join(), right_join(), etc. Funções resumo: n(), n_distinct(), first(), last(), nth(), etc. Para realizar as manipulações nos dados existe uma série de funções, para diversas finalidades: manipulação de uma tabela, manipulação de duas tabela, agrupamento, funções de vetores, além de outras funções específicas. relocate(): muda a ordem das colunas rename(): muda o nome das colunas select(): seleciona colunas pelo nome pull(): seleciona uma coluna como vetor mutate(): adiciona novas colunas ou adiciona resultados em colunas existentes arrange(): reordenar as linhas com base nos valores de colunas filter(): seleciona linhas com base em valores distinct(): remove linhas com valores repetidos com base nos valores de colunas slice(): seleciona linhas pelos números sample_n(): amostragem aleatória de linhas summarise(): agrega ou resume os dados através de funções, podendo considerar valores das colunas *_join(): junta dados de duas tabelas através de uma coluna chave Todas as funções seguem a mesma sintaxe, de modo que o tibble é sempre o primeiro argumento das funções verbais, seguido de um pipe e pelo o nome da função. Isso permite o encademanto de várias operações consecutivas. tibble operador pipe nome da função verbal com os argumentos entre parênteses As funções verbais não precisam modificar o tibble original, sendo que as operações de manipulações podem e devem ser atribuídas à um novo objeto. tb_dplyr &lt;- tb %&gt;% funcao_verbal(argumento1, argumento2) Além de data.frames e tibbles, a manipulação pelo formato dplyr torna o trabalho com outros formatos de classes e dados acessível e eficiente. dtplyr: manipular conjuntos de dados data.table dbplyr: manipular conjuntos de dados SQL sparklyr: manipular conjuntos de dados no Apache Spark Para nossos exemplos, vamos utilizar os dados que carregamos anteriormente palmerpenguins. Esses dados estão disponíveis no pacote palmerpenguins. Mas agora, vamos utilizar o conjunto de dados penguins, que é uma versão simplificada dos dados brutos. Primeiramente, vamos reordenadar as colunas com a função dplyr::relocate(). Simplesmente listamos as colunas que queremos mudar de posição. Além disso, há dois argumentos bastante simples: .before que indica qual a coluna que as realocadas devem se mover antes e .after que indica qual a coluna que as realocadas devem se mover depois, ambas podem ser informadas com os nomes ou posições desses colunas com números. # reordenar colunas - nome penguins_relocate &lt;- penguins %&gt;% dplyr::relocate(sex, year, .after = island) # reordenar colunas - posicao penguins_relocate &lt;- penguins %&gt;% dplyr::relocate(sex, year, .after = 2) rename(): muda o nome das colunas select(): seleciona colunas pelo nome pull(): seleciona uma coluna como vetor mutate(): adiciona novas colunas ou adiciona resultados em colunas existentes arrange(): reordenar as linhas com base nos valores de colunas filter(): seleciona linhas com base em valores distinct(): remove linhas com valores repetidos com base nos valores de colunas slice(): seleciona linhas pelos números sample_n(): amostragem aleatória de linhas summarise(): agrega ou resume os dados através de funções, podendo considerar valores das colunas *_join(): junta dados de duas tabelas através de uma coluna chave 5.5.9 stringr Pacote para a manipulação de caracteres ou strings. Comprimento stringr::str_length(&quot;abc&quot;) ## [1] 3 Extração por posição stringr::str_sub(&quot;abc&quot;, 3) ## [1] &quot;c&quot; Inserir espaço em branco - esquerda stringr::str_pad(&quot;abc&quot;, width = 4, side = &quot;left&quot;) ## [1] &quot; abc&quot; Inserir espaço em branco - direira stringr::str_pad(&quot;abc&quot;, width = 4, side = &quot;right&quot;) ## [1] &quot;abc &quot; Remover espaço em branco do começo, final ou ambos stringr::str_trim(&quot; abc &quot;) ## [1] &quot;abc&quot; Minúsculas e maiúsculas stringr::str_to_upper(&quot;abc&quot;) ## [1] &quot;ABC&quot; stringr::str_to_title(&quot;abc&quot;) ## [1] &quot;Abc&quot; stringr::str_to_title(&quot;aBc&quot;) ## [1] &quot;Abc&quot; Ordenação le &lt;- sample(letters, 26, rep = TRUE) le ## [1] &quot;q&quot; &quot;m&quot; &quot;q&quot; &quot;t&quot; &quot;a&quot; &quot;q&quot; &quot;a&quot; &quot;b&quot; &quot;h&quot; &quot;p&quot; &quot;c&quot; &quot;e&quot; &quot;m&quot; &quot;l&quot; &quot;a&quot; &quot;s&quot; &quot;e&quot; &quot;o&quot; &quot;x&quot; ## [20] &quot;f&quot; &quot;w&quot; &quot;p&quot; &quot;j&quot; &quot;g&quot; &quot;i&quot; &quot;i&quot; stringr::str_sort(le) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;e&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;i&quot; &quot;j&quot; &quot;l&quot; &quot;m&quot; &quot;m&quot; &quot;o&quot; &quot;p&quot; &quot;p&quot; ## [20] &quot;q&quot; &quot;q&quot; &quot;q&quot; &quot;s&quot; &quot;t&quot; &quot;w&quot; &quot;x&quot; stringr::str_sort(le, dec = TRUE) ## [1] &quot;x&quot; &quot;w&quot; &quot;t&quot; &quot;s&quot; &quot;q&quot; &quot;q&quot; &quot;q&quot; &quot;p&quot; &quot;p&quot; &quot;o&quot; &quot;m&quot; &quot;m&quot; &quot;l&quot; &quot;j&quot; &quot;i&quot; &quot;i&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; ## [20] &quot;e&quot; &quot;e&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; Extrair por padrão stringr::str_extract(&quot;abc&quot;, &quot;b&quot;) ## [1] &quot;b&quot; Substituir stringr::str_replace(&quot;abc&quot;, &quot;a&quot;, &quot;y&quot;) ## [1] &quot;ybc&quot; Separação stringr::str_split(&quot;a-b-c&quot;, &quot;-&quot;) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 5.5.10 forcats Pacote para a manipulação de fatores. as_factor(): cria fatores # fixar amostragem set.seed(42) # cria um fator fa &lt;- sample(c(&quot;alto&quot;, &quot;medio&quot;, &quot;baixo&quot;), 30, rep = TRUE) %&gt;% forcats::as_factor() fa ## [1] alto alto alto alto medio medio medio alto baixo baixo alto alto ## [13] medio medio medio baixo baixo alto alto baixo alto baixo alto alto ## [25] medio baixo medio alto medio medio ## Levels: alto medio baixo fct_recode(): muda o nome dos níveis # muda o nome dos niveis fa_recode &lt;- fa %&gt;% forcats::fct_recode(a = &quot;alto&quot;, m = &quot;medio&quot;, b = &quot;baixo&quot;) fa_recode ## [1] a a a a m m m a b b a a m m m b b a a b a b a a m b m a m m ## Levels: a m b fct_rev(): inverte os níveis # inverte os niveis fa_rev &lt;- fa_recode %&gt;% forcats::fct_rev() fa_rev ## [1] a a a a m m m a b b a a m m m b b a a b a b a a m b m a m m ## Levels: b m a fct_relevel(): especifica a classificação de um ou mais níveis # especifica a classificacao de um nivel fa_relevel &lt;- fa_recode %&gt;% forcats::fct_relevel(c(&quot;a&quot;, &quot;m&quot;, &quot;b&quot;)) fa_relevel ## [1] a a a a m m m a b b a a m m m b b a a b a b a a m b m a m m ## Levels: a m b fct_inorder(): ordem em que aparece # ordem em que aparece fa_inorder &lt;- fa_recode %&gt;% forcats::fct_inorder() fa_inorder ## [1] a a a a m m m a b b a a m m m b b a a b a b a a m b m a m m ## Levels: a m b fct_infreq(): ordem (decrescente) de frequência # ordem (decrescente) de frequencia fa_infreq &lt;- fa_recode %&gt;% forcats::fct_infreq() fa_infreq ## [1] a a a a m m m a b b a a m m m b b a a b a b a a m b m a m m ## Levels: a m b fct_lump(): agregação de níveis raros em um nível # agregacao de niveis raros em um nivel fa_lump &lt;- fa_recode %&gt;% forcats::fct_lump() fa_lump ## [1] a a a a m m m a Other Other a a ## [13] m m m Other Other a a Other a Other a a ## [25] m Other m a m m ## Levels: a m Other 5.5.11 lubridate Pacote para trabalhar com datas. Pacote à parte do tidyverse # install install.packages(&quot;lubridate&quot;) # load library(lubridate) As funções date() e as_date() assumem que a ordem segue o padrão da língua inglesa: ano-mês-dia (ymd) date: classe para datas # string data_string &lt;- &quot;2020-04-24&quot; data_string ## [1] &quot;2020-04-24&quot; class(data_string) ## [1] &quot;character&quot; As funções date() e as_date() assumem que a ordem segue o padrão da língua inglesa: ano-mês-dia (ymd) date: classe para datas # criar um objeto com a classe data data_date &lt;- lubridate::date(data_string) data_date ## [1] &quot;2020-04-24&quot; class(data_date) ## [1] &quot;Date&quot; As funções date() e as_date() assumem que a ordem segue o padrão da língua inglesa: ano-mês-dia (ymd) date: classe para datas # criar um objeto com a classe data data_date &lt;- lubridate::as_date(data_string) data_date ## [1] &quot;2020-04-24&quot; class(data_date) ## [1] &quot;Date&quot; Datas no padrão da língua portuguesa: dia-mês-ano (dmy) date: classe para datas # string data_string &lt;- &quot;20-10-2020&quot; data_string ## [1] &quot;20-10-2020&quot; class(data_string) ## [1] &quot;character&quot; Datas no padrão da língua portuguesa: dia-mês-ano (dmy) date: classe para datas # criar um objeto com a classe data data_date &lt;- lubridate::dmy(data_string) data_date ## [1] &quot;2020-10-20&quot; class(data_date) ## [1] &quot;Date&quot; Além de outros diversos formatos # formatos lubridate::dmy(20102020) ## [1] &quot;2020-10-20&quot; lubridate::dmy(&quot;20102020&quot;) ## [1] &quot;2020-10-20&quot; lubridate::dmy(&quot;20/10/2020&quot;) ## [1] &quot;2020-10-20&quot; lubridate::dmy(&quot;20.10.2020&quot;) ## [1] &quot;2020-10-20&quot; Especificar horários # especificar horarios lubridate::dmy_h(2010202020) ## [1] &quot;2020-10-20 20:00:00 UTC&quot; lubridate::dmy_hm(201020202035) ## [1] &quot;2020-10-20 20:35:00 UTC&quot; lubridate::dmy_hms(20102020203535) ## [1] &quot;2020-10-20 20:35:35 UTC&quot; Funções úteis second(): extrai os segundos minute(): extrai os minutos hour(): extrai a hora wday(): extrai o dia da semana mday(): extrai o dia do mês month(): extrai o mês year(): extrai o ano Extração # criar data &lt;- lubridate::dmy_hms(20102020203535) data ## [1] &quot;2020-10-20 20:35:35 UTC&quot; # extrair lubridate::second(data) ## [1] 35 lubridate::day(data) ## [1] 20 lubridate::month(data) ## [1] 10 lubridate::wday(data) ## [1] 3 lubridate::wday(data, label = TRUE) ## [1] Tue ## Levels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat Inclusão # criar data &lt;- lubridate::dmy(20102020) data ## [1] &quot;2020-10-20&quot; # inlcuir lubridate::hour(data) &lt;- 13 data ## [1] &quot;2020-10-20 13:00:00 UTC&quot; Extrair a data no instante da execução # extrair a data no instante da execucao lubridate::today() ## [1] &quot;2021-02-27&quot; # extrair a data e horario no instante da execucao lubridate::now() ## [1] &quot;2021-02-27 03:36:00 -03&quot; Fusos horários # agora agora &lt;- lubridate::ymd_hms(lubridate::now(), tz = &quot;America/Sao_Paulo&quot;) agora ## [1] &quot;2021-02-27 03:36:00 -03&quot; # verificar os tz OlsonNames() %&gt;% head() ## [1] &quot;Africa/Abidjan&quot; &quot;Africa/Accra&quot; &quot;Africa/Addis_Ababa&quot; ## [4] &quot;Africa/Algiers&quot; &quot;Africa/Asmara&quot; &quot;Africa/Asmera&quot; # que horas sao em... lubridate::with_tz(agora, tzone = &quot;GMT&quot;) ## [1] &quot;2021-02-27 06:36:00 GMT&quot; lubridate::with_tz(agora, tzone = &quot;Europe/Stockholm&quot;) ## [1] &quot;2021-02-27 07:36:00 CET&quot; # altera o fuso sem mudar a hora lubridate::force_tz(agora, tzone = &quot;GMT&quot;) ## [1] &quot;2021-02-27 03:36:00 GMT&quot; Operações com datas Intervalos Intervalos podem ser salvos em objetos com classe interval # datas inicio_r &lt;- lubridate::dmy(&quot;30-11-2011&quot;) hoje_r &lt;- lubridate::today() r_intervalo &lt;- lubridate::interval(inicio_r, hoje_r) r_intervalo ## [1] 2011-11-30 UTC--2021-02-27 UTC class(r_intervalo) ## [1] &quot;Interval&quot; ## attr(,&quot;package&quot;) ## [1] &quot;lubridate&quot; Operações com datas Intervalos Intersecção de intervalor com a função int_overlaps() # outra forma de definir um intervalo: o operador %--% r_intervaloo &lt;- lubridate::dmy(&quot;30-11-2011&quot;) %--% lubridate::today() filho_intervalo &lt;- lubridate::dmy(&quot;26-09-2013&quot;) %--% lubridate::today() # verificar sobreposicao lubridate::int_overlaps(r_intervaloo, filho_intervalo) ## [1] TRUE Operações com datas Aritmética com datas # somando datas inicio_r + lubridate::ddays(1) ## [1] &quot;2011-12-01&quot; inicio_r + lubridate::dyears(1) ## [1] &quot;2012-11-29 06:00:00 UTC&quot; # criando datas recorrentes reunioes &lt;- lubridate::today() + lubridate::weeks(0:10) reunioes ## [1] &quot;2021-02-27&quot; &quot;2021-03-06&quot; &quot;2021-03-13&quot; &quot;2021-03-20&quot; &quot;2021-03-27&quot; ## [6] &quot;2021-04-03&quot; &quot;2021-04-10&quot; &quot;2021-04-17&quot; &quot;2021-04-24&quot; &quot;2021-05-01&quot; ## [11] &quot;2021-05-08&quot; # duracao de um intervalo r_intervalo &lt;- inicio_r %--% lubridate::today() r_intervalo ## [1] 2011-11-30 UTC--2021-02-27 UTC # transformacoes r_intervalo / lubridate::dyears(1) ## [1] 9.245722 r_intervalo / lubridate::ddays(1) ## [1] 3377 # total do periodo estudando r lubridate::as.period(r_intervaloo) ## [1] &quot;9y 2m 28d 0H 0M 0S&quot; # idade do meu filho lubridate::as.period(filho_intervalo) ## [1] &quot;7y 5m 1d 0H 0M 0S&quot; 5.5.12 purrr Pacote que implementa Programação Funcional Uma função chama outra função para ser aplicada repetidamente percorrendo elementos de um objeto (vetor, lista ou data frame) Exemplos: - Análise de experimento em vários locais - Análise de todas as respostas de um experimento - Análise dos dados com diferentes transformações de variáveis - Simulação computacional com diferentes delineamentos - Importação de todos os datasets de um diretório A principal função é a map*() e sua “família” map(.x, .f) .x: uma vetor, lista ou data frame .f: uma função Aplicando uma função em série x &lt;- list(1:5, c(4, 5, 7), c(1, 1, 1), c(2, 2, 2, 2, 2)) purrr::map(x, sum) ## [[1]] ## [1] 15 ## ## [[2]] ## [1] 16 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 10 Tipos de retorno map returns - map(): list - map_chr(): character vector - map_dbl(): double vector (numeric) - map_int(): integer vector - map_lgl(): logical vector - map_dfc(): data frame (by column) - map_dfr(): data frame (by row) Retorna double vector (numeric) purrr::map_dbl(x, sum) ## [1] 15 16 3 10 Retorna strings purrr::map_chr(x, paste, collapse = &quot; &quot;) ## [1] &quot;1 2 3 4 5&quot; &quot;4 5 7&quot; &quot;1 1 1&quot; &quot;2 2 2 2 2&quot; Duas listas em paralelo x &lt;- list(3, 5, 0, 1) y &lt;- list(3, 5, 0, 1) purrr::map2_dbl(x, y, prod) ## [1] 9 25 0 1 Várias listas aninhadas x &lt;- list(3, 5, 0, 1) y &lt;- list(3, 5, 0, 1) z &lt;- list(3, 5, 0, 1) purrr::pmap_dbl(list(x, y, z), prod) ## [1] 27 125 0 1 Calcular a média para várias colunas mean_var &lt;- si %&gt;% dplyr::select(species_number, altitude) %&gt;% purrr::map_dbl(mean) mean_var Calcular o desvio padrão para várias colunas sd_var &lt;- si %&gt;% dplyr::select(species_number, altitude) %&gt;% purrr::map_dbl(sd) sd_var furrr - Programação funcional paralelizada Faz o mapeamento em paralelo mais integrado possível 5.6 Exercícios 5.6.1 Base R Use o R para verificar o resultado da operação 7 + 7 ÷ 7 + 7 x 7 - 7. Verifique através do R se 3x2³ é maior que 2x3². Crie dois objetos (qualquer nome) com os valores 100 e 300. Multiplique esses objetos (função prod()) e atribuam ao objeto mult. Faça o logaritmo natural (função log()) do objeto mult e atribuam ao objeto ln. Quantos pacotes existem no CRAN nesse momento? Execute essa combinação no Console: nrow(available.packages(repos = \"http://cran.r-project.org\")). Instale o pacote tidyverse do CRAN. Escolha números para jogar na mega-sena usando o R, nomeando o objeto como mega. Lembrando: são 6 valores de 1 a 60 e atribuam a um objeto. Crie um fator chamado tr, com dois níveis (“cont” e “trat”) para descrever 100 locais de amostragem, 50 de cada tratamento. O fator deve ser dessa forma cont, cont, cont, ...., cont, trat, trat, ...., trat. Crie uma matriz chamada ma, resultante da disposição de um vetor composto por 10000 valores aleatórios entre 0 e 10. A matriz deve conter 100 linhas e ser disposta por colunas. Crie um data frame chamado df, resultante da composição desses vetores: id: 1:50 sp: sp01, sp02, ..., sp49, sp50 ab: 50 valores aleatórios entre 0 a 5 Crie uma lista com os objetos criados anteriormente: mega, tr, ma e df. Selecione os elmentos ímpares do objeto tr, e atribua ao objeto tr_impar. Selecione as linhas com ids pares do objeto df, e atribua ao objeto df_ids_par. Faça uma amostragem de 10 linhas do objeto df, e atribua ao objeto df_amos10. 5.6.2 tidyverse Reescreva as operações abaixo utilizando pipes %&gt;%. log10(cumsum(1:100)) sum(sqrt(abs(rnorm(100)))) sum(sort(sample(1:10, 10000, rep = TRUE))) 5.7 Material de R Listamos a seguir livros, apostilas e links com material que recomendamos para seguir com sua aprendizagem em R. 5.7.1 Livros OLIVEIRA, Paulo Felipe de; GUERRA, Saulo; MCDONNEL, Robert (2018) Ciência de Dados com R – Introdução. Editora IBPAD. https://cdr.ibpad.com.br/ Pedro Duarte Faria, João Pedro Figueira Amorim Parga (2020) Introdução à Linguagem R: seus fundamentos e sua prática. https://www.researchgate.net/publication/345985082_Introducao_a_Linguagem_R_seus_fundamentos_e_sua_pratica Carrie Wright, Shannon Ellis, Stephanie Hicks, and Roger D. Peng (2021) Tidyverse Skills for Data Science in R. https://leanpub.com/tidyverseskillsdatascience Tilman M. Davies (2016) The Book of R: a first course in programming and statistics. Wickham H, Grolemund G (2017) R for Data Science. O’Reilly. Wickham H (2018) Advanced R. 2nd ed. Chapman &amp; Hall’s R Series. 5.7.2 Apostilas 5.7.3 Links R resources (free courses, books, tutorials, &amp; cheat sheets) "]]
