--- 
title: "Introdu√ß√£o ao R com aplica√ß√µes em biodiversidade e conserva√ß√£o"
author: ""
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook."
---
--- 
title: "Introdu√ß√£o ao R com aplica√ß√µes em biodiversidade e conserva√ß√£o"
author: ""
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

# Pr√©-requisitos



<!--chapter:end:index.Rmd-->

# Pr√©-requisitos



<!--chapter:end:01_pre_requisitos.Rmd-->

# Como usar este livro



<!--chapter:end:02_uso_livro.Rmd-->

# Perguntas em ecologia



<!--chapter:end:03_perguntas_ecologia.Rmd-->


# Introdu√ß√£o √† linguagem R

Placeholder


## R e RStudio
## Material de R
## Funcionamento da linguagem R
## Estrutura e manipula√ß√£o de dados 
### Tipos de objeto (vetor, fator, matriz, data frame, lista, fun√ß√µes)
## Entendendo o arquivo de ajuda, como buscar ajuda
## Instalando e carregando pacotes do CRAN e do GitHub/GitLab
## Importa√ß√£o e exporta√ß√£o de dados 
## tidyverse (readr, readxl, tibble, tidyr, dplyr, stringr, lubridate e purrr?)
## Principais erros de iniciantes e a melhor forma de pedir ajuda
### Procurando e entendendo erros
#### Certifique-se que leu e entendeu a mensagem de erro
#### Certifique-se que instalou e carregou os pacotes das fun√ß√µes que ir√° utilizar
#### Certifique-se que definiu o diret√≥rio correto de onde quer importar ou exportar seus dado
#### Certifique-se que sua planilha est√° com separa√ß√£o de decimais e colunas corretos
#### Certifique-se que os arquivos que ir√£o ser importados n√£o est√£o corrompidos
#### Certifique-se que n√£o digitou algum comando errado
#### Certifique-se que a atribui√ß√£o foi feita corretamente
#### Certifique-se que a Classe do objeto √© a mesma requerida pela fun√ß√£o
### Tentando resolver seus pr√≥prios erros
#### Leia a documenta√ß√£o das fun√ß√µes
#### Fa√ßa buscas extensivas no Google e no Stack Overflow
### Idealmente, como pedir ajuda?

<!--chapter:end:04_r_tidyverse.Rmd-->

# Gr√°ficos

<!--chapter:end:05_graficos.Rmd-->


# Estat√≠stica b√°sica

Placeholder


## Teste T (de Student) para duas amostras independentes
### Backgorund da an√°lise
#### Exemplo pr√°tico 1 - Teste T para duas amostras com vari√¢ncias iguais
##### Explica√ß√£o dos dados
### An√°lise
#### Exemplo pr√°tico 2 - Teste T para duas amostras independentes com vari√¢ncias diferentes
##### Explica√ß√£o dos dados
### An√°lise
## Teste T para amostras pareadas
### Backgorund da an√°lise
#### Exemplo pr√°tico 1 - Teste T para amostras pareadas
##### Explica√ß√£o dos dados
### An√°lise
## Correla√ß√£o de Pearson
### Backgorund da an√°lise
#### Exemplo pr√°tico 1 - Correla√ß√£o de Pearson
##### Explica√ß√£o dos dados
### An√°lise
## Regress√£o Simples
### Backgorund da an√°lise
#### Exemplo pr√°tico 1 - Regress√£o simples
##### Explica√ß√£o dos dados
### An√°lise
## Regress√£o M√∫ltipla
### Backgorund da an√°lise
#### Exemplo pr√°tico 1 - Regress√£o m√∫ltipla
##### Explica√ß√£o dos dados
### An√°lise
## An√°lises de Vari√¢ncia (ANOVA)
### Backgorund da an√°lise
## ANOVA de um fator
#### Exemplo pr√°tico 1 - Anova de um fator
##### Explica√ß√£o dos dados
### An√°lise
## ANOVA de dois fatores ou Anova fatorial
#### Exemplo pr√°tico 1 - Anova de dois fatores
##### Explica√ß√£o dos dados
### An√°lise
## ANOVA em blocos aleatorizados
#### Exemplo pr√°tico 1 - Anova em blocos aleatorizados
##### Explica√ß√£o dos dados
### An√°lise
## An√°lise de covari√¢ncia (ANCOVA)
#### Exemplo pr√°tico 1 - ANCOVA
##### Explica√ß√£o dos dados
### An√°lise
### Para se aprofundar

<!--chapter:end:06_analises_univariadas_lm.Rmd-->

# An√°lises univariadas - GLM



<!--chapter:end:07_analises_univariadas_glm.Rmd-->


# Introdu√ß√£o √† An√°lises Multidimensionais

Placeholder


## Backgorund da an√°lise
## Exemplo 1: 
### Explica√ß√£o da an√°lise
### An√°lise
#### Interpreta√ß√£o dos resultados
## Exemplo 2: 
## Backgorund da an√°lise
## Exemplo 1: 
### Explica√ß√£o da an√°lise
### An√°lise
## Backgorund da an√°lise
## Exemplo 1: 
### Explica√ß√£o da an√°lise
### An√°lise
### Para se aprofundar

<!--chapter:end:08_analises_multivariadas.Rmd-->


# Rarefa√ß√£o

Placeholder


## Background da an√°lise
## Exemplo pr√°tico 1 - Morcegos
### Explica√ß√£o
### An√°lise
### Interpreta√ß√£o dos resultados
## Exemplo pr√°tico 2 - Rarefa√ß√£o
### Explica√ß√£o
### An√°lise
### Interpreta√ß√£o dos resultados
## Para se aprofundar

<!--chapter:end:09_rarefacao.Rmd-->


# Estimadores de Riqueza

Placeholder


## Backgorund da an√°lise
## Estimadores baseados na abund√¢ncia das esp√©cies
### CHAO 1 - (Chao 1984, 1987): 
#### Exemplo pr√°tico - Chao 1
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
### ACE - *Abundance-based Coverage Estimador* (Chao & Lee 1992, Chao et al. 2000): 
#### Exemplo pr√°tico - ACE
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
## Estimadores baseados na incid√™ncia das esp√©cies
### CHAO 2 - (Chao 1987): 
#### Exemplo pr√°tico - Chao 2
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
### JACKKNIFE 1 (Burnham & Overton 1978, 1979): 
#### Exemplo pr√°tico - Jackknife 1
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
### JACKKNIFE 2 (Burnham & Overton 1978, 1979, Palmer 1991): 
#### Exemplo pr√°tico - Jackknife 2
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
### BOOTSTRAP (Smith & van Belle 1984): 
#### Exemplo pr√°tico - Bootstrap
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
### Interpola√ß√£o e Extrapola√ß√£o baseadas em rarefa√ß√£o usando amostragens de incid√™ncia ou abund√¢ncia (Chao & Jost 2012, Colwell et al. 2012): 
#### Exemplo pr√°tico 
##### Explica√ß√£o dos dados
### An√°lise
#### Interpreta√ß√£o dos resultados
#### Interpreta√ß√£o dos resultados
### Para se aprofundar

<!--chapter:end:10_riqueza.Rmd-->


# Diversidade Taxon√¥mica

Placeholder


## Diversidade alfa (ùõÇ)
## Riqueza de esp√©cies ou n√∫mero de esp√©cies
#### Exemplo pr√°tico 1 - Riqueza de esp√©cies
## Diversidade de esp√©cies
#### Exemplo pr√°tico 2 - Diversidade de esp√©cies
## Diagramas de Whittaker ou Curva de Domin√¢ncia
## N√∫meros de Hill
## Diversidade beta (ùõÉ)
### Para se aprofundar

<!--chapter:end:11_diversidade_taxonomica.Rmd-->

# Diversidade filogen√©tica



<!--chapter:end:12_diversidade_filogenetica.Rmd-->

# Diversidade funcional



<!--chapter:end:13_diversidade_funcional.Rmd-->

# Dados geogr√°ficos no R #dados-geograficos}

## Introdu√ß√£o

Nesta se√ß√£o, vamos fazer uma breve introdu√ß√£o aos principais conceitos sobre o funcionamento de dados geogr√°ficos no R: formatos de dados vetoriais e pacotes; formatos de dados raster e pacotes; Sistemas de Refer√™ncias de Coordenadas e unidades; fontes de dados geogr√°ficos e pacotes; importar e exportar dados geogr√°ficos; descri√ß√£o de objetos espaciais; reproje√ß√£o de dados geogr√°ficos; e principais opera√ß√µes com dados geogr√°ficos. Num segundo momento, iremos criar mapas com seus principais elementos. Por fim, apresentaremos exemplos de aplica√ß√µes de an√°lises espaciais para dados ecol√≥gicos, focadas em resumir informa√ß√µes sobre a biodiverisdade, preparar de dados para compor vari√°veis preditoras, e como fazer predi√ß√µes espaciais cont√≠nuas de distribui√ß√£o de uma esp√©cie e riqueza de esp√©cies.

Esse cap√≠tulo segue parte da estrutura organizada por @lovelace-etal-2019, principalmente os cap√≠tulos 2 a 8, sendo adaptado para atender aos principais requisitos que julgamos necess√°rios a estudos ecol√≥gicos. Entretanto, n√£o foi poss√≠vel cobrir todos os assuntos sobre geoprocessamento, sendo um assunto muito extenso, que requer a leitura de livros especializados na √°rea como Wegmann et al. (2016), Wegmann et al. (2020) e Fletcher & Fortin (2018). Outros livros sobre a an√°lise geoespacial no R podem ser consultados no cap√≠tulo [11 - Geospatial](https://www.bigbookofr.com/geospatial.html) do [Big Book of R](https://www.bigbookofr.com/index.html).

Todas as opera√ß√µes ser√£o realizadas atrav√©s da linguagem R, utilizando principalmente os pacotes: *tidyverse* (Wickham et al. 2019) para o formato tidyverse, *here* (M√ºller 2020) para diret√≥rios,  *sf* [@pebesma-2018] para dados vetoriais, *raster* [@hijmans-2020] para dados raster, *rgdal* para formatos geoespaciais (Bivand et al. 2021), *rnaturalearth* (South 2017) e *geobr* (Pereira & Goncalves 2020) para baixar dados vetoriais, e *ggplot2* (Wickham 2016), *ggspatial* (Dunnington 2020), *tmap* (Tennekes 2018), *mapview* (Appelhans et al. 2020), *leaflet* (Cheng et al. 2021), e *viridis* [@garnier-2018] para a composi√ß√£o de mapas, dentro outros.

## Pr√©-requisitos
Dessa forma, garanta que esses pacotes listados a seguir estejam instalados e carregados.

```{r eval=FALSE}
# instalar pacotes
install.packages(c("tidyverse", 
                   "here", 
                   "sf", 
                   "raster", 
                   "rgdal", 
                   "spData",
                   "rnaturalearth",
                   "geobr",
                   "ggplot2",
                   "ggspatial",
                   "tmap",
                   "tmaptools",
                   "grid",
                   "mapview",
                   "leaflet",
                   "viridis"), 
                 dep = TRUE)
```

```{r message=FALSE, warning=FALSE}
# carregar pacotes
library(tidyverse)
library(here)
library(sf) 
library(raster) 
library(rgdal) 
library(spData)
library(rnaturalearth)
library(geobr)
library(ggplot2)
library(ggspatial)
library(tmap)
library(tmaptools)
library(grid)
library(mapview)
library(leaflet)
library(viridis)
```

> **IMPORTANTE**: Se voc√™ estiver utilizando MacOS ou Linux, a instala√ß√£o dos pacotes listados acima pode n√£o funcionar. Esses sistemas operacionais possuem "requisitos espec√≠ficos do sistema" que s√£o geralmente descritos no `README.md` dos pacotes no GitHub. Entretanto, h√° v√°rias instru√ß√µes espec√≠ficas que podem ser encontradas [on-line](https://rtask.thinkr.fr/installation-of-r-4-0-on-ubuntu-20-04-lts-and-tips-for-spatial-packages/). Al√©m deste link, h√° posts sobre [Linux](https://geocompr.github.io/post/2020/installing-r-spatial-ubuntu/) e [MacOS](http://www.kyngchaos.com/) que podema auxiliar.

## Vetor

Dados **vetoriais** representam informa√ß√µes geogr√°ficas acuradas atrav√©s de **pontos, linhas e pol√≠gonos** (Figura \@ref(fig:fig-vetor-tipos)). Cada uma dessas geometrias s√£o indicadas para representar fei√ß√µes e/ou eventos espec√≠ficos, como veremos adiante.

```{r fig-vetor-tipos, echo=FALSE, fig.height=4, fig.align='center', fig.cap="Ilustra√ß√£o das geometrias de ponto, linha e pol√≠gono gen√©ricos. Adaptado de: Lovelace, Nowosad & Muenchow (2019)."}
old_par = par(mfrow = c(1, 3), pty = "s", mar = c(0, 3, 1, 0))
plot(st_as_sfc(c("POINT(5 5)")), axes = TRUE, pch = 20, cex = 2, main = "Ponto")
plot(st_as_sfc("LINESTRING(1 4, 5 5, 4 1, 2 2)"), lwd = 2, axes = TRUE, main = "Linha")
plot(st_as_sfc("POLYGON((1 4, 2 2, 4 1, 5 5, 1 4))"), col="gray", lwd = 2, axes = TRUE, main = "Pol√≠gono")
par(old_par)
```

### Pontos

**Pontos** s√£o geometrias geralmente utilizadas para representar **eventos pontuais unit√°rios**, como ocorr√™ncia de esp√©cies, locais de coleta, pontos de GPS ou nascentes de rios. Esses dados s√£o representados por um √∫nico v√©rtice, ou seja, um par de coordenadas (longitude - X e latitude - Y), que s√£o plotados na forma de c√≠culos ou outro elemento que represente o evento em quest√£o. Dessa forma, geralmente utilizamos dados tabulares com pelo menos duas colunas contendo essas coordenadas. Al√©m disso, esses dados tabulares podem conter outras colunas com informa√ß√µes quantitativas ou qualitativas como n√∫mero de esp√©cies, temperatura, precipita√ß√£o ou ainda categorias como tipo de habitat, que podemos representar nos pontos atrav√©s de diferentes formatos, tamanhos ou cores desses pontos (Tabela \@ref(tab:tab-vetor-pontos) e Figura \@ref(fig:fig-vetor-pontos)).

```{r tab-vetor-pontos, echo=FALSE}
library(knitr)
kable(tibble::tibble(
  Id = 1:5, 
  Longitude = c(0, 1, 2, 5, 5) ,
  Latitude = c(2, 5, 3, 4, 1),
  `N√∫mero de esp√©cies` = c(2, 3, 3, 2, 5),
  Temperatura = c(20, 22, 28, 23, 25),
  Precipita√ß√£o = c(1000, 1100, 1300, 1200, 1450),
  Habitat = c("floresta", "pastagem", "floresta", "floresta", "pastagem")), 
  caption = "Dados tabulares para pontos."
)
```

```{r fig-vetor-pontos, echo=FALSE, fig.align='center', fig.cap="Geometrias de pontos e suas identifica√ß√µes com a tabela de dados."}
plot(st_as_sfc(c("MULTIPOINT(0 2, 1 5, 2 3, 5 4, 5 1)")), axes = TRUE, pch = 20, cex = 2, xlim = c(0, 5), ylim = c(1, 5), main = "Pontos")
text(x = c(0, 1, 2, 5, 5), 
     y = c(2, 5, 3, 4, 1) - c(rep(.3, 4), -.3), 
     labels = 1:5)
```

### Linhas

**Linhas** representam **geometrias lineares** como estradas, rios, trajetos, divis√µes ou dist√¢ncias. Geralmente as linhas s√£o criadas em softwares de Sistema de Informa√ß√µes Geogr√°ficas (SIG) como o [QGIS](https://qgis.org/), e depois importadas para o R. As linhas s√£o representadas por no m√≠nimo dois v√©rtices conectados, i.e., dois pares de coordenadas, gerando uma geometria aberta, possuindo como caracter√≠stica o **comprimento**. Da mesma forma que os pontos, as linhas podem possuir informa√ß√µes tabulares, sendo quantitativas como comprimento dessa fei√ß√£o, ou ainda informa√ß√µes qualitativas como o nome de estradas ou vaz√£o de rios, que podem ser utilizadas para alterar o formato, tamanho ou cor dessas linhas (Tabela \@ref(tab:tab-vetor-linhas) e Figura \@ref(fig:fig-vetor-linhas)).

```{r tab-vetor-linhas, echo=FALSE, results='asis'}
kable(tibble(Id = 1:5, 
             Rodovias = paste0("rodovia_0", 1:5),
             Comprimento = c(12, 52, 5, 38, 18)),
      caption = "Dados tabulares para linhas.",
      align = "c")
```

```{r fig-vetor-linhas, echo=FALSE, fig.align='center', fig.cap="Geometrias de linhas e suas identifica√ß√µes com a tabela de dados."}
plot(st_as_sfc("MULTILINESTRING((1 1, 2 2), (1 3, 5 3), (1 4, 1 5), (3 5, 5 5, 5 4), (3 1, 5 1))"), 
     lwd = 2, axes = TRUE, main = "Linhas")
text(x = c(1.1, 5, 1.2, 5, 5), 
     y = c(1.3, 2.8, 5, 3.8, 1.2), 
     labels = 1:5)
```

### Pol√≠gonos

Por fim, **pol√≠gonos** representam **geometrias fechadas**, como fragmentos de vegeta√ß√£o, lagos ou limites geogr√°ficos, sendo mais voltado para representar fei√ß√µes de um mapa de uso e cobertura da terra ou limites geogr√°ficos naturais, pol√≠ticos, administrativos ou regulares. Os pol√≠gonos tamb√©m s√£o criados geralmente em softwares espec√≠ficos de SIG e depois importados para o R, ou podemos usar fun√ß√µes para criar *buffers* ou malhas de quadr√≠culas ou hex√°gonos. Os pol√≠gonos s√£o representados por no m√≠nimo tr√™s v√©rtices conectados, sendo que o primeiro v√©rtice possui coordenadas id√™nticas ao √∫ltimo, de modo que essa liga√ß√£o gere uma fei√ß√£o fechada, com caracter√≠sticas como **per√≠metro** e/ou **√°rea**. Da mesma forma que os pontos e linhas, colunas podem ser associadas aos pol√≠gonos para representar informa√ß√µes quantitativas como per√≠metro e √°rea dessa pol√≠gono, ou ainda informa√ß√µes qualitativas como a classe de cobertura da terra ou o nome do limite geogr√°fico, que podem ser utilizados para alterar formatos, tamanho ou cores desses pol√≠gonos (Tabela \@ref(tab:tab-vetor-poligonos) e Figura \@ref(fig:fig-vetor-poligonos)).

```{r tab-vetor-poligonos, echo=FALSE, results='asis'}
kable(tibble(id = 1:5, 
             uso = c("floresta", "urbano", "pastagem", "agua", "cerrado"),
             area_ha = c(50, 22, 30, 25, 40),
             perimeto_m = c(700, 300, 250, 400, 500)),
      caption = "Dados tabulares para pol√≠gonos.",
      align = "c")
```

```{r fig-vetor-poligonos, echo=FALSE, fig.align='center', fig.cap="Geometrias de pol√≠gonos e suas identifica√ß√µes com a tabela de dados."}
plot(st_as_sfc("MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)))"),
     axes = TRUE, col = "forestgreen", main = "Pol√≠gonos")
plot(st_as_sfc("MULTIPOLYGON (((4 1, 2 1, 2 2, 2 2, 4 1)))"),
     col = "gray", add = TRUE)
plot(st_as_sfc("MULTIPOLYGON (((4 1, 4 5, 5 5, 5 1, 4 1)))"),
     col = "yellow", add = TRUE)
plot(st_as_sfc("MULTIPOLYGON (((4 4, 4 5, 1 5, 4 4)))"),
     col = "steelblue", add = TRUE)
plot(st_as_sfc("MULTIPOLYGON (((0 1, 0 5, 1 5, 2 2, 2 1, 0 1)))"),
     col = "orange", add = TRUE)
text(x = c(2.8, 2.5, 4.5, 3.1, .7), 
     y = c(3, 1.3, 3, 4.7, 3), 
     labels = c("floresta\n(1)", "urbano\n(2)", "pastagem\n(3)", "agua\n(4)", "cerrado\n(5)"))
```

Al√©m disso, geralmente utilizamos **pol√≠gono regulares** (buffers, quadr√≠culas ou hex√°gonos) para **resumir informa√ß√µes** de biodiversidade ou de vari√°veis preditoras, que podem ser utilizadas como unidades amostrais em an√°lises espaciais ou estat√≠sticas, principalmente nas √°reas de Ecologia Espacial, Ecologia da Paisagem, Biogeografia e Macroecologia (Tabela \@ref(tab:tab-vetor-poligonos-regulares) e Figura \@ref(fig:fig-vetor-poligonos-regulares)).

```{r tab-vetor-poligonos-regulares, echo=FALSE}
kable(tibble(id = c(1:5, "..."), 
             numero_especies = c(2, 3, 3, 2, 5, "..."),
             temperatura = c(20, 22, 28, 23, 25, "..."),
             precipitacao = c(1000, 1100, 1300, 1200, 1450, "...")),
      caption = "Dados tabulares.",
      align = "c")
```

```{r fig-vetor-poligonos-regulares, echo=FALSE, fig.height=4, fig.align='center', fig.cap="Pol√≠gonos regulares: buffers, quadr√≠culas e hex√°gonos."}
old_par = par(mfrow = c(1, 3), pty = "s", mar = c(0, 3, 1, 0))

plot(st_as_sfc("MULTIPOINT(1 2, 1 5, 2 3, 4 4, 4 1)"),
     pch = 20, axes = TRUE, xlim = c(0, 5), ylim = c(0, 6), main = "Buffers")
plot(st_as_sfc("MULTIPOINT(1 2, 1 5, 2 3, 4 4, 4 1)") %>% 
       sf::st_as_sf() %>% 
       sf::st_buffer(.5),
     lwd = 2, add = TRUE)
text(x = c(1, 1, 2, 4, 4), 
     y = c(2, 5, 3, 4, 1) + .3, 
     labels = 1:5, col = "gray50")

plot(st_as_sfc("POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))") %>% 
       sf::st_as_sf() %>% 
       sf::st_make_grid(cellsize = 1),
     lwd = 2, axes = TRUE, main = "Quadr√≠culas")
text(x = rep(seq(.5, 4.5, 1), 5), 
     y = rep(seq(.5, 4.5, 1), each = 5), 
     labels = c(21:25, 16:20, 11:15, 6:10, 1:5), col = "gray50")

plot(st_as_sfc("POLYGON((.5 .5, .5 4, 4 4, 4 .5, .5 .5))") %>%
       sf::st_as_sf() %>%
       sf::st_make_grid(cellsize = 1, square = FALSE),
     lwd = 2, axes = TRUE, main = "Hex√°gonos")
text(x = c(seq(.5, 4.5, 1),
           seq(0, 4, 1),
           seq(.5, 4.5, 1),
           seq(0, 4, 1),
           seq(.5, 4.5, 1),
           seq(0, 4, 1)),
     y = c(rep(0.5, 5),
           rep(1.35, 5),
           rep(2.25, 5),
           rep(3.1, 5),
           rep(3.95, 5),
           rep(4.85, 5)),
     labels = c(26:30, 21:25, 16:20, 11:15, 6:10, 1:5),
     col = "gray50")

par(old_par)
```

### Tabela de atributos

Para os dados vetoriais √© necess√°rio ainda destacar um elemento fundamental: a **tabela de atributos**. A tabela de atributos √© uma tabela que inclui dados **geogr√°ficos** e **dados alfanum√©ricos**. Os **dados geogr√°ficos** s√£o representados por cada fei√ß√£o geolocalizada espacialmente (ponto, linha ou pol√≠gono), e os **dados alfanum√©ricos** s√£o todos os demais dados associados a cada uma dessas fei√ß√µes, representado na forma de colunas (Figuras \@ref(fig:fig-vetor-pontos), \@ref(fig:fig-vetor-linhas), \@ref(fig:fig-vetor-poligonos) e \@ref(fig:fig-vetor-poligonos-regulares)).

Dessa forma, a **tabela de atributos** re√∫ne informa√ß√µes sobre cada fei√ß√£o e pode ser utilizada para realizar de filtros ou agrega√ß√µes dos dados de cada fei√ß√£o. √â nessa tabela que podemos ainda concatenar novas informa√ß√µes (colunas) de opera√ß√µes com as fei√ß√µes (linhas da tabela de atributos) como c√°lculo de comprimento, per√≠metro, √°rea ou ainda outras opera√ß√µes com as colunas. Tamb√©m podemos associar outros dados n√£o espaciais aos dados da tabela de atributos com a jun√ß√£o por uma coluna identificadora.

### *sf*: principal pacote no R para dados vetoriais

Atualmente o principal pacote para trabalhar com dados vetoriais no R √© o [*sf*](https://r-spatial.github.io/sf/), que implementou o *Simple Feature* no R (Pebesma 2018). Entretanto, outro pacote pode ser t√£o vers√°til quanto o *sf*, no caso o [*terra*](https://rspatial.org/terra/index.html), ainda em desenvolvimento.

O pacote *sf* facilitou muito a forma de trabalhar com vetores no R, sendo que as principais vantagens desse pacote s√£o (Lovelace, Nowosad & Muenchow 2019):

-   r√°pida importa√ß√£o e exporta√ß√£o de dados
-   aprimorado desempenho de plotagem
-   objetos *sf* podem ser tratados como dataframes na maioria das opera√ß√µes
-   fun√ß√µes *sf* podem ser combinadas usando o operador `%>%` e funcionam no formato tidyverse
-   fun√ß√µes *sf* s√£o consistentes e intuitivas (quase sempre come√ßam com prefixo `st_`)

Os tipos de geometrias apresentadas s√£o representadas por diferentes classes: `POINT`, `LINESTRING` e `POLYGON` para apenas uma fei√ß√£o de cada tipo de geometria; `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON` para v√°rias fei√ß√µes de cada tipo de geometria e; `GEOMETRYCOLLECTION` para v√°rias fei√ß√µes e tipos de geometrias (Figura \@ref(fig:fig-vetor-sf-classes)).

```{r fig-vetor-sf-classes, fig.align='center', fig.cap="Tipos de classes suportadas pelo pacote *sf*. Fonte: Lovelace, Nowosad & Muenchow (2019).", out.width="100%", echo=FALSE}
include_graphics("img/sf-classes.png")
```

O pacote *sf* define um sistema de tr√™s classes hier√°rquicas (Tabela \@ref(tab:tab-vetor-sf-estruturas)):

-   Classe *sfg* - uma geometria √∫nica
-   Classe *sfc* - uma coluna de geometria, que √© um conjunto de geometrias *sfg* e informa√ß√µes Sistema de Refer√™ncia de Coordenadas (do ingl√™s *Coordinate Reference Systems- CRS*)
-   Classe *sf* - uma camada, que √© uma coluna de geometria *sfc* dentro de um dataframe com atributos n√£o espaciais

```{r sf-estruturas, echo=FALSE}
kable(tibble(Classes = c("`sfg`", "`sfc`", "*sf*"), 
             Hierarquia = c("Geometria", "Coluna de geometria", "Camada"),
             Informa√ß√£o = c("Tipo e coordenadas", "Conjundo de `sfg` + CRS", "`sfc` + atributos")), 
      caption = "Estruturas de dados espaciais no pacote sf. Fonte: [Dorman (2021)](https://michaeldorman.github.io/R-Spatial-Workshop-at-CBS-2021/main.html).")
```

Ao olharmos as informa√ß√µes de um objeto da classe *sf*, podemos notar diversas informa√ß√µes que descrevem o mesmo:

-   *resumo do vetor*: indica o n√∫mero de fei√ß√µes (linhas) e campos (colunas)
-   *tipo da geometria*: umas das sete classes listadas anteriormente (Figura \@ref(fig:fig-vetor-sf-classes))
-   *dimens√£o*: n√∫mero de dimens√µes, geralmente duas (XY)
-   *bbox (bordas)*: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   *informa√ß√£o do CRS*: `epsg` ou `proj4string` indicando o CRS
-   *tibble*: tabela de atributos, com destaque para a coluna `geom` ou `geometry` que representa cada fei√ß√£o ou geometria

```{r}
data(world)
world
```

Podemos fazer um mapa simples utilizando a fun√ß√£o `plot()` desse objeto. Para facilitar, escolheremos apenas a primeira coluna `[1]` (Figura \@ref(fig:fig-vetor-mundo)).

> IMPORTANTE: faremos mapas mais elaborados na se√ß√£o xx desse cap√≠tulo.

```{r fig-vetor-mundo, fig.align='center', out.width="100%", fig.cap="Mapa vetorial do mundo."}
plot(world[1], col = viridis::viridis(100), main = "Mapa do mundo")
```

## Raster

Os dados no formato **raster** consistem em uma **matriz** (com linhas e colunas) representando **c√©lulas igualmente espa√ßadas** (pixels; Figura \@ref(fig:fig-raster)). Esse formato de dado torna a √°lgebra e o processamento de mapas muito mais eficiente e r√°pido do que o processamento de dados vetoriais. As c√©lulas dos dados raster possuem **duas informa√ß√µes**: 1. identifica√ß√£o das c√©lulas (IDs das c√©lulas) para especificar sua posi√ß√£o na matriz (Figura \@ref(fig:fig-raster) A) e; 2. valores das c√©lulas (Figura \@ref(fig:fig-raster) B), que geralmente s√£o coloridos para facilitar a interpreta√ß√£o da varia√ß√£o dos valores no espa√ßo (Figura \@ref(fig:fig-raster) C). Al√©m disso, valores ausentes ou n√£o amostrados s√£o representados por `NA`, ou seja, *not available* (Figura \@ref(fig:fig-raster) B e C).

```{r fig-raster, echo=FALSE, fig.align='center', fig.cap="Raster: (A) IDs das c√©lulas, (B) valores das c√©lulas, (C) c√©lulas coloridas. Adaptado de: Lovelace, Nowosad & Muenchow (2019)."}
library(gridExtra)

# daods
set.seed(42)
small_ras <- raster(matrix(1:16, 4, 4, byrow = TRUE))
small_ras_val <- raster(matrix(sample.int(100, 16), 4, 4, byrow = TRUE))
small_ras_val[c(10, 15)] <- NA
polys <- rasterToPolygons(small_ras, na.rm = FALSE)

# ids das celulas
p_1 <- spplot(small_ras, colorkey = FALSE, col.regions = "white",
              main = "A. IDs das c√©lulas",
              sp.layout = list(
                list("sp.polygons", polys, first = FALSE),
                list("sp.text", xyFromCell(small_ras_val, 1:ncell(small_ras)),
                     1:ncell(small_ras))
              )
)

# valor das celulas
p_2 <- spplot(small_ras_val, colorkey = FALSE, col.regions = "white",
              main = "B. Valores das c√©luas",
              sp.layout = list(
                list("sp.polygons", polys, first = FALSE),
                list("sp.text", xyFromCell(small_ras_val,
                                           1:ncell(small_ras_val)),
                     values(small_ras_val))
              )
)

# mapa colorido
p_3 <- spplot(small_ras_val, 
              col.regions = viridis::viridis(16),
              colorkey = FALSE,
              main = "C. Valores coloridos")

grid.arrange(p_1, p_2, p_3, ncol = 3)
```

### Tipos de raster

A **c√©lula ou pixel** de um raster pode conter apenas um **√∫nico valor**, que pode ser **cont√≠nuo** ou **categ√≥rico** (Figura \@ref(fig:fig-raster-cont-cat)). O formato raster geralmente representa **fen√¥menos cont√≠nuos**, como eleva√ß√£o, precipita√ß√£o, temperatura, ou dados espectrais de imagens de sat√©lite, mas tamb√©m pode representar **categorias** como tipos de florestas ou cobertura da terra (Figura \@ref(fig:fig-raster-cont-cat)).

```{r fig-raster-cont-cat, echo=FALSE, fig.align='center', fig.cap="Raster: (A) mapa cont√≠nuo, (B) mapa categ√≥rico. Adaptado de: Lovelace, Nowosad & Muenchow (2019)."}
# dados
set.seed(42)
small_ras_con <- raster(matrix(sample(1:100, 16) + sample(seq(.1, .9, .1), 16, rep = TRUE), 4, 4, byrow = TRUE))
small_ras_cat <- raster(matrix(sample(1:4, 16, rep = TRUE), 4, 4, byrow = TRUE))
polys_con <- rasterToPolygons(small_ras_con, na.rm = FALSE)
polys_cat <- rasterToPolygons(small_ras_cat, na.rm = FALSE)

# mapa continuo
p_1 <- spplot(small_ras_con, 
              col.regions = viridis::viridis(16),
              colorkey = FALSE,
              main = "A. Mapa cont√≠nuo",
              sp.layout = list(
                list("sp.polygons", polys_con, first = FALSE),
                list("sp.text", xyFromCell(small_ras_con,
                                           1:ncell(small_ras_con)),
                     values(small_ras_con))))

# mapa categorico
p_2 <- spplot(small_ras_cat, 
              col.regions = RColorBrewer::brewer.pal(name = "Dark2", n = 4),
              colorkey = FALSE,
              main = "B. Mapa categ√≥rico",
              sp.layout = list(
                list("sp.polygons", polys_cat, first = FALSE),
                list("sp.text", xyFromCell(small_ras_cat,
                                           1:ncell(small_ras_cat)),
                     values(small_ras_cat))))

grid.arrange(p_1, p_2, ncol = 2)
```

### *raster*: principal pacote no R para dados raster

Atualmente, o principal pacote para trabalhar com dados raster √© o [*raster*](https://rspatial.org/raster/index.html) (Hijmans 2020), apesar de existir outros dois em desenvolvimento e j√° sendo aplicados, como o [*terra*](https://rspatial.org/terra/index.html) e o [*stars*](https://r-spatial.github.io/stars/). O pacote *raster* fornece uma ampla gama de fun√ß√µes para criar, importar, exportar, manipular e processar dados raster no R. O objeto raster pode assumir tr√™s classes no R: `RasterLayer`, `RasterStack` e `RasterBrick`.

A classe `RasterLayer` representa apenas uma camada raster. Para criar um raster no R podemos utilizar a fun√ß√£o `raster::raster()`. Observando essa classe, podemos notar as seguintes informa√ß√µes:

-   *class*: classe raster do objeto raster
-   *dimensions*: n√∫mero de linhas, colunas e c√©lulas
-   *resolution*: largura e altura da c√©lula
-   *extent*: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   *crs*: Sistema de Refer√™ncia de Coordenadas (*CRS*)
-   *source*: fonte dos dados (mem√≥ria ou disco)
-   *names*: nome das camadas
-   *values*: valores m√°ximos e m√≠nimos das c√©lulas

```{r}
raster_layer <- raster::raster(nrows = 5, ncols = 5, 
                               res = .5,
                               xmn = -61.5, xmx = -59, ymn = -14.5, ymx = -12,
                               vals = sample(1:25, 25, rep = TRUE))
raster_layer
```

Um mapa simples do objeto raster pode ser obtido utilizando a fun√ß√£o `plot()`, do pr√≥prio pacote *raster* (Figura \@ref(fig:fig-raster-layer)).

```{r fig-raster-layer, fig.align='center', fig.cap="Mapa simples de um `RasterLayer`."}
plot(raster_layer, col = viridis::viridis(n = 25))
```

Al√©m da classe `RasterLayer`, h√° mais duas classes que trabalham com m√∫ltiplas camadas: `RasterBrick` e `RasterStack`. Elas diferem em rela√ß√£o ao n√∫mero de formatos de arquivo suportados, tipo de representa√ß√£o interna e velocidade de processamento.

A classe `RasterBrick` geralmente corresponde a importa√ß√£o de um √∫nico arquivo de imagem de sat√©lite multiespectral (multicamadas) ou a um √∫nico objeto com v√°rias camadas na mem√≥ria. A fun√ß√£o `raster::brick()` cria um objeto `RasterBrick`.

```{r}
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

raster_brick <- raster::brick(raster_layer1, raster_layer2, raster_layer3, raster_layer4)
raster_brick
```

Ao utilizarmos a fun√ß√£o `plot()` do pacote *raster*, podemos visualizar todos os raster contidos no objeto `RasterBrick` (Figura \@ref(fig:fig-raster-brick)).

```{r fig-raster-brick, fig.align='center', fig.cap="Mapas simples de um raster RasterBrick."}
plot(raster_brick, col = viridis::viridis(n = 25))
```

J√° a classe `RasterStack` permite conectar v√°rios objetos raster armazenados em arquivos diferentes ou v√°rios objetos na mem√≥ria. Um `RasterStack` √© uma lista de objetos `RasterLayer` com a mesma extens√£o, resolu√ß√£o e CRS. Uma maneira de cri√°-lo √© com a jun√ß√£o de v√°rios objetos espaciais j√° existentes no ambiente do R ou listar v√°rios arquivos raster em um diret√≥rio armazenado no disco. A fun√ß√£o `raster::stack()` cria um objeto `RasterStack`.

Outra diferen√ßa √© que o tempo de processamento para objetos `RasterBrick` geralmente √© menor do que para objetos `RasterStack`. A decis√£o sobre qual classe `Raster` deve ser usada depende principalmente do car√°ter dos dados de entrada.

```{r}
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

raster_stack <- raster::stack(raster_layer1, raster_layer2, raster_layer3, raster_layer4)
raster_stack
```

Da mesma forma, ao utilizar a fun√ß√£o `plot()` do pacote *raster*, podemos visualizar todos os raster contidos no objeto `RasterStack` (Figura \@ref(fig:fig-raster-stack)).

```{r fig-raster-stack, fig.align='center', fig.cap="Mapas simples de um raster RasterStack."}
plot(raster_stack, col = viridis::viridis(n = 25))
```

## Sistema de Refer√™ncia de Coordenadas e Unidades

Os dados geogr√°ficos (vetor e raster) possuem ainda um outro componente fundamental, que √© o **Sistema de Refer√™ncia de Coordenadas**, ou do ingl√™s *Coordinate Reference System (CRS)*. Esse componente define como os elementos espaciais (vetor e raster) representam uma fei√ß√£o na superf√≠cie da Terra. Esse componente √© composto por dois principais conceitos: primeiro, que tipo de unidades est√£o sendo utilizadas para a representa√ß√£o geogr√°fica, podendo assumir dois tipos - **√¢ngulos ou metros**, que definem o **Sistema de Coordenadas Geogr√°ficas** e o **Sistema de Coordenadas Projetadas**, respectivamente. O segundo componente √© o **datum**, que √© a rela√ß√£o do sistema de coordenadas com a superf√≠cie da Terra. Esse √∫ltimo componente faz parte de uma √°rea da **Cartografia** denominada **Geod√©sia** que estuda a forma e dimens√µes da Terra, campo gravitacional, e a localiza√ß√£o de pontos fixos e sistemas de coordenadas. O livro de Lapaine et al. (2017) √© um excelente material para se aprofundar nesse assunto.

### Sistema de Refer√™ncia de Coordenadas Geogr√°ficas

O **Sistema de Refer√™ncia de Coordenadas Geogr√°ficas** utiliza √¢ngulos para representar fei√ß√µes na superf√≠cie da Terra atrav√©s de dois valores: longitude e latitude. A longitude localiza-se na dire√ß√£o Leste-Oeste e a latitude localiza-se na dire√ß√£o Norte-Sul. Nesse sistema, a superf√≠cie da Terra geralmente √© representada por uma superf√≠cie elipsoidal, pois a Terra √© ligeiramente achatada nos polos.

### Sistema de Refer√™ncia de Coordenadas Projetadas

O **Sistema de Refer√™ncia de Coordenadas Projetadas** utiliza um Sistema Cartesiano de Coordenadas em uma superf√≠cie plana. Dessa forma, √† partir de uma origem, tra√ßam-se eixos x e y, e uma unidade linear como o **metro** √© utilizada. Todos as proje√ß√µes feitas de sistemas geogr√°ficos convertem uma superf√≠cie tridimensional em uma superf√≠cie plana bidimensional. Sendo assim, essa convers√£o tr√°s consigo algum tipo de distor√ß√£o em rela√ß√£o √† por√ß√£o real, como √°rea, dire√ß√£o, dist√¢ncia ou formato, de modo que um sistema de coordenadas projetadas pode preservar somente uma ou duas dessas propriedades.

Existem tr√™s grandes grupos de proje√ß√µes: cil√≠ndricos, c√¥nicos e planares. Na **proje√ß√£o cil√≠ndrica**, a superf√≠cie da Terra √© mapeada em um **cilindro**, sendo tamb√©m criada tocando a superf√≠cie da Terra ao longo de uma ou duas linhas de tang√™ncia, sendo utilizada com mais frequ√™ncia para mapear todo o globo, tendo como exemplo mais conhecido a **Proje√ß√£o Universal Transversa de Mercator (UTM)**. Na **proje√ß√£o c√¥nica**, a superf√≠cie da Terra √© projetada em um **cone** ao longo de uma linha ou duas linhas de tang√™ncia, de modo que as distor√ß√µes s√£o minimizadas ao longo das linhas e aumentam com a dist√¢ncia das mesmas, sendo portanto, mais adequada para mapear √°reas de latitudes m√©dias, tendo como exemplo mais conhecido a **Proje√ß√£o C√¥nica Equivalente de Albers** e a **Proje√ß√£o C√¥nica Conforme de Lambert**. E na **proje√ß√£o plana**, tamb√©m denominada **Proje√ß√£o azimutal**, o mapeamento toca o globo em um ponto ou ao longo de uma linha de tang√™ncia, sendo normalmente usado no mapeamento de regi√µes polares, sendo a mais comum a **Proje√ß√£o Azimutal Equidistante**, a mesma utilizada na bandeira da ONU.

### Datum

Como dito anteriormente, o **datum** √© a rela√ß√£o do sistema de coordenadas com a superf√≠cie da Terra. Ele representa o ponto de intersec√ß√£o do elipsoide de refer√™ncia com a supercie da Terra e o geoide (forma verdadeira da Terra), compensando as diferen√ßas do campo gravitacional da Terra. Existem dois tipos de datum - local e geoc√™ntrico. Em um **datum local**, como o **SAD69 - South American Datum 1969**, o elipsoide de refer√™ncia √© deslocado para se alinhar com a superf√≠cie em um determinado local na Am√©rica do Sul. J√° em um **datum geoc√™ntrico**, como **WGS84 - World Geodetic System 1984**, o centro do elipsoide √© o centro de gravidade da Terra e a precis√£o das proje√ß√µes n√£o √© otimizada para um local espec√≠fico do globo.

No Brasil, desde 2015, o [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)](https://www.ibge.gov.br/) adotou utilizar o datum **SIRGAS2000 - Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000** para todos os mapeamentos realizados no Brasil, um esfor√ßo conjunto para adotar o mesmo datum em toda a Am√©rica. Mais sobre esse datum pode ser lido aqui: [SIRGAS2000](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/).

### Sistema de Refer√™ncia de Coordenadas (CRS) no R

No R, h√° duas formas principais de representar um **Sistema de Refer√™ncia de Coordenadas**: 1. c√≥digo `epsg` e 2. `proj4string`. O c√≥digo EPSG (*European Petroleum Survey Group*) √© uma sequ√™ncia de n√∫meros curta, referindo-se apenas a um CRS. O site [epsg.io](http://epsg.io/) permite consultar diversas informa√ß√µes sobre um c√≥digo, como procurar por um c√≥digo, representa√ß√£o de mapas e fazer transforma√ß√µes de CRS.

J√° `proj4string` permite mais flexibilidade para especificar diferentes par√¢metros, como o tipo de proje√ß√£o, datum e elips√≥ide. Dessa forma, √© poss√≠vel especificar muitas proje√ß√µes, ou mesmo modificar as proje√ß√µes existentes, tornando a representa√ß√£o `proj4string` mais complexa e flex√≠vel.

Al√©m disso, ainda √© poss√≠vel consultar uma extensa lista de CRSs no site [spatialreference.org](https://spatialreference.org/), que fornece descri√ß√µes em diversis formatos, baseados em GDAL e Proj.4. Essa abordagem permite consultar uma URL que pode produzir uma refer√™ncia espacial em um formato que seu software SIG ou o R pode utilizar como refer√™ncia.

Os pacotes espaciais no R suportam uma ampla variedade de CRSs e usam a biblioteca [PROJ](https://proj.org/index.html#). A fun√ß√£o `rgdal::make_EPSG()` retorna um data frame das proje√ß√µes dispon√≠veis, com informa√ß√µes dos c√≥digos `epsg` e `proj4string` numa mesma tabela, facilitando a busca e uso de CRSs (\@ref(tab-crs)).

```{r eval=FALSE}
crs_data <- rgdal::make_EPSG()
head(crs_data)
```

```{r echo=FALSE}
kable(head(rgdal::make_EPSG()),
      caption = "Listagem inicial das proje√ß√µes dispon√≠veis no R, com informa√ß√µes dos c√≥digos `epsg` e `proj4string`")
```

## Principais fontes de dados geogr√°ficos

H√° muitas fontes de dados geogr√°ficos em diferentes bases de dados. Geralmente as bases de dados s√£o disponibilizados separadamente em apenas dados vetoriais e apenas dados raster. Para dados vetoriais, grande parte dos dados disponibilizados s√£o utilizados em mapas como limites pol√≠ticos, limites de biomas ou distribui√ß√£o de esp√©cies para **pol√≠gonos**; estradas e rios para **dados lineares**, ou ainda pontos de ocorr√™ncia de esp√©cies ou comunidades, ou medidas tomadas em campo sobre condi√ß√µes naturais como clima ou relevo, como **pontos**. Entretanto, √© sempre recomendado o uso de **bases oficiais**, principalmente em rela√ß√£o √† dados vetoriais de **limites pol√≠ticos**. Para tanto, √© sempre fundamental buscar as **bases oficiais de cada pa√≠s**, entrentanto, h√° bases que podem ser utilizadas globalmente, como veremos.

Sobre as bases de dados raster, h√° uma infinidade de dados para diferentes objetivos, mas grande parte deles s√£o relativos √† condi√ß√µes ambientais, representando uma vari√°vel de interesse de forma cont√≠nua no espa√ßo, como temperatura, precipita√ß√£o, eleva√ß√£o, etc.

Existe uma compila√ß√£o de dados geogr√°ficos vetoriais e raster compilada por Marcus Vin√≠cius Alves de Carvalho e Angelica Carvalho Di Maio, chamada [GeoLISTA](http://www.clickgeo.com.br/wp-content/uploads/2018/05/GeoLISTA.pdf). Entretanto, como as bases de dados tendem √† ser muito din√¢micas, √© poss√≠vel que muitas bases tenham surgido e desaparecido desde a listagem realizada.

Al√©m das bases de dados, h√° pacotes espec√≠ficos no R que fazem o download dos dados vetoriais e matriciais, facilitando a aquisi√ß√£o e reprodutibilidade. Para conferir uma listagem completa de pacotes para diversas an√°lises espaciais, veja [CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html).

### Vetor

Dentre as bases vetoriais, destacamos as seguintes na Tabela \@ref(tab:tab-vetor-bases):

```{r tab-vetor-bases, echo=FALSE}
knitr::kable(tibble(
  `Bases de dados` = c("[IBGE](https://www.ibge.gov.br/geociencias/downloads-geociencias.html)",
                       "[FBDS](http://geo.fbds.org.br/)",
                       "[GeoBank](http://geosgb.cprm.gov.br/)",
                       "[Pastagem.org](http://maps.lapig.iesa.ufg.br)",
                       "[CanaSat](http://www.dsr.inpe.br/laf/canasat/)",
                       "[CSR Maps](http://maps.csr.ufmg.br)",
                       "[Ecoregions](https://ecoregions2017.appspot.com/)",
                       "[UN Biodiversity Lab](https://www.unbiodiversitylab.org/)",
                       "[Biodiversity Hotspots](https://zenodo.org/record/3261807#.YA8lpPv0nOY)",
                       "[IUCN Red List of Threatened Species](https://www.iucnredlist.org/resources/spatial-data-download)",
                       "[Map of Life (MOL)](https://mol.org/)",
                       "[Key Biodiversity Areas](http://www.keybiodiversityareas.org/kba-data/request)",
                       "[HydroSHEDS](https://www.hydrosheds.org/)",
                       "[Global Roads Inventory Project (GRIP)](https://www.globio.info/download-grip-dataset)",
                       "[Database of Global Administrative Areas (GADM)](https://gadm.org/)",
                       "[Natural Earth](https://www.naturaleatoriorthdata.com/)",
                       "[Protected Planet](https://www.protectedplanet.net)", 
                       "[Global Biological Information Facility (GBIF)](http://www.gbif.org)",
                       "[Species Link](http://www.splink.cria.org.br)",
                       "[Global Invasive Species Information Network (GISIN)](http://www.gisin.org)"),
  Descri√ß√£o = c("Limites territoriais e censit√°rios do Brasil", 
                "Uso da terra, APP e hidrografia - Mata Atl√¢ntica e Cerrado", 
                "Dados geol√≥gicos do Brasil",
                "Dados de pastagens e gado para o Brasil",
                "Dados de cana-de-a√ß√∫car para o Brasil",
                "Diversos dados vetoriais e raster para o Brasil",
                "Dados de biorregi√µes e biomas do mundo",
                "Diversas bases de dados para o mundo",
                "Dados dos limites dos Hotspots de Biodiversidade",
                "Dados dos limites das distribui√ß√µes das esp√©cies para o mundo",
                "Dados da distribui√ß√£o de esp√©cies e outros dados para o mundo",
                "Dados dos limites das Key Biodiversity Areas",
                "Informa√ß√µes hidrol√≥gicas do mundo",
                "Dados de estradas do mundo todo",
                "Limites de √°reas administrativas do mundo",
                "Diversos limites para o mundo",
                "Limites de √°reas protegidas para o mundo",
                "Dados de ocorr√™ncias de esp√©cies para o mundo",
                "Dados de ocorr√™ncias de esp√©cies para o Brasil",
                "Dados de ocorr√™ncias de esp√©cies invasoras para o Mundo")
), 
caption = "Principais bases de dados vetoriais para o Brasil e o Mundo.",
booktabs = TRUE)
```

### Raster

Dentre as bases raster, destacamos as seguintes na Tabela \@ref(tab:tab-raster-bases):

```{r tab-raster-bases, echo=FALSE}
knitr::kable(tibble(
  `Bases de dados` = c("[MapBiomas](https://mapbiomas.org/)",
                       "[Bahlu](ftp://madeira.dea.ufv.br/bdados/bhalu/)",
                       "[USGS](https://www.usgs.gov/)",
                       "[SRTM](http://srtm.csi.cgiar.org/)",
                       "[Geoservice Maps](https://geoservice.dlr.de/web/maps)",
                       "[Global Forest Watch](https://www.globalforestwatch.org/)",
                       "[GlobCover](http://due.esrin.esa.int/page_globcover.php)",
                       "[Landcover](https://www.earthenv.org/landcover)",
                       "[Global Human Footprint](https://wcshumanfootprint.org/)",
                       "[GHSL - Global Human Settlement Layer](https://ghsl.jrc.ec.europa.eu/download.php)",
                       "[Land-Use Harmonization (LUH2)](https://luh.umd.edu/)",
                       "[ESA Climate Change Initiative](https://climate.esa.int/en/odp/#/dashboard)",
                       "[WorldClim](https://www.worldclim.org/)",
                       "[CHELSA](https://chelsa-climate.org/)",
                       "[EarthEnv](https://www.earthenv.org/)",
                       "[SoilGrids](https://soilgrids.org/)",
                       "[Global Wetlands](https://www2.cifor.org/global-wetlands/)",
                       "[Global Surface Water Explorer](https://global-surface-water.appspot.com/#)",
                       "[MARSPEC](http://www.marspec.org/)",
                       "[Bio-ORACLE](http://www.oracle.ugent.be/)"), 
  Descri√ß√£o = c("Uso e cobertura da terra para o Brasil, Panamazonia Legal e Chaco, de 1985 a 2019", 
                "Distribui√ß√µes hist√≥ricas de terras agr√≠colas e pastagens para todo o Brasil de 1940 a 2012", 
                "Dados de diversos sat√©lites livres para o mundo",
                "Dados de eleva√ß√£o para o mundo",
                "Dados de eleva√ß√£o e florestas para o mundo",
                "Dados de florestas para o mundo",
                "Dados de uso e cobertura da terra para todo o planeta",
                "Dados de uso e cobertura da terra para todo o planeta",
                "Dados de pegada ecol√≥gica para o mundo",
                "Dados e ferramentas abertos e gratuitos para avaliar a presen√ßa humana no planeta",
                "Dados atuais e previs√µes de uso da terra",
                "Arquivos globais de observa√ß√£o da Terra nos √∫ltimos 30 anos da Ag√™ncia Espacial Europeia (ESA)",
                "Dados clim√°ticos para o mundo",
                "Dados clim√°ticos para o mundo",
                "Dados de cobertura da terra, nuvens, relevo e hidrografia",
                "Dados de solo para o mundo",
                "Dados de √°reas √∫midas para o mundo",
                "Dados de √°guas superficiais para o mundo",
                "Dados de condi√ß√µes do oceano para o mundo",
                "Dados de condi√ß√µes do oceano para o mundo")), 
  caption = "Principais bases de dados raster para o Brasil e o Mundo.",
  booktabs = TRUE
)
```

### Pacotes do R

Dentre os pacotes, destacamos os seguintes na Tabela \@ref(tab:tab-packages-bases):

```{r tab-packages-bases, echo=FALSE}
knitr::kable(tibble(
  Pacotes = c("[geobr](https://cran.r-project.org/web/packages/geobr/index.html)",
              "[rnaturalearth](https://cran.r-project.org/web/packages/rnaturalearth/index.html)",
              "[rworldmap](https://cran.r-project.org/web/packages/rworldmap/index.html)",
              "[spData](https://cran.r-project.org/web/packages/spData/index.html)",
              "[OpenStreetMap](https://cran.r-project.org/web/packages/OpenStreetMap/index.html)",
              "[osmdata](https://cran.r-project.org/web/packages/osmdata/index.html)",
              "[geonames](https://cran.r-project.org/web/packages/geonames/index.html)",
              "[rgbif](https://cran.r-project.org/web/packages/rgbif/index.html)",
              "[maptools](https://cran.r-project.org/web/packages/maptools/index.html)",
              "[marmap](https://cran.r-project.org/web/packages/marmap/index.html)",
              "[oce](https://cran.r-project.org/web/packages/oce/index.html)",
              "[envirem](https://cran.r-project.org/web/packages/envirem/index.html)",
              "[sdmpredictors](https://cran.r-project.org/web/packages/sdmpredictors/index.html)",
              "[metScanR](https://cran.r-project.org/web/packages/metScanR/index.html)",
              "[ClimDown](https://cran.r-project.org/web/packages/ClimDown/index.html)",
              "[rWBclimate](https://cran.r-project.org/web/packages/rWBclimate/index.html)",
              "[rnoaa](https://cran.r-project.org/web/packages/rnoaa/index.html)",
              "[RNCEP](https://cran.r-project.org/web/packages/RNCEP/index.html)",
              "[smapr](https://cran.r-project.org/web/packages/smapr/index.html)"), 
  Descri√ß√£o = c("Carrega Shapefiles de Conjuntos de Dados Espaciais Oficiais do Brasil", 
                "Dados do mapa mundial da Natural Earth", 
                "Mapeando Dados Globais",
                "Conjuntos de dados para an√°lise espacial",
                "Acesso para abrir imagens raster de mapas de ruas",
                "Baixe e importe dados do OpenStreetMap",
                "Interface para o servi√ßo da Web de consulta espacial 'Geonames'",
                "Interface para o Global 'Biodiversity' Information Facility API",
                "Ferramentas para lidar com objetos espaciais",
                "Importar, tra√ßar e analisar dados batim√©tricos e topogr√°ficos",
                "Fonte e processamento de dados oceanogr√°ficos",
                "Gera√ß√£o de Vari√°veis ENVIREM",
                "Conjuntos de dados preditor de modelagem de distribui√ß√£o de esp√©cies",
                "Encontre, Mapeie e Colete Dados e Metadados Ambientais",
                "Biblioteca de redu√ß√£o de escala do clima para a produ√ß√£o di√°ria do modelo clim√°tico",
                "Acessa dados clim√°ticos do Banco Mundial",
                "Dados meteorol√≥gicos 'NOAA' de R",
                "Obtenha, organize e visualize dados meteorol√≥gicos NCEP",
                "Aquisi√ß√£o e processamento de dados ativos-passivos (SMAP) de umidade do solo da NASA")
), 
caption = "Principais pacotes para download de dados vetoriais e raster.",
booktabs = TRUE)
```

## Importar e exportar dados geogr√°ficos

Agora que sabemos o que s√£o dados geogr√°ficos e em quais bases de dados podemos buscar e baixar esses dados, veremos quais os principais formatos e como import√°-los e export√°-los do R.

### Principais formatos de arquivos geogr√°ficos

H√° diversos formatos de arquivos geogr√°ficos, alguns espec√≠ficos para dados vetoriais e raster, e outros no formato de banco de dados geoespaciais, como [PostGIS](https://postgis.net/), que podem armazenar ambos.

Entretanto, todos os formatos para serem importados para o R usaram do [GDAL (*Geospatial Data Abstraction Library*)](https://gdal.org/), uma interface unificada para leitura e grava√ß√£o de diversos arquivos geogr√°ficos, sendo utilizado tamb√©m por uma s√©ria de softwares de GIS como QGIS, GRASS GIS e ArcGIS.

Dentre esses formatos, destacamos na Tabela \@ref(tab:tab-formatos):
```{r tab-formatos, echo=FALSE}
knitr::kable(tibble(
  Nome = c("ESRI Shapefile", "GeoJSON", "KML", "GPX", "GeoTIFF", "Arc ASCII", "NetCDF", "BIL", "R-raster", "SQLite/SpatiaLite", "ESRI FileGDB", "GeoPackage"), 
  Exten√ß√£o = c(".shp (arquivo principal)", ".geojson", ".kml", ".gpx", ".tif/.tiff", ".asc", ".nc", ".bil/.hdr", ".gri/ .grd", ".sqlite", ".gdb", ".gpkg"),
  Descri√ß√£o = c("Formato popular que consiste em pelo menos quatro arquivos: .shp (fei√ß√£o), .dbf (tabela de atributos), .shx (liga√ß√£o entre .shp e .dbf) e .prj (proje√ß√£o)", "Estende o formato de troca JSON incluindo um subconjunto da representa√ß√£o de recurso simples", "Formato baseado em XML para visualiza√ß√£o espacial, desenvolvido para uso com o Google Earth. O arquivo KML compactado forma o formato KMZ", "Esquema XML criado para troca de dados de GPS", "Formato raster popular. Um arquivo TIFF contendo metadados espaciais adicionais.", "Formato de texto em que as primeiras seis linhas representam o cabe√ßalho raster, seguido pelos valores das c√©lulas raster organizadas em linhas e colunas", "NetCDF (Network Common Data Form) √© um conjunto de bibliotecas de software e formatos de dados independentes para cria√ß√£o", "BIL (Banda intercalada por linha) s√£o m√©todos comuns de organiza√ß√£o para imagens multibanda, geralmente acompanhados por um arquivo .hdr, descrevendo atributos espec√≠ficos da imagem", "Formato raster nativo do raster do pacote R", "Banco de dados relacional aut√¥nomo", "Objetos espaciais e n√£o espaciais criados pelo ArcGIS. Permite: v√°rias classes de recursos; topologia", "Cont√™iner de banco de dados leve baseado em SQLite permitindo uma troca f√°cil e independente de plataforma de geodados"),
  Tipo = c("Vetor", "Vetor", "Vetor", "Vetor", "Raster", "Raster", "Raster", "Raster", "Raster", "Vetor e raster", "Vetor e raster", "Vetor e raster"),
  Modelo = c("Parcialmente aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Propriet√°rio", "Aberto")), 
  caption = "Principais formatos de arquivos geogr√°ficos. Adaptado de: Lovelace, Nowosad & Muenchow (2019).",
  
)
```

O formato mais comum para arquivos vetoriais √© o [**ESRI Shapefile**](https://doc.arcgis.com/en/arcgis-online/reference/shapefiles.htm), e para arquivos raster √© o [**GeoTIFF**](https://gdal.org/drivers/raster/gtiff.html), e para dados clim√°ticos em m√∫ltiplas camadas, geralmente h√° a disponibiliza√ß√£o de dados no formato [**NetCDF**](https://www.unidata.ucar.edu/software/netcdf/). Entretanto, recentemente tivemos o surgimento do [**GeoPackage**](https://www.geopackage.org/), que possui diversas vantagens em rela√ß√£o aos formatos anteriores, podendo armazanar em apenas um arquivo, dados no formato vetorial, raster e tamb√©m dados n√£o-espaciais, al√©m de possuir uma grande integra√ß√£o com diversos softwares e bancos de dados.

### Importar dados

As principais fun√ß√µes para importar dados no R s√£o: 1) para vetores a fun√ß√£o `sf::st_read()`, e 2) para raster a fun√ß√£o `raster::raster()` e suas varia√ß√µes `raster::brick()` e `raster::stack()`. Essas fun√ß√µes atribuem objetos ao seu espa√ßo de trabalho, armazenando-os na mem√≥ria RAM dispon√≠vel em seu hardware, sendo essa a maior limita√ß√£o para trabalhar com dados geogr√°ficos no R. Por exemplo, se um arquivo raster possui mais de 8 Gb de tamamho, e seu computador possui extamente 8 Gb de RAM, √© muito prov√°vel que ele n√£o seja importado ou mesmo criado como um objeto dentro do ambiente R. Existem solu√ß√µes para esses problemas, mas n√£o as abordaremos nesse cap√≠tulo.

#### Vetor

Como vimos, os arquivos vetoriais s√£o disponibilizados em diversos formatos. Para sabermos se um determinado formato pode ser importado ou exportado utilizando o pacote *sf*, podemos utilizar a fun√ß√£o `sf::st_drivers()`. Uma amostra desses formatos √© apresentado na Tabela \@ref(tab:tab-vetor-formatos):

```{r eval=FALSE}
head(sf::st_drivers())
```

```{r tab-vetor-formatos, echo=FALSE}
da <- head(st_drivers())
rownames(da) <- NULL
kable(da,
      caption = "Alguns formatos vetoriais importados e exportados pelo pacote *sf*.")
```

##### Importar dados vetoriais existentes

Para importar vetores no R iremos utilizar a fun√ß√£o `sf::st_read()`. A estrutura √© semelhante para todos os formatos descritos na Tabela \@ref(tab:tab-vetor-formatos), de modo que sempre preencheremos o argumento **dsn** (*data source name*) com o nome do arquivo a ser importado. Entretanto, para banco de dados, como **GeoPackage**, pode ser necess√°rio especificar a camada que se tem interesse com um segundo argumento na fun√ß√£o `sf::st_read()`, chamado **layer**, com o nome da camada.

Para todas as opera√ß√µes nesse livro usaremos os dados dispon√≠veis para o munic√≠pio de Rio Claro/SP. Primeiramente, iremos baixar esses dados da [FBDS (Funda√ß√£o Brasileira para o Desenvolvimento Sustent√°vel)](https://www.fbds.org.br/), atrav√©s desse [reposit√≥rio de dados](http://geo.fbds.org.br/). Em 2015, a FBDS deu in√≠cio ao **Projeto de Mapeamento em Alta Resolu√ßƒÉo dos Biomas Brasileiros**, mapeando a cobertura da terra, hidrografia (nascentes, rios e lagos) e √°reas de preserva√ßƒÉo permanente (APPs). O mapeamento foi conclu√≠do para os munic√≠pios dos biomas Mata Atl√¢ntica e Cerrado. Para fazer o download dos arquivos de interesse, utilizaremos o R.

Primeiramente, iremos criar um diret√≥rio.

```{r eval=FALSE}
# criar um diretorio
dir.create(here::here("dados"))
dir.create(here::here("dados", "vetor"))
```

Em seguida, vamos fazer o download de pontos de nascentes, linhas de hidrografia e pol√≠gonos de cobertura da terra para o munic√≠pio de Rio Claro/SP.

```{r eval=FALSE}
# aumentar o tempo de download
options(timeout = 600)

# download
for(i in c(".dbf", ".prj", ".shp", ".shx")){
  
  # pontos de nascentes
  download.file(
    url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_NASCENTES", i),
    destfile = here::here("dados", "vetor", paste0("SP_3543907_NASCENTES", i)), mode = "wb")
  
  # linhas de hidrografia
  download.file(
    url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_RIOS_SIMPLES", i),
    destfile = here::here("dados", "vetor", paste0("SP_3543907_RIOS_SIMPLES", i)), mode = "wb")
  
  # poligonos de cobertura da terra
  download.file(
    url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/USO/SP_3543907_USO", i),
    destfile = here::here("dados", "vetor", paste0("SP_3543907_USO", i)), mode = "wb")
}
```

Agora podemos importar esses dados para o R. Primeiro vamos importar as nascentes (Figura \@ref(fig:fig-vetor-nascentes)).

```{r}
# importar pontos
rc_nas <- sf::st_read(here::here("dados", "vetor", "SP_3543907_NASCENTES.shp"), quiet = TRUE)
```

```{r fig-vetor-nascentes, fig.align='center', fig.cap="Mapa de nascentes de Rio Claro/SP."}
plot(rc_nas[1], pch = 20, col = "blue", main = NA, axes = TRUE, graticule = TRUE)
```

Agora vamos importar a hidrografia (Figura \@ref(fig:fig-vetor-hidrografia)).

```{r}
# importar hidrografia
rc_hid <- sf::st_read(here::here("dados", "vetor", "SP_3543907_RIOS_SIMPLES.shp"), quiet = TRUE)
```

```{r fig-vetor-hidrografia, fig.align='center', fig.cap="Mapa de hidrografia de Rio Claro/SP."}
plot(rc_hid[1], col = "steelblue", main = NA, axes = TRUE, graticule = TRUE)
```

E por fim, vamos importar a cobertura da terra (Figura \@ref(fig:fig-vetor-cobertura)).

```{r}
# importar cobertura
rc_cob <- sf::st_read(here::here("dados", "vetor", "SP_3543907_USO.shp"), quiet = TRUE)
```

```{r fig-vetor-cobertura, fig.align='center', fig.cap="Mapa de cobertura da terra de Rio Claro/SP."}
plot(rc_cob[5], col = c("blue", "orange", "gray30", "forestgreen", "green"), main = NA, axes = TRUE, graticule = TRUE)
```

##### Importar utilizando pacotes

Al√©m de bases de dados, podemos importar dados de pacotes, como listado anteriormente na Tabela \@ref(tab:tab-packages-bases). Para o Brasil, o pacote mais interessante trata-se do [`geobr`](https://ipeagit.github.io/geobr/), do [Instituto de Pesquisa Econ√¥mica Aplicada (IPEA)](https://www.ipea.gov.br/portal/), que possui dados oficiais do [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE))](https://www.ibge.gov.br/).

√â poss√≠vel listar todos os dados dispon√≠veis no pacote atrav√©s da fun√ß√£o `geobr::list_geobr()`. Na Tabale \@ref(tab:tab-vetor-dados-geobr) √© poss√≠vel ver alguns dados.

```{r eval=FALSE}
# listar todos os dados do geobr
geobr::list_geobr()
```

```{r tab-vetor-dados-geobr, echo=FALSE}
knitr::kable(head(geobr::list_geobr()),
             caption = "Alguns dados dispon√≠veis no pacote *geobr*.")
```

Como exemplo, vamos fazer o download o limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-rio-claro)).

```{r}
# rio claro
rc_2019 <- geobr::read_municipality(code_muni = 3543907, year = 2019, showProgress = FALSE)
```

```{r fig-vetor-rio-claro, fig.align='center', fig.cap="Mapa do limite do munic√≠pio de Rio Claro/SP."}
plot(rc_2019[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

J√° para o mundo, o pacote mais interessante trata-se do [`rnaturalearth`](https://docs.ropensci.org/rnaturalearth/), que faz o download de dados do [Natural Earth](https://www.naturaleatoriorthdata.com/). Vamos fazer o download do limite do Brasil (Figura \@ref(fig:fig-vetor-brasil)).

```{r}
# brasil
br <- rnaturalearth::ne_countries(scale = "large", country = "Brazil", returnclass = "sf")
```

```{r fig-vetor-brasil, fig.align='center', fig.cap="Mapa do limite do Brasil."}
plot(br[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

##### Criar um objeto espacial de uma tabela de coordenadas

√â muito comum em coletas de campo ou fontes de dados, disponibilizar **coordendas de locais de estudo** ou de **ocorr√™ncias de esp√©cies**. Essas tabelas devem possuir duas colunas, uma para longitude e outra para latitude. Ao import√°-las para o R, o formato que assumem pode ser de uma das classes: `matrix`, `dataframe` ou `tibble`, ou seja, ainda n√£o s√£o da classe *sf*. Nesta se√ß√£o iremos ver como fazer essa convers√£o.

Para tanto, vamos usar os dados de comunidades de anf√≠bios da Mata Atl√¢ntica (Atlantic Amphibians, Vancine et al. 2018). Iremos fazer o download diretamente do site da fonte dos dados. Antes vamos criar um diret√≥rio.

```{r eval=FALSE}
# criar um diretorio
dir.create(here::here("dados", "tabelas"))
```

Em seguida, vamos fazer o download de um arquivo `.zip` e fazer o `unzip` nesse mesmo diret√≥rio, utilizando fun√ß√µes nativas do R.

```{r eval=FALSE}
# download
download.file(url = "https://esajournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fecy.2392&file=ecy2392-sup-0001-DataS1.zip",
              destfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"), mode = "wb")

# unzip
unzip(zipfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"),
      exdir = here::here("dados", "tabelas"))
```

Agora iremos importar a tabela de dados para criar o objeto espacial.

```{r}
# importar tabela de locais
aa_lo <- readr::read_csv(here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"))
aa_lo
```

Por fim, podemos facilmente criar um objeto espacial do tipo `MULTIPOINT` utilizando a fun√ß√£o `sf::st_as_sf()`. Podemos ver essas coordenadas plotadas no mapa simples da Figura \@ref(fig:fig-vetor-pontos-atlantic-amphibians). √â necess√°rio antes se ater primeiramente ao argumento **coords** que deve indicar as colunas de longitude e latitude, nessa ordem; e tamb√©m ao argumento **crs** para indicar o CRS correspondente dessas coordendas, que aqui sabemos que as coordenadas s√£o geogr√°ficas e com Datum WGS84. Ent√£o podemos facilmente utilizar o c√≥digo EPSG 4326 para tanto. Entretanto, se as coordenadas estiverem em metros por exemplo, teremos de nos ater √† qual CRS as mesmas foram coletadas, ou seja, se s√£o coordenadas de GPS, √© preciso saber como o GPS estava configurado (Datum) e √† qual zona UTM as coordenadas pertencem para definir o c√≥digo EPSG correto.

```{r}
# convert para sf
aa_lo_ve <- aa_lo %>% 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
aa_lo_ve
```

```{r fig-vetor-pontos-atlantic-amphibians, fig.align='center', fig.cap="Mapa das coordenadas do Atlantic Amphinians."}
plot(aa_lo_ve[1], pch = 20, col = "black", main = NA, axes = TRUE, graticule = TRUE)
```

##### Converter dados espaciais *sp* para *sf*

O pacote *sf* √© mais recente e mais f√°cil de manipular objetos vetoriais no R, como vimos. Seu predecessor, o pacote *sp* possui uma classe pr√≥pria e hom√¥nima. Entretanto, muito pacotes de an√°lises espaciais ainda utilizam essa classe em suas fun√ß√µes, apesar dessa migra√ß√£o ter ocorrido recentemente. Dessa forma, a convers√£o entre essas classes pode ser necess√°ria em alguns momentos.

Abaixo, veremos como podemos fazer essa convers√£o facilmente. Primeiramente, vamos importar um dados *sp*.

```{r}
# paises sp
co110_sp <- rnaturalearth::countries110
class(co110_sp)
```

Agora, podemos converter facilmente com a fun√ß√£o `sf::st_as_sf()`.

```{r}
# paises sf
co110_sf <- sf::st_as_sf(co110_sp)
class(co110_sf)
```

Podemo facilmente converter esse objeto novamente para a classe *sp* com a fun√ß√£o `sf::as_Spatial`.

```{r}
# paises sp
co110_sp <- sf::as_Spatial(co110_sf)
class(co110_sp)
```

#### Raster

Para importar dados raster no R iremos utilizar a fun√ß√£o `raster::raster()`, `raster::brick()` ou `raster::stack()`. Para apenas uma camada raster, usaremos a fun√ß√£o `raster::raster()`, com o argumento **x** sendo o nome do arquivo. J√° para mais camadas, usaremos `raster::brick()` para um arquivo que possua m√∫ltiplas camadas, ou ainda a fun√ß√£o `raster::stack()` para v√°rias arquivos em diferentes camadas tamb√©m no argumento **x**, sendo necess√°rio listar os arquivos no diret√≥rio, geralmente utilizando a fun√ß√£o `dir()` ou `list.files()`. Entretanto, para especificar uma camada, podemos utiliar o argumento **band** ou **layer** e o nome dessa camada.

##### Raster Layer
Primeiramente, vamos criar um diret√≥rio como para os dados raster.

```{r eval=FALSE}
# criar directorio
dir.create(here::here("dados", "raster"))
```

Em seguida, vamos fazer o download de dados de eleva√ß√£o, localizados tamb√©m para o munic√≠pio de Rio Claro. Iremos utilizar os dados do [*Shuttle Radar Topography Mission - SRTM*](https://srtm.csi.cgiar.org/). Para saber mais sobre esses dados, recomandamos a leitura do artigo Farr et al. (2007).

```{r eval=FALSE}
# aumentar o tempo oara download
options(timeout = 600)

# download
download.file(url = "https://srtm.csi.cgiar.org/wp-content/uploads/files/srtm_5x5/TIFF/srtm_27_17.zip",
              destfile = here::here("dados", "raster", "srtm_27_17.zip"), mode = "wb")

# unzip
unzip(zipfile = here::here("dados", "raster", "srtm_27_17.zip"),
      exdir = here::here("dados", "raster"))
```

Agora podemos importar essa camada para o R, e visualiz√°-la em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-dem)).

```{r}
# importar raster
ra <- raster::raster(here::here("dados", "raster", "srtm_27_17.tif"))
ra
```

```{r fig-raster-dem, fig.align='center', fig.cap="Mapa do raster DEM em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP."}
plot(ra, col = viridis::viridis(10))
plot(rc_2019[1], col = NA, add = TRUE)
```

##### Raster Stack

Al√©m dos dados de eleva√ß√£o, dados de temperatura e precipita√ß√£o podem ser obtidos do [WorldClim](https://www.worldclim.org/). Para saber mais sobre esses dados, recomandamos a leitura do artigo Fick & Hijmans (2017).

```{r eval=FALSE}
# download
download.file(url = "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_10m_bio.zip",
              destfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"), mode = "wb")

# unzip
unzip(zipfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"),
      exdir = here::here("dados", "raster"))
```

Para importar essa s√©rie de camadas, primeiramente iremos listar os arquivos e depois importar no formato `RasterStack` ((Figura \@ref(fig:fig-raster-wc)).

```{r}
# listar arquivos
fi <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
  grep(".tif", ., value = TRUE)
fi

# importar
st <- raster::stack(here::here("dados", "raster", fi))
st
```

```{r fig-raster-wc, fig.align='center', fig.cap="Mapas dos rasters WorldClim para o mundo."}
plot(st[[1:2]], col = viridis::viridis(10))
```

### Exportar dados

Saber a melhor forma de exportar dados geogr√°ficos de objetos rec√©m-criados do R √© fundamental, principalmente porque essa a√ß√£o ir√° depender do tipo de dado (vetor ou raster), classe do objeto (por exemplo, multiponto ou RasterLayer) e tipo e quantidade de informa√ß√µes armazenadas (por exemplo, tamanho do objeto, intervalo de valores).

#### Vetor

Para dados vetoriais, a principal fun√ß√£o utilizada √© a `sf::st_write()`. Essa fun√ß√£o permite gravar objetos sf em v√°rios formatos de arquivos vetoriais, `.shp`, `.gpkg` ou `.geojson`. O formato a ser exportado vai influenciar na velocidade do processo de grava√ß√£o.

Os argumentos dessa fun√ß√£o ser√° o **obj** que √© o objeto sf criado no ambiente R, e o **dsn** ser√° o *data source name*, ou seja, o nome que o arquivo ter√° ao ser exportado do R, de modo que o complemento **.shp**, por exemplo, ir√° definir que o arquivo ter√° a extens√£o `ESRI Shapefile`. Entretanto, esse formato pode ser definido tamb√©m utilizando o argumento **driver**, com as possibilidades listadas nesse [site](https://gdal.org/drivers/vector/index.html).

```{r eval=FALSE}
# exportar o vetor de rio claro no formato esri shapefile
sf::st_write(obj = rc_2019, dsn = here::here("dados", "vetor", "rio_claro.shp"))
```

Ou podemos exportar no formato de `GeoPackage`. Entretando, aqui √© interessante acrescentar um argumento chamado **layer** para definir o nome das camadas a serem exportadas no mesmo arquivo `GeoPackage`.

```{r eval=FALSE}
# exportar o vetor de rio claro no formato geopackage
sf::st_write(obj = rc_2019, dsn = here::here("dados", "vetor", "vetores.gpkg"), layer = "rio_claro")
```

Sobre esse formato, h√° algo muito interessante que podemos fazer: podemos agrescentar outros arquivos vetoriais ao mesmo arquivo j√° criado. Como exemplo, iremos exportar o limite do Brasil para o mesmo arquivo.

```{r eval=FALSE}
# exportar o vetor do brasil no formato geopackage
sf::st_write(obj = br, dsn = here::here("dados", "vetor", "vetores.gpkg"), layer = "brasil")
```

#### Raster

Para exportar dados raster utilizamos geralmente a fun√ß√£o `raster::writeRaster()`. Exportar dados raster √© um pouco mais complexo que dados vetoriais. Teremos de definir se iremos exportar arquivos em **uma camada ou v√°rias**, **quantidade de informa√ß√µes por pixel**, e ainda **diferentes formatos de sa√≠da**. Um ponto fundamental: arquivos raster escritos em discos geralmente ocupam bastante espa√ßo, e dessa forma h√° par√¢metros espec√≠ficos para certos tipos de dados, que detalharemos a seguir.

Na fun√ß√£o `raster::writeRaster()`, o argumento **x** diz respeito ao objeto raster no ambiente R. O argumento **filename** √© nome do arquivo que ser√° exportado do R, podendo ou n√£o possuir a extens√£o que se pretende que o arquivo tenha. O argumento **format** √© o formato do arquivo, sendo as principais possibilidades resumidas na Tabela \@ref(tab:tab-raster-formatos), e para saber das possibilidade suportadas, use a fun√ß√£o `raster::writeFormats()`. O argumento **bylayer** diz se de um objeto com m√∫ltiplas camadas, cada uma delas ser√° exportada em um arquivo diferente.

```{r tab-raster-formatos, echo=FALSE}
knitr::kable(tibble(
  `Tipo de arquivo` = c("raster", "ascii", "SAGA", "IDRISI", "CDF", "GTiff", "ENVI", "EHdr", "HFA"), 
  `Nome longo` = c("Formato pacote raster", "ESRI Ascii", "SAGA GIS", "IDRISI", "netCDF (requer ncdf4)", "GeoTiff (requer rgdal)", "ENVI .hdr", "ESRI .hdr", "Erdas imagem (.img)"),
  Extens√£o = c(".grd", ".asc", ".sdat", ".rst", ".nc", ".tif", ".envi", ".bil", ".img"),
  `Suporte a m√∫ltiplas camadas` = c("Sim", "N√£o", "N√£o", "N√£o", "Sim", "Sim", "Sim", "Sim", "Sim")), 
  caption = "Principais formatos de arquivos raster exportados do R.",
  
)
```

Dentre os argumentos adicionais, temos ainda o *datatype*, que faz refer√™ncia √† um dos nove tipos de dados detalhados na Tabela \@ref(tab:tab-raster-tipos), sendo que o tipo de dado determina a representa√ß√£o de bits (quantidade de informa√ß√£o) do objeto raster exportado e depende da faixa de valores do objeto raster em cada pixel. Quanto mais valores um tipo de dado puder representar, maior ser√° o arquivo exportado no disco, dessa forma, √© interessante utilizar um tipo de dado que diminua o tamanho do arquivo √† ser exportado, dependendo do tipo de dados em cada pixel. Para a fun√ß√£o `raster::writeRaster()`, o default √© *FLT4S*, o que pode ocupar mais espa√ßo em disco do que o necess√°rio, dependendo do tipo de dados do objeto raster no R.

```{r tab-raster-tipos, echo=FALSE}
knitr::kable(tibble(
  `Tipo de dado` = c("LOG1S", "INT1S", "INT1U", "INT2S", "INT2U", "INT4S", "INT4U", "FLT4S", "FLT8S"), 
  `Valor m√≠nimo` = c("FALSE (0)",	"-127",	"0", "-32.767", "0", "-2.147.483.647", "0", "-3,4e+38", "-1,7e+308"),
  `Valor m√°ximo` = c("TRUE (1)",	"127",	"255", "32.767", "65534", "2.147.483.647", "42.94.967.296", "3,4e+38", "1,7e+308")), 
  caption = "Tipos de dados suportados pelo pacote raster.")
```

Outros argumentos de suporte s√£o: **overwrite** para sobreescrever um arquivo que j√° exista, *progress* para mostrar uma barra de progresso da exporta√ß√£o como "text" ou "window", e **options** que permite op√ß√µes do GDAL. Para esse √∫ltimo, quando exportar especificamente para o formato `GeoTIFF`, podemos utilizar `options = c("COMPRESS=NONE", "TFW=YES")` para que haja compress√£o do arquivo, diminuindo consideravelmente seu tamanho (cerca de um ter√ßo), aliado √† um arquivo auxiliar `.tfw` para ser carregado em softwares espec√≠ficos de SIG, como ArcGIS.

Para exportar apenas uma camada `RasterLayer`, podemos utilizar a fun√ß√£o `raster::writeRaster()` em um formato mais simples.

```{r eval=FALSE}
# diretorio
dir.create(here::here("dados", "raster", "exportados"))

# exportar raster layer
raster::writeRaster(ra, 
                    filename = here::here("dados", "raster", "exportados", "elevation"),
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=NONE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

Para mais de uma camada `RasterBrick` ou `RasterStack`, podemos utilizar a fun√ß√£o `raster::writeRaster()` com mais argumentos, como o `bylayer = TRUE`.

```{r eval=FALSE}
raster::writeRaster(x = st, 
                    filename = here::here("dados", "raster", "exportados", names(st)),
                    bylayer = TRUE, 
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=NONE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

## Descri√ß√£o de objetos espaciais

Muitas vezes iremos precisar **verificar as informa√ß√µes** dos objetos geogr√°ficos importados para o R. Apesar de chamar o objeto trazer grande parte das informa√ß√µes que precisamos, existem fun√ß√µes espec√≠ficas que nos auxiliam nesse processo de descri√ß√£o dos objetos.

### Vetor

Podemos acessar as **informa√ß√µes geogr√°ficas** e a **tabela de atributos** de um objeto importado como vetor simplesmente chamando o **nome do objeto** no R.

```{r}
# rio claro
rc_2019
```

Mas tamb√©m podemos acessar **informa√ß√µes geogr√°ficas** com fun√ß√µes espec√≠ficas, como tipo de geometria, limites geogr√°ficos do vetor (extens√£o), sistema de refer√™ncia de coordenadas (CRS), e a tabela de atributos.

```{r}
# tipo de geometria
sf::st_geometry_type(rc_2019)

# extensao
sf::st_bbox(rc_2019)

# crs
sf::st_crs(rc_2019)

# acessar a tabela de atributos
rc_2019_tab <- sf::st_drop_geometry(rc_2019)
rc_2019_tab
```

### Raster

Da mesma forma, podemos acessar as **informa√ß√µes dos dados raster** chamando o **nome do objeto**.

```{r}
ra
```

Al√©m disso, podemos selecionar informa√ß√µes desse objeto com fun√ß√µes espec√≠ficas, tanto para `RasterLayer` quanto para `RasterBrick` ou `RasterStack`, como classe, dimens√µes (n√∫mero de linhas, colunas e camadas), n√∫mero de camadas, n√∫mero de linhas, n√∫mero de colunas, n√∫mero de c√©lulas, resolu√ß√£o (largura e altura do tamanho do pixel), extens√£o (limites geogr√°ficos), sistema de refer√™ncia de coordenadas (CRS), nome das camadas e extrair os valores de todos os pixels.

```{r}
# classe
class(ra)

# dimensoes
dim(ra)

# numero de camadas
nlayers(ra)

# numero de linhas
nrow(ra)

# numero de colunas
ncol(ra)

# numero de celulas
ncell(ra)

# resolucao
res(ra)

# extensao
extent(ra)

# projecao ou crs
projection(ra)

# nome
names(ra)

# valores
getValues(ra) %>% head
values(ra) %>% head
ra[] %>% head
```

## Reproje√ß√£o de dados geogr√°ficos

Em algumas situa√ß√µes √© necess√°rio alterar o CRS de um objeto espacial para um novo CRS. A reproje√ß√£o √© justamente a transforma√ß√£o de coordenadas de um CRS para outro: **geogr√°ficos** ('lon/lat', com unidades em graus de longitude e latitude) e **projetados** (normalmente com unidades de metros a partir de um datum).

Geralmente iremos precisar fazer essa opera√ß√£o para transformar camadas para o **mesmo CRS**, de modo que possam ser exibidas conjuntamente, ou ainda que as camadas possuem **CRS projetado** para realizar alguma **opera√ß√£o espacial entre camadas** ou ainda quando precisamos **calcular √°reas, formatos ou dist√¢ncias**, como m√©tricas de paisagem, por exemplo. Existe uma infinidade de proje√ß√µes e um excelente material de consulta √© o livro de Lapaine et al. (2017).

Podemos verificar o CRS de uma camada atrav√©s da fun√ß√£o `sf::st_crs()` ou `raster::projection()` e `raster::crs()`, ou ainda saber se a mesma possui um CRS geogr√°fico ou n√£o, com a fun√ß√£o `sf::st_is_longlat()`. J√° para reprojetar um objeto *sf* usamos a fun√ß√£o `sf::st_transform()` e para um objeto raster usamos a fun√ß√£o `raster::projectRaster()`.

```{r}
# projecao de vetores
sf::st_crs(rc_2019)

# projecao de raster
raster::projection(ra)
raster::crs(ra)

# verificar se o crs e geografico
sf::st_is_longlat(rc_2019)
```

As fun√ß√µes `sf::st_transform()` e `raster::projectRaster()` possuem dois par√¢metros importantes: **x** que √© a camada a ser reprojetada e o **crs** que √© o CRS alvo. O argumento **crs** pode ser especificado de uma das quatro maneiras: 1) um c√≥digo EPSG (por exemplo, 4326), 2) um string PROJ4 (por exemplo, "+ proj = longlat + datum = WGS84 + no_defs"), 3) um string WKT, ou 4) um objeto crs de outra camada, conforme retornado por `sf::st_crs()` ou `raster::crs()`. Esas informa√ß√µes de EPSG, PROJ4 e WKT pode ser acessadas nas bases: [epsg.io](http://epsg.io/) e [spatialreference.org](https://spatialreference.org/).

Dentre os poss√≠veis CRSs a serem utilizados, alguns s√£o mais comuns para CRSs geogr√°ficos e projetados. Para **CRSs geogr√°ficos**, o mais comum para o mundo √© o **World Geodetic System 1984 (WGS84)**, ou seja, geogr√°fico com datum WGS84. Para o Brasil, o CRS adotado √© o [**Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)**](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/), ou seja, geogr√°fico com datum SIRGAS2000.

Para **CRSs projetados**, essa escolha vai depender da exten√ß√£o e localiza√ß√£o da √°rea de interesse no globo terrestre. Aqui destacaremos os principais, para tr√™s escalas: global, regional e local. Para a **escala global**, geralmente usa-se umas dessas proje√ß√µes, dependendo do objetivo: 1) Proje√ß√£o de Mollweide, 2) Proje√ß√£o de Winkel Tripel, 3) Proje√ß√£o de Eckert IV, 4) Proje√ß√£o Azimutal de Lambert. Para a **escala regional**, como um hemisf√©rio, geralmente usa-se a Proje√ß√£o C√¥nica de Albers. Por fim, para a **escala local**, usa-se geralmente a Proje√ß√£o Universal Transverse Mercator (UTM), um conjunto de CRSs que divide a Terra em 60 cunhas longitudinais e 20 segmentos latitudinais, como pode ser visto neste [link](http://www.dmap.co.uk/utmworld.htm).

Os principais CRSs s√£o descritos na Tabela \@ref(tab:tab-crs).

```{r tab-crs, echo=FALSE}
knitr::kable(tibble(
  CRS = c("World Geodetic System 1984 (WGS84)", 
          "Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)",
          "Proje√ß√£o de Mollweide", 
          "Proje√ß√£o de Winkel Tripel", 
          "Proje√ß√£o de Eckert IV", 
          "Proje√ß√£o Azimutal de Lambert",
          "Proje√ß√£o C√¥nica de Albers",
          "Proje√ß√£o Universal Transverse Mercator (UTM)"),
  `Tipo de CRS` = c("Geogr√°fico", 
                    "Geogr√°fico", 
                    "Projetado", 
                    "Projetado", 
                    "Projetado", 
                    "Projetado", 
                    "Projetado", 
                    "Projetado"),
  Descri√ß√£o = c("CRS geogr√°fico mais comum para o mundo", 
                "CRS geogr√°fico oficial para o Brasil", 
                "CRS projetado que  preserva as rela√ß√µes de √°rea", 
                "CRS projetado com m√≠nimo de distor√ß√£o para √°rea, dire√ß√£o e dist√¢ncia", 
                "CRS projetado que presenva a √°rea e com meridianos el√≠pticos", 
                "CRS projetado que preserva os tamanhos relativos e senso de dire√ß√£o a partir do centro", 
                "CRS projetado para escala regional, mantendo a √°rea constante em toda sua superf√≠cie", 
                "CRS projetado para escala local, distorcendo √°reas e dist√¢ncias com gravidade crescente com a dist√¢ncia do centro da zona UTM"),
  epsg.io = c("[EPSG:4326](http://epsg.io/4326)", 
              "[EPSG:4674](http://epsg.io/4674)",
              "[ESRI:54009](https://epsg.io/54009)", 
              NA, 
              "[EPSG:54012](https://epsg.io/54012)", 
              NA, 
              NA, 
              "[EPSG:31983](https://epsg.io/31983)"),
  spatialreference.org = c("[EPSG:4326](https://spatialreference.org/ref/epsg/4326/)",
                           "[EPSG:4674](https://spatialreference.org/ref/epsg/4674/)",
                           "[SR-ORG:7099](https://spatialreference.org/ref/sr-org/7099/)",
                           "[SR-ORG:7291](https://spatialreference.org/ref/sr-org/7291/)",
                           "[ESRI:54012](https://spatialreference.org/ref/esri/54012/)",
                           NA,
                           "[SR-ORG:7823](https://spatialreference.org/ref/sr-org/7823/)",
                           "[EPSG:31983](https://spatialreference.org/ref/epsg/31983/)")), 
  caption = "Principais CRSs utilizados.")
```

### Vetor

Como dissemos anteriormente, para reprojetar um vetor, utilizamos a fun√ß√£o `sf::st_transform()`, observando os argumentos **x** que √© a camada a ser reprojetada, e o **crs** que √© o CRS alvo.

Vamos reprojetar o limite do munic√≠pio de Rio Claro/SP do **CRS geogr√°fico SIRGAS2000** para o **CRS projetado SIRGAS2000/UTM23S**, com os efeitos da transforma√ß√£o podendo ser notados na Figura \@ref(fig:fig-vetor-crs-trans).

```{r}
# converter crs
rc_2019_sirgas2000_utm23s <- sf::st_transform(x = rc_2019, crs = 31983)
```

```{r fig-vetor-crs-trans, echo=FALSE, fig.align='center', fig.cap="Mapas dos limites do munic√≠pio de Rio Claro/SP com CRS geogr√°fico SIRGAS2000 e com CRS projetado SIRGAS2000/UTM23S."}
library(tidyverse)
p1 <- ggplot() +
  geom_sf(data = rc_2019) +
  coord_sf(datum = sf::st_crs(4674)) +
  labs(x = "Longitude", y = "Latitude", title = "SIRGAS2000/Geogr√°fico") + 
  theme_bw() +
  theme(axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
        panel.grid = element_line(size = .3, color = "black", linetype = 2))

p2 <- ggplot() +
  geom_sf(data = rc_2019) +
  coord_sf(datum = sf::st_crs(31983)) +
  labs(x = "X", y = "Y", title = "SIRGAS2000/UTM23S") + 
  theme_bw() +
  theme(axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
        panel.grid = element_line(size = .3, color = "black", linetype = 2))

gridExtra::grid.arrange(p1, p2, nrow = 1)
```

Podemos ainda utilizar o formato `proj4string` no argumento **crs** para fazer a transforma√ß√£o. Vamos primentamente plotar o mundo em WGS84/Geogr√°fico (Figura \@ref(fig:fig-vetor-mundo-wgs84)).

```{r fig-vetor-mundo-wgs84, fig.align='center', fig.cap="Mapa do mundo com CRS geogr√°fico e datum WGS8."}
plot(co110_sf[1], col = "gray",  main = "WGS84/Geogr√°fio", graticule = TRUE)
```

Agora, iremos reprojetar utilizando a Proje√ß√£o de Mollweide (Figura \@ref(fig:fig-vetor-mundo-moll)).

```{r}
# projecao de mollweide 
co110_sf_moll <- sf::st_transform(x = co110_sf, crs = "+proj=moll")
```

```{r fig-vetor-mundo-moll, fig.align='center', fig.cap="Mapa do mundo com CRS Proje√ß√£o de Mollweide."}
plot(co110_sf_moll[1], col = "gray", main = "Proje√ß√£o de Mollweide", graticule = TRUE)
```

Ou ainda utilizar a Proje√ß√£o Azimutal de Lambert com alguns par√¢metros ajustados para centrar a proje√ß√£o no Brasil (\@ref(fig:fig-vetor-mundo-laea)).

```{r}
# projecao de mollweide 
co110_sf_laea <- sf::st_transform(x = co110_sf, 
                                  crs = "+proj=laea +x_0=0 +y_0=0 +lon_0=-50 +lat_0=0")
```

```{r fig-vetor-mundo-laea, fig.align='center', fig.cap="Mapa do mundo com CRS Proje√ß√£o Azimutal de Lambert centrado no Brasil."}
plot(co110_sf_laea[1], col = "gray", main = "Proje√ß√£o Azimutal de Lambert", graticule = TRUE)
```

### Raster

A reproje√ß√£o de objetos raster n√£o √© uma tarefa t√£o simples quanto a reprojeao de vetores. Em vetores, a reproje√ß√£o altera as coordenadas de cada v√©rtice. Entretanto, como rasters s√£o compostos de c√©lulas retangulares do mesmo tamanho, a reproje√ß√£o do raster envolve a **cria√ß√£o de um novo objeto raster**, envolvendo duas opera√ß√µes espaciais separadas: 1) reproje√ß√£o vetorial dos centr√≥ides celulares para outro CRS (i.e., muda a **posi√ß√£o** e **tamanho** do pixel) e, 2) c√°lculo de novos valores de pixel por meio de reamostragem (i.e., muda o **valor** do pixel).

A fun√ß√£o `raster::projectRaster()` possui alguns par√¢metros que necessitam de algumas especifica√ß√µes. O argumento **from** que √© objeto raster de entrada para que sofra a reproje√ß√£o. O argumento **to** √© um objeto raster do qual todas as propriedade CRSs, como exten√ß√£o e resolu√ß√£o ser√£o associadas ao objeto raster indicado em **from**. O argumento **res** permite ajustar a resolu√ß√£o do pixel de sa√≠da do objeto raster reprojetado.

O argumento **crs** aceita apenas as defini√ß√µes de `proj4string` extensas de um CRS em vez de c√≥digos EPSG concisos. Contudo, √© poss√≠vel usar um c√≥digo `EPSG` em uma defini√ß√£o de `proj4string` com `+init=epsg:EPSG`. Por exemplo, pode-se usar a defini√ß√£o `+init=epsg:4326` para definir CRS para WGS84 (c√≥digo EPSG de 4326). A biblioteca `PROJ` adiciona automaticamente o resto dos par√¢metros e os converte em `+init=epsg:4326 +proj=longlat +datum=WGS84 + no_defs + ellps=WGS84 + towgs84=0,0,0`.

O argumento **method** permite escolher entre os m√©todos *"ngb" (vizinho mais pr√≥ximo)* ou *"biliniar" (interpola√ß√£o bilinear)*, sendo o primeiro mais indicado para reproje√ß√£o de **rasters categ√≥ricos**, pois os valores estimados devem ser iguais aos do raster original. O m√©todo *"ngb"* define cada novo valor de c√©lula para o valor da c√©lula mais pr√≥xima (centro) do raster de entrada. J√° o m√©todo *"biliniar"* √© indicado para **raster cont√≠nuos** e calcula o valor da c√©lula de sa√≠da com base nas quatro c√©lulas mais pr√≥ximas no raster original, sendo a m√©dia ponderada da dist√¢ncia dos valores dessas quatro c√©lulas.

Aqui, vamos reprojetar os dados de eleva√ß√£o para Rio Claro/SP. Para que esse processo seja mais r√°pido, iremos ajustar a extens√£o do raster para o limite do munic√≠pio usando a fun√ß√£o `raster::crop()` (Figura \@ref(fig:fig-raster-crop)). Essa fun√ß√£o ser√° melhor explicada na se√ß√£o xx.

```{r}
# ajuste do limite
ra_rc <- raster::crop(x = ra, y = rc_2019)
ra_rc
```

```{r fig-raster-crop, fig.align='center', fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP."}
plot(ra_rc, col = viridis::viridis(10))
plot(rc_2019[1], col = NA, lwd = 2, add = TRUE)
```

Primeiramente, vamos reprojetar indicando uma proje√ß√£o e sem especificar o tamanho da c√©lula (Figura \@ref(fig:fig-raster-reproj)). Note que o tamanho da c√©lula vai se ajustar para valores diferentes, sendo portanto, pixels retangulares.

```{r}
# reprojecao
ra_rc_sirgas2000_utm23s <- raster::projectRaster(from = ra_rc, crs = "+init=epsg:31983", method = "bilinear")
ra_rc_sirgas2000_utm23s
```

```{r fig-raster-reproj, fig.align='center', fig.cap="Reproje√ß√£o do raster de eleva√ß√£o para SIRGAS2000/UTM23S sem especificar o tamanho da c√©lula."}
plot(ra_rc_sirgas2000_utm23s, col = viridis::viridis(10))
plot(rc_2019_sirgas2000_utm23s[1], col = NA, lwd = 2, add = TRUE)
```

Agora vamos reprojetar especificando o tamanho da c√©lula (Figura \@ref(fig:fig-raster-reproj-celula)). Dessa forma, todas as c√©lulas ter√£o o mesmo, i.e., 90 m.

```{r}
# reprojecao
ra_rc_sirgas2000_utm23s <- raster::projectRaster(from = ra_rc, crs = "+init=epsg:31983", method = "bilinear", res = 90)
ra_rc_sirgas2000_utm23s
```

```{r fig-raster-reproj-celula, fig.align='center', fig.cap="Reproje√ß√£o do raster de eleva√ß√£o para SIRGAS2000/UTM23S especificado por um objeto e informando o tamanho da c√©lula."}
plot(ra_rc_sirgas2000_utm23s, col = viridis::viridis(10))
plot(rc_2019_sirgas2000_utm23s[1], col = NA, lwd = 2, add = TRUE)
```

Vamos tamb√©m reprojetar uma camada mundial da m√©dia de temperatura anual, indicando o tamanho da c√©lula para 25.000 m (Figura \@ref(fig:fig-raster-reproj-celula-mundo)).

```{r}
# reprojecao
bio01_moll <- raster::projectRaster(st[[1]], crs = "+proj=moll", res = 25000, method = "bilinear")
bio01_moll
```

```{r fig-raster-reproj-celula-mundo, fig.align='center', fig.cap="Reproje√ß√£o do raster de m√©dia de temperatura anual para Proje√ß√£o de Mollweide informando o tamanho da c√©lula."}
plot(bio01_moll, col = viridis::viridis(10))
plot(co110_sf_moll[1], col = NA, add = TRUE)
```

## Principais opera√ß√µes com dados geogr√°ficos

Nesta se√ß√£o veremos as principais fun√ß√µes para realizar opera√ß√µes com dados geogr√°ficos. Essas opera√ß√µes est√£o separadas conforme Lovelace, Nowosad & Muenchow (2019): **Opera√ß√µes de atributos**, **Opera√ß√µes espaciais**, e **Opera√ß√µes geom√©tricas**.

### Opera√ß√µes de atributos

S√£o modifica√ß√£o de objetos espaciais baseado em **informa√ß√µes n√£o espaciais** associadas a dados geogr√°ficos, como a **tabela de atributos** ou **valores das c√©lulas e nome** dos rasters.

#### Vetor

As principais **opera√ß√µes de atributos vetoriais** s√£o com respeito √† tabela de atributos, sendo elas: 1) filtro, 2) jun√ß√£o, 3) agrega√ß√£o, e 4) cria√ß√£o e/ou altera√ß√£o de atributos. A lista de poss√≠veis opera√ß√µes √© longa, ent√£o apresentaremos algumas opera√ß√µes utilizando as princiais fun√ß√µes e listamos as demais fun√ß√µes e suas opera√ß√µes, que ir√£o depender de objetivos diversos.

Quase todas as opera√ß√µes ser√£o as mesmas realizadas pelo pacote *dplyr* em uma tabela de dados, sendo algumas opera√ß√µes espec√≠ficas para **alterar apenas a tabela de atributos** e outras que **refletem opera√ß√µes nas fei√ß√µes**, ou seja, ir√£o alterar atrav√©s da tabela de atributos as caracter√≠sticas das fei√ß√µes. Essas fun√ß√µes e suas opera√ß√µes s√£o descritas com detalhes na Tabela (\@ref(tab:tab-vetor-operacoes-atributos)).

```{r tab-vetor-operacoes-atributos, echo=FALSE}
knitr::kable(tibble(
  Fun√ß√µes = c("`filter()`", 
              "`slice()`", 
              "`n_sample()`", 
              "`group_by()`", 
              "`summarise()`", 
              "`select()`", 
              "`pull()`", 
              "`rename()`", 
              "`mutate()`", 
              "`*_join()`"),
  `Onde atua` = c("Fei√ß√µes", 
                  "Fei√ß√µes", 
                  "Fei√ß√µes", 
                  "Fei√ß√µes", 
                  "Fei√ß√µes", 
                  "Atributos",
                  "Atributos",
                  "Atributos",
                  "Atributos",
                  "Atributos"),
  Descri√ß√£o = c("Selecionar fei√ß√µes por valores",
                "Selecionar fei√ß√µes pela posi√ß√£o na tabela de atributos",
                "Amostrar fei√ß√µes na tabela de atributos",
                "Agrupar fei√ß√µes por valores da tabela de atributos",
                "Opera√ß√µes com valores das fei√ß√µes na tabela de atributos, que acabam por dissolver as fei√ß√µes",
                "Selecionar colunas da tabela de atributos",
                "Selecionar uma coluna da tabela de atributos como vetor",
                "Renomear uma coluna da tabela de atributos",
                "Criar uma coluna ou alterar os valores da tabela de atributos",
                "Diversas fun√ß√µes para juntar dados de outras tabelas de dados √† tabela de atributos")), 
  caption = "Principais fun√ß√µes para realizar opera√ß√µes de atributos e suas descri√ß√µes.")
```

Para exemplificar as opera√ß√µes de atributos, vamos utilizar os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

##### Filtro
Vamos iniciar fazendo o **filtro de fei√ß√µes pela tabela de atributos**, que permite selecionar fei√ß√µes pelos seus valores atribu√≠dos, utilizando a fun√ß√£o `dplyr::filter()`. Aqui vamos selecionar as fei√ß√µes de floresta do mapa de cobertura da terra para Rio Claro/SP (Figura \@ref(fig:fig-vetor-opat-filtro)).

```{r}
# filtro
rc_cob_floresta <- rc_cob %>% 
  dplyr::filter(CLASSE_USO == "forma√ß√£o florestal")
```

```{r fig-vetor-opat-filtro, fig.align='center', fig.cap="Filtro da classe floresta para o mapeamento de cobertura da terra para o munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_cob_floresta$geometry, col = "forestgreen", add = TRUE)
```

##### Jun√ß√£o
Acreditamos que uma das fun√ß√µes mais √∫teis das opera√ß√µes de atributos seja a **jun√ß√£o**, referida em ingl√™s como *join*, atrav√©s das fun√ß√µes `dplyr::*_join()`. Nela, usamos uma coluna **identificadora** para **atribuir dados de outra tabela de dados**. Como exemplo, vamos criar uma tabela de dados e atribuir esses novos nomes de cobertura da terra √† tabela de atributos do objeto vetorial.

```{r}
# dados
da_classes <- tibble::tibble(CLASSE_USO = rc_cob$CLASSE_USO, 
                             classe = c("agua", "antropico", "edificado", "floresta", "silvicultura"))
da_classes
```

```{r}
# juncao
rc_cob_classes <- dplyr::left_join(rc_cob, da_classes, by = "CLASSE_USO") %>% 
  sf::st_drop_geometry()
rc_cob_classes
```

##### Agrega√ß√£o
Outra fun√ß√£o bastante √∫til √© a **agrega√ß√£o de atributos**. Apesar de existir uma fun√ß√£o que realiza a **uni√£o de fei√ß√µes**, a jun√ß√£o das fun√ß√µes `dplyr::group_by()` e `dplyr::summarise()` realizam uma tarefa semelhante. Aqui vamos agregar as nascentes para Rio Claro/SP, i.e., juntar cada ponto que estava numa linha da tabela de atributos de modo que todos fiquem numa mesma linha, com o valor da quantidade de nascentes (Figura \@ref(fig:fig-vetor-opat-agregar)).

```{r}
# agregar
rc_nas_n <- rc_nas %>% 
  dplyr::group_by(MUNICIPIO, HIDRO) %>% 
  dplyr::summarise(n = n())
rc_nas_n
```

```{r fig-vetor-opat-agregar, fig.align='center', fig.cap="Agrega√ß√£o das nascentes para o munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_nas_n$geometry, pch = 20, col = "blue", add = TRUE)
```

##### Manipula√ß√£o de colunas na tabela de atributos
Por fim, √© muito comum em an√°lises de softwares SIG a **cria√ß√£o de novas colunas na tabela de atributos**. Aqui, podemos utilizar a fun√ß√£o `dplyr::mutate()` para criar essas novas colunas, assim como atualizar os valores de colunas existentes. Em nosso exemplo, iremos fazer uma composi√ß√£o das colunas **CLASSE_USO** e **AREA_HA** na coluna **classe_area**.

```{r}
# criar coluna
rc_cob_cob_col_area <- rc_cob %>% 
  dplyr::mutate(classe_area = paste0(CLASSE_USO, " (", AREA_HA, " ha)")) %>% 
  sf::st_drop_geometry()
rc_cob_cob_col_area
```

Duas fun√ß√µes s√£o bastante interessantes de serem integradas junto com a manipula√ß√£o de tabelas de atributos. Elas calculam propriedades geom√©tricas num√©ricas dos vetores de linhas (comprimento) e pol√≠gonos (√°rea): `sf::st_length()` e `sf::st_area()`. Essas fun√ß√µes calculam essas propriedades em metros para comprimento e metros quadrados para √°rea, independentemente do CRS. Para tanto, vamos utilizar as linhas de hidrografia e os pol√≠gonos de cobertura da terra para Rio Claro/SP, e atribuir esses valores √† tabela de atributos de ambos os objetos espaciais, utilizando em conjunto a fun√ß√£o `dplyr::mutate()`.

```{r}
# comprimento de linhas
rc_hid_comp <- rc_hid %>% 
  dplyr::mutate(com = sf::st_length(.))
rc_hid_comp
```

```{r}
# area de poligonos
rc_cob_area <- rc_cob %>% 
  dplyr::mutate(area_m2 = sf::st_area(.))
rc_cob_area
```

#### Raster

Devido a **estrutura espacial** do rater ser **formada por uma ou mais superf√≠cies cont√≠nuas**, as manipula√ß√µes como subconjunto e outras opera√ß√µes em objetos raster funcionam de uma maneira diferente do que em objetos vetoriais. Veremos aqui as tr√™s principais: 1) subconjunto de c√©lulas usando o operador `[]`, j√° para subconjunto de camadas `RasterStack` ou `RasterBrick` podemos utilizar fun√ß√µes ou os operadores `[[]]` e `$`, 2) renomear nomes das camdas, e 3) resumir informa√ß√µes de todos os pixels.

Podemos fazer um **subconjunto de c√©lulas** utilizando dentro dos operadores `[]` valores para indicar a **posi√ß√£o da linha e coluna de um raster**, ou ainda a **posi√ß√£o de uma c√©lula** utilizando apenas um n√∫mero. Essas opera√ß√µes resultar√£o em valores diferentes para `RasterLayer` e `RasterBrick` ou `RasterStack`.

##### Subconjunto
```{r}
# raster - linha 1 e columna 1
ra[1, 1]

# celula 1
ra[1]

# stack - linha 1 e columna 1
st[1, 1]

# celula 1
st[1]
```

Para **selecionar uma camada** de um `RasterBrick` ou `RasterStack` podemos utilizar as fun√ß√µes `raster::subset()` ou `raster::raster()` com o argumento **layer** indicando a ordem ou o nome da camada, al√©m dos operadores `[[]]` e `$` (Figura \@ref(fig:fig-raster-stack-subset)).

```{r}
# selecao de camada num objeto stack utilizando a funcao subset
st_bio01 <- raster::subset(st, "wc2.1_10m_bio_1")
st_bio01

# selecao de camada num objeto stack utilizando a funcao raster
st_bio01 <- raster::raster(st, layer = 1)
st_bio01

# selecao de camada num objeto stack utilizando os operadores [[]] e o nome
st_bio01 <- st[["wc2.1_10m_bio_1"]]
st_bio01

# selecao de camada num objeto stack utilizando os operadores [[]] e a posicao
st_bio01 <- st[[1]]
st_bio01

# selecao de camada num objeto stack utilizando o operador $
st_bio01 <- st$wc2.1_10m_bio_1
st_bio01
```

```{r fig-raster-stack-subset, fig.align='center', fig.cap="Camada BIO01 selecionada pelas opera√ß√µes de subconjunto acima do stack de vari√°veis bioclim√°ticas."}
raster::plot(st_bio01, col = viridis::viridis(10))
```

##### Renomear
Podemos ainda **renomear camadas** dos raster `StackLayer` utilizando a fun√ß√£o `names()`.

```{r}
# nomes
names(ra_rc)

# renomear
names(ra_rc) <- "elevacao"

# nomes
names(ra_rc)
```

E essa opera√ß√£o tamb√©m funciona para `StackBrick` e `StackStack`.

```{r}
# nomes
names(st)

# renomear
names(st) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))

# nomes
names(st)
```

##### Resumir
Muitas vezes queremos fazer **c√°lculos** para todos as c√©lulas de um raster. Podemos **resumir informa√ß√µes de todos os pixels** fazendo c√°lculos simples com todos os pixels de cada camada com a fun√ß√£o `raster::cellStats()`, sendo x **x** o argumento do objeto raster e **stat** o nome da fun√ß√£o resumo, como "mean" ou "sum".

```{r}
# media de todas as celulas de altitude
raster::cellStats(x = ra_rc, stat = mean)

# media de todas as celulas de cada camada bioclimatica
raster::cellStats(x = st, stat = mean)
```

Ou ainda, podemos analisar a **frequ√™ncia com que cada valor dos pixels**, utilizand a fun√ß√£o `raster::freq()`.

```{r}
# frequencia das celulas
raster::freq(x = ra_rc) %>% head()

# frequencia das celulas
raster::freq(x = st[[1]]) %>% head()
```

### Opera√ß√µes espaciais

S√£o modifica√ß√£o de objetos espaciais baseado em **informa√ß√µes espaciais**, como **localiza√ß√£o e formato**. Seria imposs√≠vel abordar todas as opera√ß√µes realiz√°veis, ent√£o listaremos as principais e demonstraremos algumas para dados vetoriais e raster.

#### Vetor
As principais opera√ß√µes espaciais para dados vetoriais s√£o: 1) filtro espacial, 2) jun√ß√£o espacial, 3) agrega√ß√£o espacial e 4) dist√¢ncia espacial. Apresentaremos essas opera√ß√µes utilizando as princiais fun√ß√µes utilizando os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

##### Filtro espacial
Filtros espaciais s√£o opera√ß√µes que realizam **sele√ß√£o de fei√ß√µes espaciais entre dois objetos espaciais (x e y)**. Existe uma grande quantidade de fun√ß√µes para realizar filtros espaciais no R, e isso difere muito entre os objetivos, como podemos ver na Tabela (\@ref(tab:tab-filtro-espacial), Pebesma & Bivand 2020). Essas fun√ß√µes verificam se cada fei√ß√£o em x mant√©m a rela√ß√£o em y. Ao especificar o par√¢metro **sparse** = FALSE, as fun√ß√µes retornam uma matriz l√≥gica (`TRUE` e `FALSE`).

```{r tab-filtro-espaial, echo=FALSE}
knitr::kable(tibble::tibble(
  Fun√ß√£o = c("`sf::st_contains()`", 
             "`sf::st_contains_properly()`", 
             "`sf::st_covers()`", 
             "`sf::st_covered_by()`", 
             "`sf::st_crosses()`", 
             "`sf::st_disjoint()`", 
             "`sf::st_equals()`", 
             "`sf::st_equals_exact()`", 
             "`sf::st_intersects()`", 
             "`sf::st_is_within_distance()`", 
             "`sf::st_within()`", 
             "`sf::st_touches()`", 
             "`sf::st_overlaps()`", 
             "`sf::st_relate()`"), 
  Descri√ß√£o = c("Nenhum dos pontos de x est√° fora de y", 
                "x cont√©m y, e y n√£o tem pontos em comum com a fronteira de x", 
                "Nenhum ponto de y se encontra no exterior de x", 
                "Inverso de `sf::st_covers()`", 
                "x e y t√™m alguns, mas n√£o todos os pontos internos em comum", 
                "x e y n√£o t√™m pontos em comum", 
                "x e y s√£o geometricamente iguais; o n√∫mero de pedido dos n√≥s pode ser diferente; id√™ntico a x cont√©m y xND x dentro de y", 
                "x e y s√£o geometricamente iguais e t√™m ordem de n√≥ id√™ntica", 
                "x e y n√£o s√£o separados", 
                "x est√° mais perto de y do que uma determinada dist√¢ncia", 
                "Nenhum dos pontos de y est√° fora de x", 
                "x e y t√™m pelo menos um ponto limite em comum, mas nenhum ponto interno", 
                "x e y t√™m alguns pontos em comum; a dimens√£o destes √© id√™ntica √† de x e y", 
                "Dado um padr√£o, retorna se x e y aderem a este padr√£o"),
  `Fun√ß√£o inversa` = c("`st_within`", 
                       NA,
                       "`st_covered_by`", 
                       NA, 
                       NA, 
                       "`st_intersects`", 
                       NA, 
                       NA, 
                       "`st_disjoint`", 
                       NA, 
                       "`st_contains`", 
                       NA, 
                       NA, 
                       NA)),
  caption = "Principais pacotes para composi√ß√£o de mapas no R.")
```

Em nosso exemplo, utilizaremos a fun√ß√£o `sf::intersects()` para filtrar as nascentes dentro de floresta para Rio Claro/SP. Essa fun√ß√µes vai retornar a resposta bin√°ria se as nascentes est√£o (1) ou n√£o (empty) dentro dos pol√≠gonos de floresta.

```{r}
# filtro espacial
sf::st_intersects(x = rc_nas, y = rc_cob_floresta)
```

Podemos usar essa mesma fun√ß√£o em conjunto com a fun√ß√£o `dplyr::filter()` para filtrar as nascentes dentro de florestas.
```{r} 
# filtro espacial - interno
rc_nas_floresta_int <- rc_nas %>% 
  dplyr::filter(sf::st_intersects(x = ., y = rc_cob_floresta, sparse = FALSE))
```

Ou ainda podemos utilizar o operador `[]` para realizar esse filtro, como podemos notar na Figura \@ref(fig:fig-vetor-filtro-espacial-interno).

```{r}
# filtro espacial com [] - interno
rc_nas_floresta_int <- rc_nas[rc_cob_floresta, ]
```

```{r fig-vetor-filtro-espacial-interno, fig.align='center', fig.cap="Nascentes dentro de florestas no munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_cob_floresta$geometry, col = "forestgreen", add = TRUE)
plot(rc_nas_floresta_int$geometry, col = "blue", pch = 20, cex = 1, add = TRUE)
```

Entretanto, muitas vezes queremos fazer o filtro de fei√ß√µes que est√£o fora de fei√ß√µes de outro objeto espacial. Para isso, podemos usar a fun√ß√£o `sf::st_disjoint()` ou ainda utilizando o operador `[]`, mas com o argumento **op**, nesse caso utilizando a mesma fun√ß√£o como opera√ß√£o (Figura \@ref(fig:fig-vetor-filtro-espacial-externo)).

```{r}
# filtro espacial - externo
rc_nas_floresta_ext <- rc_nas %>% 
  dplyr::filter(sf::st_disjoint(x = ., y = rc_cob_floresta, sparse = FALSE))

# filtro espacial com [] - externo
rc_nas_floresta_ext <- rc_nas[rc_cob_floresta, , op = st_disjoint]
```

```{r fig-vetor-filtro-espacial-externo, fig.align='center', fig.cap="Nascentes fora de florestas no munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_cob_floresta$geometry, col = "forestgreen", add = TRUE)
plot(rc_nas_floresta_ext$geometry, col = "steelblue", pch = 20, cex = 1, add = TRUE)
```

##### Jun√ß√£o espacial

Outra opera√ß√£o muito usada dentro de an√°lises espaciais √© a jun√ß√£o espacial ou do ingl√™s *spatial join*. A ideia base √© muito semelhante com a jun√ß√£o baseada em atributos, mas aqui iremos **atribuir o valor da tabela de atributos das fei√ß√µes de um objeto espacial y √†s fei√ß√µes que fazem intersec√ß√£o com um objeto espacial x**, de modo que esses valores sejam armazenados na tabela de atributos do segundo objeto espacial.

Para exemplificar, vamos atribuir os valores dos pol√≠gonos de cobertura da terra aos pontos de nascentes para Rio Claro/SP, fazendo um agrupamento pela tabela de atributos para permitir criar o mapa da Figura \@ref(fig:fig-vetor-juncao-espacial).

```{r}
# juncao espacial
rc_nas_cob_jun <- rc_nas %>% 
  sf::st_join(x = ., y = rc_cob) %>% 
  dplyr::group_by(CLASSE_USO) %>% 
  dplyr::summarise(n = n())
```

```{r fig-vetor-juncao-espacial, fig.align='center', fig.cap="Jun√ß√£o espacial da cobertura da terra para as nascentes no munic√≠pio de Rio Claro/SP."}
# plot
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_nas_cob_jun[1], col = c("blue", "orange", "gray30", "forestgreen", "green"), pch = 20, add = TRUE)
```

##### Agrega√ß√£o espacial 
Muitas vezes queremos contabilizar quantos pontos ou agregar valores de pontos para pol√≠gonos. Podemos agregamos esses usando as fun√ß√µes `dplyr::group_by()` e `dplyr::summarise` ou utilizar a fun√ß√£o `aggregate()`. Nesse exemplo, vamos contabilizar quantas nascentes h√° por cada pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

```{r}
# agregacao espacial
rc_cob_nas_agre <- rc_nas %>% 
  aggregate(x = ., by = rc_cob, FUN = length)
```

```{r fig-vetor-vetor-agregacao-espacial, fig.align='center', fig.cap="Agrega√ß√£o espacial contabilizando o n√∫mero de nascentes para cada classe de cobertura da terra no munic√≠pio de Rio Claro/SP."}
plot(rc_cob_nas_agre[1], axes = TRUE, graticule = TRUE, main = NA)
```

##### Dist√¢ncia espacial
A dist√¢ncia espacial √© a dist√¢ncia calculada em duas dimens√µes (2D) entre um objeto espacial x e y baseado no CRS e para cada fei√ß√£o dos objetos espaciais. Para realizar esse c√°lculo, utilizamos a fun√ß√£o `sf::st_distance()`. Em nosso exemplo, vamos calcular a dist√¢ncia das nascentes at√© a floresta mais pr√≥xima, e adicionando essa informa√ß√£o para cada ponto na tabela de atributos com a fun√ß√£o `dplyr::mutate()`, para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-distancia-espacial)).

```{r}
rc_nas_dist_flo <- rc_nas %>% 
  dplyr::mutate(dist_flo = sf::st_distance(rc_nas, rc_cob_floresta))
```

```{r fig-vetor-fig-vetor-distancia-espacial, fig.align='center', fig.cap="Dist√¢ncia espacial das nascentes at√© a floresta mais pr√≥xima no munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_cob_floresta$geometry, col = "forestgreen", add = TRUE)
plot(rc_nas_dist_flo[7], pch = 20, add = TRUE)
```

#### Raster

As principais **opera√ß√µes espaciais para dados raster** podem ser classificas, segundo @lovelace-etal-2019, em: 1) opera√ß√µes locais (por c√©lula), 2) opera√ß√µes focais (por bloco de multiplas c√©lulas regulares - e.g. 3x3), 3) opera√ß√µes zonais (por bloco de multiplas c√©lulas irregulares) e 4) opera√ß√µes globais (por um ou v√°rios rasters inteiros). Cada uma delas √© aplicada para objetivos e escalas espaciais espec√≠ficas. Para os exemplos desta se√ß√£o, utilizaremos o dado raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP.

##### Opera√ß√µes locais

As **opera√ß√µes locais** contemplam todas as **opera√ß√µes realizadas c√©lula a c√©lula** em uma ou v√°rias camadas de um objeto raster. A **√°lgebra de raster** √© uma das mais comuns, simples e poderosas. Com ela podemos fazer opera√ß√µes simples atrav√©s de **operadores aritm√©ticos** (soma, subtra√ß√£o, multiplica√ß√£o, divis√£o ou potencia√ß√£o) entre dois ou mais objetos raster, ou utilizar **fun√ß√µes** para alterar todos os valores dos pixels como, por exemplo, as fun√ß√µes `lo10()` ou `sqrt()`, ou ainda a fun√ß√£o `raster::scale()` para padronizar os valores dos rasters. (Figura \@ref(fig:fig-raster-local-aritmetico)).

```{r}
# soma
ra_rc2 <- ra_rc + ra_rc

# log10
ra_rc_log10 <- log10(ra_rc)
```

```{r fig-raster-local-aritmetico, fig.align='center', fig.cap="Rasters de soma e log10 do mapa de eleva√ß√£o para Rio Claro/SP."}
par(mfrow = c(1, 2))

raster::plot(ra_rc2, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)

raster::plot(ra_rc_log10, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)

par(mfrow = c(1, 1))
```

Al√©m das opera√ß√£o aritm√©ticas, a **√°lgebra de rasters** tamb√©m permite **opera√ß√µes l√≥gicas**, como criar um novo raster (bin√°rio - composto por 1 quando a opera√ß√£o l√≥gica √© verdadeira, e 0 quanto √© falsa), onde todas as c√©lulas s√£o maiores ou menores que um valor espec√≠fico, no nosso caso, buscamos todos os pixels acima de 600 metros em Rio Claro/SP (Figura \@ref(fig:fig-raster-local-logico)).

```{r}
# acima de 600
ra_rc_acima_600 <- ra_rc > 600
```

```{r fig-raster-local-logico, fig.align='center', fig.cap="Opera√ß√£o local l√≥gica mostrando todos os pixels acima de 600 metros de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_acima_600, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Al√©m das operadores aritm√©ticas, tamb√©m podemos usar as fun√ß√µes `raster::calc()` (uma camada) e `raster::overlay()` (duas ou mais camadas) para **realizar opera√ß√µes em todas as c√©lulas**. Elas funcionam com a cria√ß√£o de uma **fun√ß√£o espec√≠fica** atrav√©s da fun√ß√£o `function()`, para esta que seja aplicada em todas as c√©lulas do raster. Essas fun√ß√µes s√£o muito eficientes, portanto, s√£o prefer√≠veis para grandes conjuntos de dados raster. Al√©m disso, eles permitem armazenar diretamente no disco ap√≥s a realiza√ß√£o da opera√ß√£o. Exemplificaremos calculando o produto de todos os pixels por eles mesmos do raster de eleva√ß√£o de Rio Claro/SP (Figura \@ref(fig:fig-raster-local-calc)).

```{r}
# produto dos pixel - calc
ra_rc_prod <- raster::calc(x = ra_rc, fun = function(x){x * x})
ra_rc_prod 
```

```{r fig-raster-local-calc, fig.align='center', fig.cap="Opera√ß√£o locais multiplica√ß√£o de todos os pixels por eles mesmos de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_prod, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A **preci√ß√£o de mapas** raster √© outra aplica√ß√£o extremamente √∫til de opera√ß√µes locais. A partir da rela√ß√£o entre **vari√°veis respostas** (e.g, pontos no espa√ßo, como ocorr√™ncia ou riqueza de esp√©cies), e **vari√°veis preditoras** (rasters  cont√≠nuos de eleva√ß√£o, pH, precipita√ß√£o, temperatura, cobertura da terra ou classe de solo), criamos **modelos** usando fun√ß√µes como `lm()`, `glm()`, `gam()` ou uma t√©cnica de aprendizado de m√°quina, e fazemos **predi√ß√µes espaciais** aplicando os **coeficientes estimados** aos valores dos raster preditores (consulte a se√ß√£o xx).

Por fim, a **reclassifica√ß√£o de rasters** √© outra opera√ß√£o muito comum quando trabalhamos com esse tipo de objeto espacial. Nela √© realizada a classifica√ß√£o de intervalos de valores num√©ricos em grupos, e.g. agrupar um modelo digital de eleva√ß√£o em classes. A fun√ß√£o que faz essa opera√ß√£o √© a `raster::reclassify()`. Ela possui dois argumentos: **x** que √© o raster a ser reclassificado, e o segundo **rcl**, para o qual devemos construir uma matriz de reclassifica√ß√£o, onde a primeira coluna √© a extremidade inferior, a segunda coluna √© a extremidade superior, e a terceira coluna representa o novo valor para os intervalos das colunas um e dois. Vamos reclassificar o raster de eleva√ß√£o de Rio Claro/SP para os intervalos 400‚Äì600, 600‚Äì800 e 800‚Äì1000 que s√£o reclassificados para os valores 1, 2 e 3, respectivamente (Figura \@ref(fig:fig-raster-local-reclassificacao)).

```{r}
# matriz de reclassificacao
rcl  <- matrix(c(400,600,1, 
                 600,800,2, 
                 800,1000,3), 
               ncol = 3, byrow = TRUE)

# reclassificao
ra_rc_rcl <- raster::reclassify(x = ra_rc, rcl = rcl)
```

```{r fig-raster-local-reclassificacao, fig.align='center', fig.cap="Opera√ß√£o local de reclassifica√ß√£o para tr√™s classes de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_rcl, col = viridis::viridis(3))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

##### Opera√ß√µes focais 

As **opera√ß√µes focais** levam em considera√ß√£o uma c√©lula central e seus vizinhos. A vizinhan√ßa (tamb√©m chamada de janela m√≥vel - *moving window*) tipicamente √© considera de c√©lulas de 3 por 3 (c√©lula central e seus oito vizinhos), mas pode assumir outra forma. A opera√ß√£o focal aplica uma fun√ß√£o de agrega√ß√£o a todas as c√©lulas dentro da vizinhan√ßa especificada, e usa a sa√≠da correspondente como o novo valor para a c√©lula central e segue para a pr√≥xima c√©lula central e seus vizinhos. 

Essa opera√ß√£o √© realizada atrav√©s da fun√ß√£o `raster::focal()`. O par√¢metro **x** especifica o raster de entrada, o par√¢metro **w** define a janela m√≥vel por uma matriz cujos valores correspondem a pesos, e por fim o par√¢metro **fun** especifica a fun√ß√£o que desejamos aplicar √†s c√©luas, como `min()`, `max()`, `sum()`, `mean()`, `sd()` ou `var()`. Existem diversas aplica√ß√µes dessa opera√ß√£o para dados raster, como no processamento de imagens de sat√©lite (ver mais em Wegmann et al. 2016). Outra utilizade √© para o  c√°lculo de caracter√≠sticas topogr√°ficas, como declividade, aspecto e dire√ß√µes de fluxo. Para calcular essas m√©tricas, podemos utilizar a fun√ß√£o `raster::terrain()`.

Para nosso exemplo, vamos realizar o c√°lculo do desvio padr√£o da eleva√ß√£o e a m√©trica de aspecto (orienta√ß√£o da vertente) para a eleva√ß√£o em Rio Claro/SP (Figura \@ref(fig:fig-raster-focal)).

```{r}
# janela movel
ra_rc_focal_sd <- raster::focal(x = ra_rc, w = matrix(1, nrow = 3, ncol = 3), fun = sd)

# declividade
ra_rc_asp <- raster::terrain(x = ra_rc, opt = "aspect")
```

```{r fig-raster-focal, fig.align='center', fig.cap="C√°lculo do desvio padr√£o da eleva√ß√£o para uma janela de 3x3 e do aspecto para Rio Claro/SP."}
par(mfrow = c(1, 2))

raster::plot(ra_rc_focal_sd, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)

raster::plot(ra_rc_asp, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)

par(mfrow = c(1, 1))
```

##### Opera√ß√µes zonais

As **opera√ß√µes zonais** aplicam uma fun√ß√£o de agrega√ß√£o a v√°rias c√©lulas de uma raster. Geralmente usa-se um segundo raster categ√≥rico para definir as zonas, de modo que as c√©lulas raster que definem a zona n√£o precisam ser vizinhas, como na opera√ß√£o focal. O resultado de uma opera√ß√£o zonal √© uma tabela de resumo agrupada por zona, explicando porque essa opera√ß√£o tamb√©m conhecida como estat√≠stica zonal. Isso √© um contraste com as opera√ß√µes focais que retornam um objeto raster.

A opera√ß√£o zonal √© realizada atrav√©s da fun√ß√£o `raster::zonal()`, que recebe de entrada no argumento **x** o raster cont√≠nuo, em **z** o raster categ√≥rico, e em **fun** a fun√ß√£o que ir√° resumir as c√©lulas. Em nosso exemplo, vamos calcular a diversas medidas resumo da eleva√ß√£o com a fun√ß√£o `summary()` para cada classe de eleva√ß√£o que criamos anteriormente na se√ß√£o xx.

```{r}
# estatistica zonal
ra_rc_zonal <- data.frame(raster::zonal(ra_rc, ra_rc_rcl, fun = "summary"))
colnames(ra_rc_zonal) <- c("zona", "min", "1qt", "mediana", "media", "3qt", "max")
ra_rc_zonal
```

##### Opera√ß√µes globais

As **opera√ß√µes globais** usa todo o conjunto de dados raster representando uma √∫nica zona. As opera√ß√µes globais mais comuns s√£o **estat√≠sticas descritivas** para todo todos os pixels do raster, utilizando a fun√ß√£o `raster::cellStats()` ou `raster::freq()`. Al√©m das estat√≠sticas descritivas, podemos gerar **rasters de dist√¢ncia**, que calcula a dist√¢ncia de cada c√©lula a uma ou um grupo c√©lulas-alvo espec√≠fica, utilizando a fun√ß√£o `raster::distance()`. 

Em nosso exemplo, vamos selecionar a classe 1 do raster classificado de eleva√ß√£o e calcular a dist√¢ncia Euclidiana (Figura \@ref(fig:fig-raster-global)).

```{r}
# distancia
ra_rc_abaixo_500 <- raster::calc(x = ra_rc, fun = function(x) ifelse(x < 500, 1, NA))
ra_rc_global_dist <- raster::distance(ra_rc_abaixo_500)
```

```{r fig-raster-global, fig.align='center', fig.cap="Raster de dist√¢ncia Euclidiana dos pixels abaixo de 500 m de eleva√ß√£o para Rio Claro/SP."}
plot(ra_rc_global_dist, col = viridis::viridis(10))
plot(ra_rc_abaixo_500, add = TRUE, col = "white", legend = FALSE)
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

### Opera√ß√µes geom√©tricas
As **opera√ß√µes geom√©tricas** realizam modifica√ß√£o em objetos espaciais baseado na **geometria do vetor ou do raster** e na **intera√ß√£o e convers√£o entre vetor-raster**. As **opera√ß√µes geom√©tricas vetoriais** podem ser **un√°rias**, funcionam em uma √∫nica geometria, ou **bin√°rias**, que modificam uma geometria com base na forma de outra. Ainda podemos fazer transforma√ß√µes para **alterar os tipos vetores**, que ir√° refletir se as fei√ß√µes s√£o √∫nicas ou m√∫ltiplas. As **opera√ß√µes geom√©tricas em rasters** envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels subjacentes e atribuir-lhes novos valores. Por fim, podemos ainda fazer opera√ß√µes de **intera√ß√µes e convers√µes raster-vetor** para ajustar rasters √† vetores, assim como converter um objeto espacial vetorial para raster e vice-versa.

#### Vetor

Como dissemos, as **opera√ß√µes geom√©tricas em vetores** ir√£o criar ou alterar a geometria de objetos da classe `sf` em uma **√∫nica geometria (un√°rias)**: 1) simplifica√ß√£o, 2) centr√≥ides, 3) pontos aleatoriot√≥rios, 4) buffers, 5) pol√≠gono convexo, 7) pol√≠gonos de Voronoi, 7) quadr√≠culas e hex√°gonos; ou que **modificam uma geometria com base na forma de outra (bin√°rias)**: 8) uni√£o e 9) recortes; e que fazem **transforma√ß√µes de tipo**.

Para exemplificar as opera√ß√µes geom√©tricas com vetores, vamos utilizar os dados do limite, nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

##### Simplifica√ß√£o

A **simplifica√ß√£o** possui o intuito de generalizar linhas ou pol√≠gonos, diminuindo assim suas complexidades em rela√ß√£o ao n√∫mero de v√©rtices. √â utilizada para representa√ß√£o em mapas menores ou mapas interativos (se√ß√£o xx), ou ainda quando um objeto √© muito grande. A fun√ß√£o utilizada √© a `sf::st_simplify()`, que usa o argumento **dTolerance** para controlar o n√≠vel de generaliza√ß√£o nas unidades do mapa. Em nosso exemplo, simplificaremos a hidrografia (Figura \@ref(fig:fig-vetor-simplificacao)).

```{r}
# simplificacao
rc_hid_simplificado <- sf::st_simplify(x = rc_hid, dTolerance = 1000)
```

```{r fig-vetor-simplificacao, fig.align='center', fig.cap="Simplifica√ß√£o da hidrografia para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_hid$geometry, col = "steelblue", lwd = 2, add = TRUE)
plot(rc_hid_simplificado$geometry, col = adjustcolor("black", .7), add = TRUE)
```

##### Centroides

A opera√ß√£o de **centroides** identifica o centro de objetos geogr√°ficos, geralmente o centro de massa das fei√ß√µes. √â utilizado para gerar um ponto simples para representa√ß√µes complexas ou para estimar a dist√¢ncia entre pol√≠gonos. Podemos calcul√°-los com a fun√ß√£o `sf::st_centroids()`, ou com a a fun√ß√£o `sf::st_point_on_surface()` para garantir que caiam dentro dos pol√≠gonos. Aqui calcularemos o centroide do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-centroide)).   

```{r}
# centroides
rc_2019_sirgas2000_utm23s_cent <- sf::st_centroid(rc_2019_sirgas2000_utm23s)
```

```{r fig-vetor-centroide, fig.align='center', fig.cap="Centroide do limite do muni√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_cent$geom, cex = 3, pch = 20, add = TRUE)
```

##### Pontos aleatoriot√≥rios 

Por vezes precisamos criar algum padr√£o aleatoriot√≥rio dentro de um contexto espacial. Isso pode ser realizado de diversas formas. Uma delas √© a cria√ß√£o de **pontos aleatoriot√≥rios** para dentro de um pol√≠gono. Podemos realizar essa opera√ß√£o com a fun√ß√£o `sf::st_sample()`. Para essa fun√ß√£o, dois argumentos s√£o utilizados: **x** uma geometria de entrada e o **size** indicando o n√∫mero de pontos √† ser criado. Outro argumento bastante interessante √© o **type**, indicando o tipo de amostragem espacial. Para nosso exemplo, vamos fixar a amostragem utilizando a fun√ß√£o `set.seed()` e sortear 30 pontos para o limite do munic√≠pio de Rio Claro/SP.

```{r}
# fixar amostragem
set.seed(42)

# pontos aleatoriotorios
rc_2019_sirgas2000_utm23s_pontos_aleatorios <- sf::st_sample(rc_2019_sirgas2000_utm23s, size = 30)
```

```{r fig-vetor-pontos-aleatoriotorios, fig.align='center', fig.cap="Sorteio de 30 pontos aleatoriot√≥rio para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios, pch = 20, add = TRUE)
```

##### Buffer

Buffers s√£o **pol√≠gonos que representam a √°rea dentro de uma determinada dist√¢ncia** de um elemento geom√©trico, independentemente de ser um ponto, linha ou pol√≠gono. O buffer √© comumente utilizado para **an√°lise de dados geogr√°ficos**, geralmente sendo entendio como uma unidade amostral, **delimitando uma por√ß√£o no entorno de algum elemento ou evento**, como as condi√ß√µes clim√°ticas ou da estrutura da paisagem para uma amostragem, ou as caracter√≠sticas de cobertura da terra ao longo de um corpo d'√°gua, geralmente entendido como a √Årea de Preserva√ß√£o Permanente (APP). Em suma, o buffer √© fundamental para a √°rea de Ecologia Espacial, assim como Ecologia da Paisagem, dentro outras aplica√ß√µes. 

A fun√ß√£o utilizada para criar buffers √© a `sf::st_buffer()`, que requer pelo menos dois argumentos: **x** uma geometria de entrada e o **dist** uma dist√¢ncia para o buffer, fornecido nas unidades do CRS da geometria de entrada. Em nosso exemplo, vamos criar buffers de 1000 metros para os 30 pontos aleatoriot√≥rios criados anteriormente para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-buffer)).   

```{r}
# buffer
rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer <- sf::st_buffer(x = rc_2019_sirgas2000_utm23s_pontos_aleatorios, dist = 1000)
```

```{r fig-vetor-buffer, fig.align='center', fig.cap="Buffers de 500 metros no entorno das nascentes que caem em florestas para o munic√≠pio de Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer, col = NA, lwd = 2, border = "red", add = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

##### Pol√≠gono convexo

Uma an√°lise bastante comum, principalmente realizada pela IUCN, √© a cria√ß√£o de **pol√≠gonos convexos**, para definir a extens√£o de ocorr√™ncia de uma esp√©cie (*Extent of occurrence* - EOO). Nesse sentido, essa opera√ß√£o ir√° ligar os pontos externos de um conjuntos de pontos e criar um pol√≠gono √† partir deles. Podemos criar esse pol√≠gono com a fun√ß√£o `sf::st_convex_hull()`. Um √∫nico passo que precisamos adiantar √© utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto *sf* `MULTIPOINT`, mas que j√° iremos explicar com mais detalhes. Vamos utilizar os pontos aleatoriot√≥rios que criamos anteriormente para criar o pol√≠gono convexo Figura \@ref(fig:fig-vetor-convexo)).

```{r}
# poligono convexo
rc_2019_sirgas2000_utm23s_convexo <- rc_2019_sirgas2000_utm23s_pontos_aleatorios %>% 
  sf::st_union() %>% 
  sf::st_convex_hull()
```

```{r fig-vetor-convexo, fig.align='center', fig.cap="Pol√≠gono convexo para os 10 pontos criados aleatoriotoriamente para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_convexo, col = NA, lwd = 2, border = "red", add = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

##### Pol√≠gonos de Voronoi

Por fim, uma outra forma de criar pol√≠gonos para resumir dados espaciais √© atrav√©s do **Pol√≠gonos de Voronoi** ou **Diagrama de Voronoi**. Nele, pol√≠gonos irregulares s√£o criados √† partir da proximidade de pontos, de modo a estimar uma √°rea de abrang√™ncia no entorno dos mesmos (Okabe et al. 2000). Esses pol√≠gonos podem ser criado com a fun√ß√£o `sf::st_voronoi()`, mas precisamos novamente utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto *sf* `MULTIPOINT`. Vamos utilizar os pontos aleatoriot√≥rios que criamos anteriormente para criar o pol√≠gono de Voronoi Figura \@ref(fig:fig-vetor-voronoi)).

```{r}
# poligono de voronoi
rc_2019_sirgas2000_utm23s_voronoi <- rc_2019_sirgas2000_utm23s_pontos_aleatorios %>% 
  sf::st_union() %>% 
  sf::st_voronoi()
```

```{r fig-vetor-voronoi, fig.align='center', fig.cap="Pol√≠gono de Voronoi para os 10 pontos criados aleatoriotoriamente para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_voronoi, col = NA, lwd = 2, border = "red", add = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

##### Quadr√≠culas e hex√°gonos

Muitas vezes precisamos criar **unidades espaciais id√™nticas e igualmente espa√ßadas** para resumir informa√ß√µes dispersas por toda a nossa √°rea de estudo. Uma pr√°tica muito comum √© a cria√ß√£o de um gride de **pontos ou quadr√≠culas** em toda a √°rea de estudo, e depois utilizar essas geometrias para **associar ou resumir informa√ß√µes espacializadas** (exemplo na se√ß√£o xx), como a IUCN utiliza para a an√°lise de √°rea de ocupa√ß√£o (*Are of occupancy* - AOO). Al√©m das quadr√≠culas, uma outra geometria que se tornou bastante comum para as finalidades descritas, √© a cria√ß√£o de **hex√°gonos**, que al√©m de serem mais esteticamente atraentes, possuem uma explica√ß√£o matem√°tica de sua funcionadade para an√°lises espaciais (Birch et al. 2007).

A fun√ß√£o utilizada para criar esses grides √© a `sf::st_make_grid()`, que requer pelo menos dois argumentos: **x** uma geometria de entrada e o **cellsize** indicando o tamanho do gride a ser criado, fornecido nas unidades do CRS da geometria de entrada. H√° diversos outros argumentos, mas os mais importantes s√£o o **square** que ir√° definir se o gride ser√° de quadriculas ou de hexagonos, e o **what** que ir√° definir se iremos gerar pol√≠gonos, cantos ou centroides. Em nosso exemplo, vamos criar quadr√≠culas e hex√°gonos de 2000 metros de lado o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-quad) e Figura \@ref(fig:fig-vetor-hex)).
Podemos ainda utilizar as fun√ß√µes de filtros espaciais (Tabela \@ref(tab:tab-filtro-espacial)) para definir como iremos selecionar esses elementos para a √°rea de estudo. Aqui utilizamos a fun√ß√£o `sf::st_intersects()`.

```{r}
# quadriculas
rc_2019_sirgas2000_utm23s_grid <- sf::st_make_grid(x = rc_2019_sirgas2000_utm23s, cellsize = 2000, what = "polygons") %>%
  sf::st_as_sf() %>%
  dplyr::filter(sf::st_intersects(x = ., y = rc_2019_sirgas2000_utm23s, sparse = FALSE))

# centroides das quadriculas
rc_2019_sirgas2000_utm23s_grid_cent <- rc_2019_sirgas2000_utm23s %>% 
  sf::st_make_grid(cellsize = 2000, what = "centers") %>%
  sf::st_as_sf() %>%
  dplyr::filter(sf::st_intersects(x = ., y = sf::st_union(rc_2019_sirgas2000_utm23s_grid), sparse = FALSE))
```

```{r fig-vetor-quad, fig.align='center', fig.cap="Quadr√≠culas de 2000 metros e centroides para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_grid, col = NA, border = "red", lwd = 2, add = TRUE)
plot(rc_2019_sirgas2000_utm23s_grid_cent, pch = 20, add = TRUE)
```

```{r}
# hexagonos
rc_2019_sirgas2000_utm23s_hex <- rc_2019_sirgas2000_utm23s %>% 
  sf::st_make_grid(cellsize = 2000, square = FALSE) %>% 
  sf::st_as_sf() %>%
  dplyr::filter(sf::st_intersects(x = ., y = rc_2019_sirgas2000_utm23s, sparse = FALSE))

# centroides de hexagonos
rc_2019_sirgas2000_utm23s_hex_cent <- rc_2019_sirgas2000_utm23s %>% 
  sf::st_make_grid(cellsize = 2000, square = FALSE, what = "centers") %>% 
  sf::st_as_sf() %>% 
  dplyr::filter(sf::st_intersects(x = ., y = sf::st_union(rc_2019_sirgas2000_utm23s_hex), sparse = FALSE))
```

```{r fig-vetor-hex, fig.align='center', fig.cap="Hex√°gonos de 2000 metros e centroides para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_hex, col = NA, border = "red", lwd = 2, add = TRUE)
plot(rc_2019_sirgas2000_utm23s_hex_cent, pch = 20, add = TRUE)
```

##### Uni√£o ("dissolver")

Como vimos na se√ß√£o xx, a **agrega√ß√£o por atributos** podemos dissolver as geometrias de pol√≠gonos no mesmo grupo pelos valores da tabela de atributos, onde, naquele exemplo, contabilizamos quantas nascentes h√° por cada pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

Nesta se√ß√£o, vamos utilizar a fun√ß√£o `sf::st_union()` para **unir diversas fei√ß√µes em uma s√≥**, dissolvendo os limites entre elas. Vamos utilizar de exemplo os buffers que criamos a partir dos pontos aleat√≥rios (Figura \@ref(fig:fig-vetor-uniao)).

```{r}
# uniao
rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao <- sf::st_union(rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer)
```

```{r fig-vetor-uniao, fig.align='center', fig.cap="Uni√£o - dissolu√ß√£o - dos buffers criados a partir de pontos aleat√≥rios para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
```

##### Recorte ("clipar")

O recorte realiza um **subconjunto espacial** envolvendo dois objetos espaciais. O recorte √© **aplicado somente a linhas e pol√≠gonos**, ou seja, usaremos linhas e pol√≠gonos para recortar linhas ou pol√≠gonos. Esse recorte pode ser realizado de tr√™s formas: 1) **intersec√ß√£o** (subconjunto das geometrias sobrepostas entre os dois objetos), 2) **diferen√ßa** (subconjunto das geometrias do primeiro objeto sem sobreposi√ß√£o com o segundo objeto), e 3) **diferen√ßa sim√©trica** (apenas as geometrias n√£o sobrepostas entre os dois objetos). Respectivamente para cada uma dessas opera√ß√µes temos fun√ß√µes espec√≠ficas: `sf::st_intersection()`, `sf::st_difference()` e `sf::st_sym_difference()`.

Para nosso exemplo, faremos o recorte da hidrogradia em rela√ß√£o aos buffers criados para os 30 pontos aleat√≥rios em Rio Claro/SP. Primeiramente, iremos fazer o recorte para dentro dos buffers com a fun√ß√£o `sf::st_intersection()` (Figura \@ref(fig:fig-vetor-interseccao)).

```{r}
# recorte - interseccao
rc_hid_interseccao <- sf::st_intersection(x = rc_hid, y = rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig:fig-vetor-interseccao, fig.align='center', fig.cap="Recorte da hidrografia para dentro dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(rc_hid_interseccao$geometry, col = "blue", add = TRUE)
```

Para nosso segundo exemplo, realizamos o recorte da hidrogradia em rela√ß√£o aos buffers, mas agora para fora dos buffers utilizando a fun√ß√£o `sf::st_difference()` (Figura \@ref(fig:fig-vetor-interseccao)).

```{r}
# recorte - diferenca
rc_hid_diferenca <- sf::st_sym_difference(x = rc_hid, y = rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig-vetor-difereca, fig.align='center', fig.cap="Recorte da hidrografia para fora dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_2019_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(rc_hid_diferenca$geometry, col = "blue", add = TRUE)
```

##### Transforma√ß√µes de tipo

Esse t√≥pico possui muitas funcionalidades, que s√£o exploradas no t√≥pico "5.2.7 Type transformations" de @lovelace-etal-2019. Aqui, nosso interesse principal √© em rela√ß√£o √† transforma√ß√£o dos tipos de objetos espaciais da classe **sf**: `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`, para `POINT`, `LINESTRING` e `POLYGON`. Muitas vezes as fei√ß√µes de nossos objetos, i.e., as linhas da tabela de atributos, est√£o agrupadas em apenas um linha da tabela. Quando o objeto espacial est√° nesse formato, geralmente em alguma classe dessas (`MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`), n√£o temos como realizar opera√ß√µes para cada fei√ß√£o, e precisamos separ√°-las cada uma em uma linha para que opera√ß√µes como o c√°lculo de comprimento ou √°rea seja poss√≠vel para cada fei√ß√£o (veja se√ß√£o xx).

Dessa forma, podemos utilizar a fun√ß√£o `sf::st_cast()` para fazer essas transforma√ß√µes e atribuir cada fei√ß√£o √† uma linha da tabela de atributos. Como exemplo, vamos separar os fragmentos de floresta e calcular a √°rea para cada fei√ß√£o em hectares (Figura \@ref(fig:fig-vetor-tipo)).

```{r}
# transformacao de tipo
rc_cob_floresta_polygon <- rc_cob_floresta %>% 
  sf::st_cast("POLYGON") %>% 
  dplyr::mutate(area_ha = sf::st_area(.)/1e4 %>% round(2))
```

```{r fig-vetor-tipo, fig.align='center', fig.cap="Recorte da hidrografia para fora dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
plot(rc_2019_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(rc_cob_floresta_polygon["area_ha"], col = viridis::viridis(100),  add = TRUE)
```

#### Raster

As **opera√ß√µes geom√©tricas em rasters** envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels subjacentes e atribuir novos valores, geralmente aumentando ou diminuindo o tamanho dos pixels. Essas opera√ß√µes permitem **alinhar rasters de diversas fontes**, fazendo com que compartilhem uma correspond√™ncia entre pixels, permitindo que eles sejam processados todos juntos, ou simplesmente permita a realiza√ß√£o de an√°lises que demorariam muito, caso os rasters possuam um tamanho de pixel muito pequeno. Importante frisar que essas opera√ß√£o funcionam para as tr√™s classes dos objetos raster: `RasterLayer`, `RasterBrick` e `RasterStack`.

Para exemplificar as opera√ß√µes geom√©tricas com rasters, vamos utilizar os dados de para o munic√≠pio de Rio Claro/SP e bioclim√°ticos para o mundo.

##### Agrega√ß√£o

Na **agrega√ß√£o de rasters** iremos aumentar o tamanho dos pixels (diminuindo a resolu√ß√£o), agregando os valores dos pixels em um pixel maior. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::aggregate()`, que possui tr√™s argumentos: **x** corresponde ao objeto raster de entrada, **fact** √© o fator de agrega√ß√£o e corresponde ao n√∫mero que definir√° como novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de agrega√ß√£o de 10, far√° com o novo raster tenha a resolu√ß√£o de 900 m) e **fun** √© a fun√ß√£o utilizada para realizar a agrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-agregacao)).

```{r}
# agregacao - aumentar o tamanho do pixel
ra_rc_sirgas2000_utm23s_agre_media <- raster::aggregate(x = ra_rc_sirgas2000_utm23s, fact = 10, fun = "mean")
ra_rc_sirgas2000_utm23s_agre_media
```

```{r fig-raster-agregacao, fig.align='center', fig.cap="Agrega√ß√£o (aumento do pixel para 900 metros) utilizando a m√©dia para o raster de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_sirgas2000_utm23s_agre_media, col = viridis::viridis(10))
plot(rc_2019_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

##### Desagrega√ß√£o

De modo contr√°tio, na **desagrega√ß√£o de rasters** iremos diminuir o tamanho dos pixels (aumentar a resolu√ß√£o), preenchendo com novos valores. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::desaggregate()`, que assim como a fun√ß√£o anterior, possui tr√™s argumentos: **x** corresponde ao objeto raster de entrada, **fact** √© o fator de desagrega√ß√£o e corresponde ao n√∫mero que definir√° como novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de desagrega√ß√£o de 2, far√° com o novo raster tenha a resolu√ß√£o de 9 m) e **method** √© a fun√ß√£o utilizada para realizar a desagrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-desagregacao)).

```{r}
# desagregacao - diminuir o tamanho do pixel
ra_rc_desg_bil <- raster::disaggregate(x = ra_rc_sirgas2000_utm23s, fact = 10, method = "bilinear")
ra_rc_desg_bil
```

```{r fig-raster-desagregacao, fig.align='center', fig.cap="Desagrega√ß√£o (diminui√ß√£o do pixel para 9 metros) utilizando o m√©todo bilinear para o raster de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_desg_bil, col = viridis::viridis(10))
plot(rc_2019_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

##### Alinhamento de rasters

Muitas vezes queremos ir al√©m de ajustar o tamanho do pixel e ajustar as camadas rasters, ajustando tamb√©m a **extens√£o, n√∫mero e origem dos pixels** para v√°rias camadas rasters, principalmente se precisamos criar objetos das classes `RasterBrick` ou `RasterStack`. Dessa forma, podemos utilizar a fun√ß√£o `raster::compareRaster()` para comparar os rasters em rela√ßao a extens√£o, n√∫mero de linhas e colunas, proje√ß√£o, resolu√ß√£o e origem (ou um subconjunto dessas compara√ß√µes).

Podemos utilizar a fun√ß√£o `raster::resample()` para fazer esse alinhamento, ou ainda a fun√ß√£o `gdalUtils::align_rasters()`. Para nosso exemplo, vamos ajustar uma camada bioclim√°tica (BIO01) √† camada de eleva√ß√£o para Rio Claro/SP (Figura \@ref(fig:fig-raster-reamostragem)).

```{r}
# desagregacao - diminuir o tamanho do pixel
st_rc <- raster::resample(x = st$bio01, y = ra_rc, method = "bilinear")
st_rc
```

```{r fig-raster-reamostragem, fig.align='center', fig.cap="Reamostragem (alinhamento dos raster) utilizando o m√©todo bilinear para alinhar o raster bioclim√°tico ao de eleva√ß√£o para Rio Claro/SP."}
raster::plot(st_rc, col = viridis::viridis(10))
plot(rc_2019_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

#### Intera√ß√µes raster-vetor

Por fim, podemos ainda fazer opera√ß√µes da **intera√ß√£o entre objetos vetoriais e raster**, como **ajustes da extens√£o** do raster para vetores (corte e m√°scara), **extra√ß√£o dos valores** dos pixels para vetores (pontos, linhas e pol√≠gonos), e **estat√≠sticas zonais** dos valores dos pixels dos raster para um vetor (pol√≠gonos).

##### Cortes e m√°scaras

Muitas vezes precisamos **ajustar o tamanho** de um objeto raster √† uma √°rea menor de interesse, geralmente definido por um objeto vetorial. Para realizar essa opera√ß√£o, dispomos de duas fun√ß√µes: `raster::crop()` e `raster::mask()`, sendo que ambos os objetos precisam estar no mesmo CRS. 

A primeira delas ajusta o raster √† extens√£o do vertor. Como exemplo, vamos retomar o raster de eleva√ß√£o original baixado do site xx e importado na se√ß√£o xx (). Primeiramente, vamos usar a fun√ß√£o `raster::crop()` para ajustar esse raster √† extens√£o do limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte)).

```{r}
# crop - adjuste da extens√£o
ra_rc_crop <- raster::crop(ra, rc_2019)
```

```{r fig-raster-corte, fig.align='center', fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para a extens√£o de Rio Claro/SP."}
raster::plot(ra_rc_crop, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster ao limite do munic√≠pio de Rio Claro/SP, vamos usar a fun√ß√£o `raster::mask()`. √â importante notar que essa fun√ß√£o preenche com `NAs` os pixels que est√£o fora do limite do pol√≠gono e n√£o ajusta a extens√£o (Figura \@ref(fig:fig-raster-corte)).

```{r}
# mask - adjuste ao limite
ra_rc_mask <- raster::mask(ra, rc_2019)
```

```{r fig-raster-mascara, fig.align='center', fig.cap="Ajuste do raster de eleva√ß√£o para ao limite do Rio Claro/SP."}
raster::plot(ra_rc_mask, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster √† extens√£o e ao limite do munic√≠pio de Rio Claro/SP, precisamos utilizar conjuntamente as fun√ß√µes `raster::crop()` e `raster::mask()` (Figura \@ref(fig:fig-raster-corte-mascara)).

```{r}
# crop e mask - ajuste da extens√£o e do limite
ra_rc_crop_mask <- ra %>% 
  raster::crop(rc_2019) %>% 
  raster::mask(rc_2019)
```

```{r fig-raster-corte-mascara, fig.align='center', fig.cap="Ajuste da extens√£o e do limite do raster de eleva√ß√£o para Rio Claro/SP."}
raster::plot(ra_rc_crop_mask, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A fun√ß√£o `raster::mask()` possui um argumento chamado **inverse**, que cria uma m√°scara inversa ao limite, preenchendo com `NA` o pixels internos ao limite do pol√≠gono, como podemos ver para o raster de eleva√ß√£o e o limite de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte-mascara-inverso)).

```{r}
# crop e mask inversa - ajuste da extens√£o e do limite inverso
ra_rc_crop_mask_inv <- ra %>% 
  raster::crop(rc_2019) %>% 
  raster::mask(rc_2019, inverse = TRUE)
```

```{r fig-raster-corte-mascara-inverso, fig.align='center', fig.cap="Opera√ß√£o focal para uma janela de 3x3 pixels calculando o desvio padr√£o de eleva√ß√£o para Rio Claro/SP."}
# plot
raster::plot(ra_rc_crop_mask_inv, col = viridis::viridis(10))
plot(rc_2019$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

##### Extra√ß√£o

A intera√ß√£o entre raster-vetor de **extra√ß√£o** √© o processo que identifica e retorna valores associados de pixels de um raster com base em um objeto vetorial. √â uma opera√ß√£o extramamente comum em an√°lises geogr√°ficas, principalmente para associar valores de raster ambientais (cont√≠nuos ou categ√≥ricos) √† pontos de ocorr√™ncia ou amostragem. Os valores retornados ir√£o depender do tipo vetor (pontos, linhas ou pol√≠gonos) e de argumentos da fun√ß√£o `raster::extract()` que alteram o funcionamento da extra√ß√£o.

Em nosso exemplo, vamos extrar os valores de eleva√ß√£o do raster de eleva√ß√£o para as nascentes do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-extracao)).

```{r}
# extracao
rc_nas_ele <- rc_nas %>% 
  dplyr::mutate(elev = raster::extract(x = ra_rc_sirgas2000_utm23s, y = .))
```

```{r fig-raster-extracao2, fig.align='center', fig.cap="Extra√ß√£o dos valores de eleva√ß√£o para as nascentes de Rio Claro/SP."}
# plot
plot(rc_nas_ele["elev"], pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

Al√©m da extra√ß√£o dos valores totais, podemos resumir os valores dos pixels com a mesma opera√ß√£o de extra√ß√£o, utilizando ainda a fun√ß√£o `raster::extract()`, mas utilizando uma fun√ß√£o para resumir os valores dos pixels para um pol√≠gono, opera√ß√£o tamb√©m denominada de **estat√≠stica zonal**. J√° vimos que ela pode ser realizada entre rasters na se√ß√£o xx, mas aqui a realizaremos para rasters e vetores. 

Para o exemplo, vamos calcular a eleva√ß√£o m√©dia dos valores de eleva√ß√£o para os hex√°gonos que criamos para todo o limite de Rio Claro/SP( Figura \@ref(fig:fig-raster-zonas)).

```{r}
# extracao - estatistica por zonas
rc_2019_sirgas2000_utm23s_hex_alt <- rc_2019_sirgas2000_utm23s_hex %>% 
  dplyr::mutate(elev_mean = raster::extract(x = ra_rc_sirgas2000_utm23s, y = rc_2019_sirgas2000_utm23s_hex, fun = mean, na.rm = TRUE))
```

```{r fig-raster-zonas, fig.align='center', fig.cap="Extra√ß√£o dos valores de eleva√ß√£o e resumo pela m√©dia para os hex√°gonos de Rio Claro/SP."}
# plot
plot(rc_2019_sirgas2000_utm23s_hex_alt["elev_mean"], pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

#### Convers√µes raster-vetor

Por fim, podemos ainda fazer opera√ß√µes de **convers√£o entre objetos vetoriais para raster e vice-versa**. Nessas opera√ß√µes, podemos resumir ou transformar objetos vetoriais (pontos, linhas ou pol√≠gonos) para rasters, escolhendo um raster previamente existente, processo denominado **rasteriza√ß√£o**. Tamb√©m podemos realizar o processo inverso, i.e., transformar o raster em um vetor, podendo esse vetor ser um gride pontos, linhas ou pol√≠gonos, opera√ß√£o chamada de **vetoriza√ß√£o**.

##### Rasteriza√ß√£o

A convers√£o de vetor para raster pode ser realizada de **pontos para rasters**. Nesse processo, podemos utilizar uma fun√ß√£o para **resumir os dados pontuais** para os pixels do raster que iremos criar. Para essa opera√ß√£o, podemos utilizar a fun√ß√£o `raster::rasterize()`, com o argumento **x** sendo o vetor de entrada, **y** o raster base, **field** a coluna ou campo da tabela de atributos do ojeto vetorial para os quais os valores ser√£o utilizados e **fun** a fun√ß√£o utilizada para agrega√ß√£o dos dados.

Aqui, vamos contabilizar a quantidade de nascentes por pixel, utilizando como base o raster para o qual mudamos a resolu√ß√£o para 900 metros (\@ref(fig:fig-raster-rasterizacao-pontos)).

```{r}
# rasterizar pontos
rc_nas_rasterizacao <- raster::rasterize(x = rc_nas, y = ra_rc_sirgas2000_utm23s_agre_media, field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-pontos, fig.align='center', fig.cap="Rasteriza√ß√£o das nascentes, com a opera√ß√£o de contabiliza√ß√£o para Rio Claro/SP."}
raster::plot(rc_nas_rasterizacao, col = viridis::viridis(10))
plot(rc_nas$geometry, pch = 20, cex = .5, col = adjustcolor("gray", .5), add = TRUE)
```

Al√©m de pontos, podemos tamb√©m rasterizar linhas. Aqui vamos contanilizar as linhas da hidrografia simplificada para Rio Claro/SP (Figura \@ref(fig:fig-raster-rasterizacao-linhas)).

```{r}
# rasterizar linhas
rc_hid_rasterizacao <- raster::rasterize(x = rc_hid_simplificado,
                                         y = ra_rc_sirgas2000_utm23s_agre_media,
                                         field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-linhas, fig.align='center', fig.cap="Rasteriza√ß√£o da hidrografia, com a opera√ß√£o de contabiliza√ß√£o para Rio Claro/SP."}
raster::plot(rc_hid_rasterizacao, col = viridis::viridis(10))
plot(rc_hid_simplificado$geom, col = "gray", add = TRUE)
```

Podemos ainda rasterizar pol√≠gonos, de modo que cada pixel do raster a ser criado ir√° receber o valor da tabela de atributos, ou uma an√°lise pelo vizinho mais pr√≥ximo no caso de um campo categ√≥rico, como a cobertura da terra, que tamb√©m vai depender da resolu√ß√£o do raster base e do tamanho da fei√ß√£o do pol√≠gono. Para nosso exemplo, antes de criar o raster vamos transforma a coluna de classe de cobertura da terra em `factor` (Figura \@ref(fig:fig-raster-rasterizacao-poligonos)). Entretanto, essa opera√ß√£o tente a demorar muito no caso de pol√≠gonos, sendo que dois pacotes tentar a acelerar esse processo (*fasterize* e *gdalUtils*), com suas fun√ß√µes para essa opera√ß√£o sendo: `fasterize::fasterize()` e `gdalUtils::gdal_rasterize()`.

```{r}
# rasterizar poligonos
rc_cob_rasterizacao <- rc_cob %>% 
  dplyr::mutate(classe = as.factor(CLASSE_USO)) %>% 
  raster::rasterize(x = ., y = ra_rc_sirgas2000_utm23s_agre_media, field = "classe")
```

```{r fig-raster-rasterizacao-poligonos, fig.align='center', fig.cap="Opera√ß√£o focal para uma janela de 3x3 pixels calculando o desvio padr√£o de eleva√ß√£o para Rio Claro/SP."}
raster::plot(rc_cob_rasterizacao, col = viridis::viridis(10))
plot(rc_cob$geom, add = TRUE)
```

##### Vetoriza√ß√£o

A opera√ß√£o inversa √† rasteriza√ß√£o √© a **vetoriza√ß√£o**, na qual iremos converter um raster em um vetor, sendo que esse vetor ir√° receber os valores dos pixels. O vetor em quest√£o pode ser **pontos** (geralmente um gride de pontos), **linhas** (geralmente isolinhas ou linhas de contorno), ou **pol√≠gonos** (geralmente esse pol√≠gonos sendo dissolvidos). Existem fun√ß√µes espec√≠ficas para cada uma dessas convers√µes, sendo elas: `raster::rasterToPoints()`, `raster::rasterToContour()` e `raster::rasterToPolygons()`, respectivamente. Para a √∫ltima fun√ß√£o, ainda dispomos de uma alternativa mais veloz `spex::polygonize()`.

Em nosso exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP, criando um gride de pontos, sendo os pontos os centroides de cada pixels \@ref(fig:fig-raster-vetorizacao-pontos)).

```{r}
# vetorizacao de pontos
ra_rc_sirgas2000_utm23s_agre_media_pontos <- raster::rasterToPoints(ra_rc_sirgas2000_utm23s_agre_media, spatial = TRUE) %>% 
  sf::st_as_sf()
```

```{r fig-raster-vetorizacao, fig.align='center', fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando pontos para Rio Claro/SP."}
raster::plot(ra_rc_sirgas2000_utm23s_agre_media, col = viridis::viridis(10, alpha = .8))
plot(ra_rc_sirgas2000_utm23s_agre_media_pontos, pch = 20, cex = .7, main = FALSE, add = TRUE)
plot(rc_2019_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Nesse exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP novamente, mas agora criando isolinhas, de modo que entre as linhas os pixels ter√£o os valores mostrados nas linhas \@ref(fig:fig-raster-vetorizacao-linhas)).

```{r}
# vetorizacao de linhas
ra_rc_sirgas2000_utm23s_agre_media_linhas <- raster::rasterToContour(x = ra_rc_sirgas2000_utm23s_agre_media) %>% 
  sf::st_as_sf()
```

```{r fig-raster-vetorizacao-linhas, fig.align='center', fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando isolinhas para Rio Claro/SP."}
raster::plot(ra_rc_sirgas2000_utm23s_agre_media, col = viridis::viridis(10, alpha = .8))
contour(ra_rc_sirgas2000_utm23s_agre_media, labcex = 1, main = FALSE, add = TRUE)
plot(rc_2019_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Por fim, vamos vetorizar o raster de cobertura da terra criado anteriormente para Rio Claro/SP, criando pol√≠gonos n√£o dissolvendo e dissolvidos \@ref(fig:fig-raster-vetorizacao-poligonos)).

```{r}
# vetorizacao de poligonos
rc_cob_rasterizacao_poligonos <- raster::rasterToPolygons(rc_cob_rasterizacao) %>% 
  sf::st_as_sf()

# vetorizacao de poligonos dissolvendo
rc_cob_rasterizacao_poligonos_dissolvidos <- raster::rasterToPolygons(rc_cob_rasterizacao, dissolve = TRUE) %>% 
  sf::st_as_sf()
```

```{r fig-raster-vetorizacao-poligonos, fig.align='center', fig.cap="Vetoriza√ß√£o do raster de cobertura da terra para Rio Claro/SP, n√£o dissolvendo e dissolvendos os pol√≠gonos."}
par(mfrow = c(1, 2))
raster::plot(rc_cob_rasterizacao, col = viridis::viridis(10))
plot(rc_cob_rasterizacao_poligonos$geometry, col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)

raster::plot(rc_cob_rasterizacao, col = viridis::viridis(10))
plot(rc_cob_rasterizacao_poligonos_dissolvidos$geometry, col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)
par(mfrow = c(1, 1))
```

## Visualiza√ß√£o de dados geogr√°ficos - Mapas

Um dos pontos finais de toda a an√°lise envolvendo a manipula√ß√£o de dados geogr√°ficos ser√° imprescind√≠vel a apresenta√ß√£o de um mapa com as informa√ß√µes de interesse espacializadas. Mas antes, √© necess√°rio ter conhecimento de alguns elementos m√≠nimos para a composi√ß√£o de um mapa informativo. Al√©m disso, o R nos permite criar alguns tipos diferentes de mapas com algumas caracter√≠sticas a depender do tipo de dado, anima√ß√£o ou intera√ß√£o, sendo os mais comuns os est√°ticos, mas podemos por vezes para melhor apresenta√ß√£o, criar mapas animados e/ou interativos. Por fim, veremos as melhores formas de exportar mapas para diferentes formatos.

### Elementos de um mapa

Um mapa pode ser composto de v√°rios elementos, tendo estes os intuito de auxiliar a visualiza√ß√£o e entendimento de seu conte√∫do. Apesar disso, nem todos os elementos necessitam estar presentes em todos os layouts, sendo que os mesmos devem atendem √† necessidade das representa√ß√µes, podendo ser muitas vezes omitidos.

Os principais elementos de um mapa geralmente s√£o compostos por: **mapa principal** (ocupando quase toda a √°rea da figura), **mapa secund√°rio** (geralmente muito menor que o mapa principal e com o intuito de mostrar a localiza√ß√£o do mapa principal num contexto mais amplo, como pa√≠s ou continente), **t√≠tulo** (para resumir o intuito do mapa), **legenda** (apresentando as informa√ß√µes detalhadas das classes ou escala de valores, geralmente identificando as cores e/ou texturas), **barra de escala** (representando quantas unidades do mapa representam do mundo real), **indicador de orienta√ß√£o (Norte)** (indicando o norte geogr√°fico, podendo ser representado por uma flecha, b√∫ssula ou compasso), **gride de coordenadas** (coordenadas presentes nas laterais), **descri√ß√£o do CRS** (indicando qual o CRS), **informa√ß√µes de origem** (informa√ß√µes sobre a fonte dos dados representados no mapa), al√©m de **outros elementos auxiliares** (como elementos textuais e figuras extras).

Podemos visualizar esses elementos resumidos na Figura \@ref(fig:fig-mapa-elementos).

```{r fig-mapa-elementos, fig.align='center', fig.cap="Principais elementos de um mapa.", out.width="100%", echo=FALSE}
library(tmap)
library(geobr)
library(rnaturalearth)
library(grid)

sa <- rnaturalearth::ne_countries(continent = "South America")
br <- rnaturalearth::ne_countries(country = "Brazil")
bi <- geobr::read_biomes(showProgress = FALSE) %>%
  dplyr::filter(name_biome != "Sistema Costeiro")

sa_map <- tm_shape(sa) +
  tm_polygons() +
  tm_shape(br) +
  tm_polygons(col = "gray50")

tm_shape(bi, bbox = c(-74, -35, -27, 10)) +
  tm_polygons(col = "name_biome",
              pal = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"),
              border.col = "black",
              title = "Legenda") +
  tm_compass() +
  tm_scale_bar(text.size = .6) +
  tm_graticules(lines = FALSE) +
  tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
  tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
  tm_layout(title = "Biomas do Brasil",
            title.position = c(.25, .95),
            title.size = 1.8,
            title.fontface = "bold",
            legend.frame = TRUE,
            legend.position = c("left", "bottom"),
            legend.title.fontface = "bold")
print(sa_map, vp = viewport(.815, .875, wi = .2, he = .2))
```

### Principais pacotes para composi√ß√£o de mapas

H√° uma grande quantidade de pacotes para a composi√ß√£o de mapas no R. Aqui listamos os que consideramos principais (Tabela \@ref(tab:tab-mapa-pacotes)).

```{r tab-mapa-pacotes, echo=FALSE}
knitr::kable(tibble::tibble(
  Pacote = c("[ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html)", 
             "[ggspatial](https://cran.r-project.org/web/packages/ggspatial/index.html)", 
             "[ggmap](https://cran.r-project.org/web/packages/ggmap/index.html)", 
             "[tmap](https://cran.r-project.org/web/packages/tmap/index.html)", 
             "[leaflet](https://cran.r-project.org/web/packages/leaflet/index.html)",
             "[plotly](https://cran.r-project.org/web/packages/plotly/index.html)",
             "[cartography](https://cran.r-project.org/web/packages/cartography/index.html)",
             "[googleway](https://cran.r-project.org/web/packages/googleway/index.html)",
             "[mapview](https://cran.r-project.org/web/packages/mapview/index.html)",
             "[rasterVis](https://cran.r-project.org/web/packages/rasterVis/index.html)",
             "[cartogram](https://cran.r-project.org/web/packages/cartogram/index.html)",
             "[geogrid](https://cran.r-project.org/web/packages/geogrid/index.html)",
             "[geofacet](https://cran.r-project.org/web/packages/geofacet/index.html)",
             "[globe](https://cran.r-project.org/web/packages/globe/index.html)",
             "[linemap](https://cran.r-project.org/web/packages/linemap/index.html)"), 
  Descri√ß√£o = c("Cria visualiza√ß√µes de dados elegantes usando a gram√°tica de gr√°ficos",
                "Estrutura de dados espaciais para ggplot2",
                "Visualiza√ß√£o espacial com ggplot2",
                "Mapas tem√°ticos",
                "Cria mapas da web interativos com a biblioteca JavaScript 'Leaflet'",
                "Cria gr√°ficos interativos da Web por meio de 'plotly.js'",
                "Cartografia tem√°tica",
                "Acessa APIs do Google Maps para recuperar dados e mapas de plotagem",
                "Visualiza√ß√£o interativa de dados espaciais em R",
                "M√©todos de visualiza√ß√£o para dados raster",
                "Crie cartogramas com R",
                "Transforme pol√≠gonos geoespaciais em grades regulares ou hexagonais",
                "'ggplot2' Utilit√°rios de faceta√ß√£o para dados geogr√°ficos",
                "Plot 2D and 3D Views of the Earth, Including Major Coastline",
                "Line Maps")),
  caption = "Principais pacotes para composi√ß√£o de mapas no R.")
```

### Mapas est√°ticos

Mapas est√°ticos s√£o mapas simples e fixos para visualiza√ß√£o de dados, sendo o tipo mais comum de sa√≠da visual. No in√≠cio da composi√ß√£o de mapas no R, esse era o √∫nico tipo de mapa que a linguagem permitia produzir, principalmente utilizando o pacote sp (Pebesma e Bivand 2005). No entanto, com o advento de ferramentas de visualiza√ß√£o din√¢mica para o R, como componentes de HTML, os mapas puderam ser compostos de forma din√¢mica.

Neste t√≥pico abordaremos fun√ß√µes simples para composi√ß√£o de mapas, como o `plot()`, al√©m de pacotes para composi√ß√£o de mapas mais elaborados, como os pacotes ggplot (Wickham 2016) e tmap (Tennekes 2018).

#### Fun√ß√£o `plot()`

A fun√ß√£o gen√©rica `plot()` √© a maneira mais r√°pida de compor mapas est√°ticos utilizando objetos espaciais vetoriais e raster, funcionando para ambos pacotes que apresentamos anteriormente (sf e raster). Apesar da simplicidade, essa fun√ß√£o geralmente tende a criar mapas com relativa velocidade, nos auxiliando principalmente em fases iniciais de desenvolvimento de um projeto, por exemplo. Essa fun√ß√£o oferece dezenas de argumentos em base R, permitindo alguns ajustes limitados, com resultados bastante interessantes.

Como dito anteriormente, a fun√ß√£o `plot()` vai funcionar diferentemente dependendo da classe do objeto espacial. Para objetos espaciais sf, a fun√ß√£o vai plotar um mapa para cada coluna da tabela de atributos. Vamos usar de exemplo nosso mapa de biomas mostrado como exemplo de elementos principais de um mapa, podendo inclusive selecionar apenas a coluna de caracter√≠sticas geoespaciais (`geom`).

Primeiramente, vamos fazer o download dos dados de limites de biomas, retirando os sistemas costeiros, usando o pacote geobr.

```{r}
# biomas
biomas <- geobr::read_biomes(showProgress = FALSE) %>%
  dplyr::filter(name_biome != "Sistema Costeiro")
biomas
```

Agora, quando utilizamos a fun√ß√£o `plot()` para um objeto da classe sf, temos os tr√™s mapas indicando cada coluna da tabela de atritos (Figura \@ref(fig:fig-vetor-map-plot)).

```{r fig-vetor-map-plot, fig.align='center', fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto sf.", out.width="100%"}
plot(biomas)
```

Selecionando as colunas desse objeto, podemos escolher a informa√ß√£o da coluna que queremos plotar, por exemplo, apenas a geometria. Al√©m disso, podemos acrescentar os argumentos **col** para colorir e **main** para o t√≠tulo, al√©m dos argumentos **axes** e **graticule** para adicionar as coordenadas e quadr√≠culas. A legenda pode ser adicionada com a fun√ß√£o `legend()` (Figura \@ref(fig:fig-vetor-map-plot-selecao)).

```{r fig-vetor-map-plot-selecao}
plot(biomas$geom, 
     col = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"), 
     main = "Biomas do Brasil", axes = TRUE, graticule = TRUE)
legend(x = -75, y = -20, pch = 15, cex = .7, pt.cex = 2.5, legend = biomas$name_biome, 
       col = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"))
```

Para a classe dos objetos espaciais raster, a fun√ß√£o `plot()` vai plotar um mapa para o tipo `RasterLayer` e quantos mapas houverem no objeto e couberem no espa√ßo de plot para `RasterBrick` e `RasterStack`. Al√©m disso, para essa classe, essa fun√ß√£o prov√™ tamb√©m uma escala de cores autom√°tica dos valores e uma legenda de cor 'terrain'. Vamos fazer o mapa da camada raster de eleva√ß√£o para os limites do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-layer-mapa)).

```{r fig-raster-layer-mapa, fig.align='center', fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster.", out.width="100%"}
plot(ra_rc)
plot(rc_2019[1], col = NA, lwd = 2, add = TRUE)
```

Agora vamos plotar objetos da classe `RasterStack`, alterando a cor para 'viridis', usando a fun√ß√£o `viridis()` do pacote hom√¥nimo. Vamos fazer o mapa de duas camadas raster bioclim√°ticas para o mundo (Figura \@ref(fig:fig-raster-stack-mapa)).

```{r fig-raster-stack-mapa, fig.align='center', fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster.", out.width="100%"}
plot(st[[1:2]], col = viridis::viridis(10))
```

Para exportar esses mapas podemos utilizar as fun√ß√µes `png()` ou `pdf()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, √† t√≠tulo de exemplo, a √∫ltima figura.

```{r, eval=FALSE}
# diretorio
dir.create(here::here("dados", "mapas"))

# exportar mapa
png(filename = here::here("dados", "mapas", "elev_rc.png"), width = 20, height = 20, units = "cm", res = 300)
plot(ra_rc)
plot(rc_2019[1], col = NA, lwd = 2, add = TRUE)
dev.off()
```

#### Pacotes *ggplot2* e *ggspatial*

Como discutimos no cap√≠tulo xx sobre gr√°ficos, o pacote *ggplot2* utiliza a gram√°tica de gr√°ficos para composi√ß√£o de figuras no R (Wilkinson 1999, Wickhan 2016). Para cada classe de objeto geogr√°fico h√° fun√ß√µes espec√≠ficas para os dados: para objetos sf `geom_sf()` e para objetos raster `geom_raster()`.

Al√©m do pacote *ggplot2*, podemos utilizar o pacote ggspatial para acrescentar elementos geogr√°ficos como a **barra de escala** e o **indicador de orienta√ß√£o (Norte)**, atrav√©s das fun√ß√µes `annotation_scale()` e `annotation_north_arrow()`, respectivamente, al√©m de outras fun√ß√µes espec√≠ficas que n√£o abordaremos aqui.

A estrutura de composi√ß√£o das fun√ß√µes do pacote *ggplot2* vai funcionar parecido com a estrutura√ß√£o de gr√°ficos j√° vista no cap√≠tulo XX, de modo que a cada fun√ß√£o iremos utilizando o sinal de `+` para acrescentar outra camada. Iremos indicar os dados com a fun√ß√£o `ggplot()` e a coluna da tabela de atributos que queremos representar com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_sf()` para indicar que trata-se de um objeto sf.

Al√©m dessas fun√ß√µes, podemos ainda a fazer altera√ß√µes nos mapas atrav√©s das fun√ß√µes: `scale_*()` que vai alterar as caracter√≠sticas indicadas em `aes()`, `coord_*()` que vai alterar constru√ß√£o do mapa em rela√ß√£o √† coordenadas, `facet_*()` que altera a disposi√ß√£o de v√°rios mapas, e `theme_*()` e `theme()` que ir√£o alterar caracter√≠sticas relacionadas ao tema, como fontes e legenda. Podemos ainda utilizar as fun√ß√µes `annotate()` para adicionar textos e `labs()` para alterar o t√≠tulo principal, da legenda e dos eixos.

Vamos demonstrar esse o funcionamento atrav√©s do c√≥digo que compos o mapa de biomas, apresentado no inicial  dessa se√ß√£o (Figura \@ref(fig:fig-vetor-mapa-ggplot2)).

```{r fig-vetor-mapa-ggplot2, fig.align='center', fig.cap="Mapa vetorial com o pacote *ggplot2*.", out.width="100%"}
# dados
bi <- geobr::read_biomes(showProgress = FALSE) %>%
  dplyr::filter(name_biome != "Sistema Costeiro")

# mapa
map_biomas_ggplot2 <- ggplot(data = bi) +
  aes(fill = name_biome) +
  geom_sf(color = "black") +
  scale_fill_manual(values = c("darkgreen", "orange", "orange4", 
                               "forestgreen", "yellow", "yellow3")) +
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "br", which_north = "true",
                         pad_x = unit(0, "cm"), pad_y = unit(.5, "cm"),
                         style = north_arrow_fancy_orienteering) +
  annotate(geom = "text", label = "CRS: SIRGAS2000/Geo", x = -38, y = -31, size = 2.5) +
  annotate(geom = "text", label = "Fonte: IBGE (2019)", x = -39, y = -32.5, size = 2.5) +
  labs(title = "Biomas do Brasil", fill = "Legenda", x = "Longitude", y = "Latitude") +
  theme_bw() +
  theme(title = element_text(size = 15, face = "bold"),
        legend.title = element_text(size = 10, face = "bold"),
        legend.position = c(.15, .25),
        legend.background = element_rect(colour = "black"),
        axis.title = element_text(size = 10, face = "plain"))
map_biomas_ggplot2
```

Para objetos raster, o uso do pacote *ggplot2* para compor mapas requer um passo preliminar. Primeiramente, vamos criar um data frame com os dados do raster com as linhas sendo os pixels e as colunas sendo a coordenada central da longitude e latitude, al√©m dos valores de cada camada. E esse passo pode ser realizado com a fun√ß√£o `raster::rasterToPoints()`. 

Uma vez que temos esses dados organizados, podemos utilizar as fun√ß√µes `ggplot()` para indicar o data frame, e as colunas com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_raster()` para indicar que trata-se de um objeto raster. Al√©m dessas fun√ß√µes, podemos ainda utilizar as demais fun√ß√µes para alterar as caracter√≠sticas do mapa. Entretanto, devemos nos atentar para a fun√ß√£o `coord_*()` e escolher aquela que vai fazer a constru√ß√£o do mapa em rela√ß√£o √† coordenadas e resolu√ß√£o das c√©lulas.

Como exemplo, vamos compor o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-ggplot2)).

```{r fig-raster-mapa-ggplot2, fig.align='center', fig.cap="Mapa raster com o pacote *ggplot2*.", out.width="100%"}
# dados
ra_rc_da <- raster::rasterToPoints(ra_rc) %>% 
  tibble::as_tibble()
head(ra_rc_da)

# mapa
map_elev_rc_ggplot2 <- ggplot() +
  geom_raster(data = ra_rc_da, aes(x = x, y = y, fill = elevacao)) +
  geom_sf(data = rc_2019, color = "red", fill = NA, size = 1.3) +
  scale_fill_viridis_c() +
  coord_sf() +
  annotation_scale(location = "br",
                   pad_x = unit(.5, "cm"), pad_y = unit(.7, "cm"),) +
  annotation_north_arrow(location = "br", which_north = "true",
                         pad_x = unit(.4, "cm"), pad_y = unit(1.3, "cm"),
                         style = north_arrow_fancy_orienteering) +
  annotate(geom = "text", label = "CRS: WGS84/Geo", x = -47.51, y = -22.53, size = 3) +
  labs(title = "Eleva√ß√£o de Rio Claro/SP", fill = "Eleva√ß√£o (m)", x = "Longitude", y = "Latitude") +
  theme_bw() +
  theme(title = element_text(size = 15, face = "bold"),
        legend.title = element_text(size = 10, face = "bold"),
        legend.position = c(.2, .25),
        legend.background = element_rect(colour = "black"),
        axis.title = element_text(size = 10, face = "plain"),
        axis.text.y = element_text(angle = 90, hjust = .4))
map_elev_rc_ggplot2
```

Para exportar mapas criados com o pacote *ggplot2*, podemos utilizar a fun√ß]ao `ggplot2::ggsave()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, √† t√≠tulo de exemplo, a √∫ltima figura.

```{r, eval=FALSE}
# exportar mapa ggplot2
ggsave(filename = here::here("dados", "mapas", "elev_rc_ggplot2.png"), plot = map_elev_rc_ggplot2, width = 20, height = 20, units = "cm", dpi = 300)
```

#### Pacote tmap

O pacote tmap √© um pacote direcionado a cria√ß√£o de mapas, com uma sintaxe concisa que permite a cria√ß√£o de mapas com o m√≠nimo de c√≥digo, muito similar ao pacote *ggplot2* (Tennekes 2018). Ele tamb√©m pode gerar mapas est√°ticos ou interativos usando o mesmo c√≥digo, apenas mudando a forma de visualiza√ß√£o com a fun√ß√£o `tmap_mode()`. Por fim, o pacote tmap aceita diversas classes espaciais, incluindo objetos raster, de forma bastante simples. Mais sobre o pacote pode ser lido [aqui](https://mtennekes.github.io/tmap/). Novamente, atentar para a instala√ß√£o extra em [Linux](https://geocompr.github.io/post/2020/installing-r-spatial-ubuntu/) e [MacOS](http://www.kyngchaos.com).

Todas as fun√ß√µes do pacote tmap iniciam-se com `tm_*`, facilitando seu uso. A cada fun√ß√£o iremos utiliz o sinal de `+` para acrescentar outra camada, da mesma forma que o ggplot2. A principal fun√ß√£o, em que todos os objetos espaciais s√£o dados de entrada, √© `tm_shape()`. A partir dela, podemos seguir com fun√ß√µes espec√≠ficas para vizualiza√ß√£o de objetos sf, como `tm_polygons()`, `tm_borders()`, `tm_fill()`, `tm_lines()`, `tm_dots()` ou `tm_bubbles()`; ou com fun√ß√µes para objetos raster como `tm_raster()`. Ainda h√° fun√ß√µes como `tm_text()` para representa√ß√£o de textos das fei√ß√µes, e `tm_scale_bar()`, `tm_compass()` e `tm_graticules()`, para adicionar **barra de escala**, **indicador de orienta√ß√£o (Norte)** e **gride de coordenadas**. Por fim, a fun√ß√£o `tm_credits()` adiciona um texto descritivo e a fun√ß√£o `tm_layout()` faz diversas mudan√ßas nos detalhes do mapa. 

Uma funcionalidade muito interessante do pacote *tmap* √© o uso da fun√ß√£o `tmaptools::palette_explorer()` para escolher as paletas de cores dispon√≠veis. Essa fun√ß√£or requer que os pacotes *shiny* e *shinyjs* estejam instalados, e quando executada, retorna uma aba onde √© poss√≠vel editar e escolher algumas paletas de cores nativas do  *tmap*.

Diversos par√¢metros podem ser acrescentados √† fun√ß√µes de composi√ß√£o do tmap, mas n√£o as detalharemos aqui, pois todas s√£o descritas nos vignettes do pacote: [tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) e [tmap: version changes](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes.html).

Vamos seguir com a composi√ß√£o do mapa de biomas para o Brasil (Figura \@ref(fig-vetor-mapa-tmap)).

```{r fig-vetor-mapa-tmap, fig.align='center', fig.cap="Mapa vetorial com o pacote *tmap*.", out.width="100%"}
map_biomas_tmap <- tm_shape(bi, bbox = c(-74, -35, -27, 10)) +
  tm_polygons(col = "name_biome",
              pal = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"),
              border.col = "black",
              title = "Legenda") +
  tm_compass() +
  tm_scale_bar(text.size = .6) +
  tm_graticules(lines = FALSE) +
  tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
  tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
  tm_layout(title = "Biomas do Brasil",
            title.position = c(.25, .95),
            title.size = 1.8,
            title.fontface = "bold",
            legend.frame = TRUE,
            legend.position = c("left", "bottom"),
            legend.title.fontface = "bold")
map_biomas_tmap
```

Al√©m disso, o pacote tmap nos permite adicionar de forma simples um mapa secund√°rio, provendo uma localiza√ß√£o regional de interesse (Figura \@ref(fig:fig-vetor-mapa-sec-tmap)).

```{r fig-vetor-mapa-sec-tmap, fig.align='center', fig.cap="Mapa vetorial prim√°rio e secund√°rio com o pacote *tmap*.", out.width="100%"}
# dados
sa <- rnaturalearth::ne_countries(continent = "South America")
br <- rnaturalearth::ne_countries(country = "Brazil")
bi <- geobr::read_biomes(showProgress = FALSE) %>%
  dplyr::filter(name_biome != "Sistema Costeiro")

# mapa secundario
map_biomas_sa <- tm_shape(sa) +
  tm_polygons() +
  tm_shape(br) +
  tm_polygons(col = "gray50")

# juntando os mapas
map_biomas_tmap
print(map_biomas_sa, vp = viewport(.815, .875, wi = .2, he = .2))
```

Como exemplo de mapa raster, vamos compor novamente o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-tmap)).

```{r fig-raster-mapa-tmap, fig.align='center', fig.cap="Mapa raster com o pacote *tmap*.", out.width="100%"}
map_elev_rc_tmap <- tm_shape(ra_rc) +
  tm_raster(pal = "viridis", title = "Eleva√ß√£o (m)") +
  tm_shape(rc_2019) +
  tm_borders(col = "red", lwd = 2) +
  tm_compass(position = c(.9, .08)) +
  tm_scale_bar(text.size = .6, position = c(.67, 0)) +
  tm_graticules(lines = FALSE) +
  tm_credits("CRS: WGS84/Geo", position = c(.67, .06)) +
  tm_layout(title = "Eleva√ß√£o Rio Claro/SP",
            title.size = 1.3,
            title.fontface = "bold",
            legend.title.size = .8,
            legend.text.size = .6,
            legend.frame = TRUE,
            legend.position = c(.01, .01),
            legend.title.fontface = "bold")
map_elev_rc_tmap
```

Para exportar mapas criados com o pacote *tmap*, podemos utilizar a fun√ß√£o `tmap::tmap_save()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, √† t√≠tulo de exemplo, a √∫ltima figura.

```{r, eval=FALSE}
# exportar mapa tmap
tmap::tmap_save(tm = map_elev_rc_tmap, filename = here::here("dados", "mapas", "elev_rc_tmap.png"), width = 20, height = 20, units = "cm", dpi = 300)
```

### Mapas animados

Podemos montar facetados para mostrar como padr√µes espaciais de vari√°veis variam ao longo do tempo, como por exemplo, os limites do Brasil ao longo do tempo (Figura \@ref(fig:fig-vetor-brasil-tmap-facted)). Entretanto essa a abordagem possui algumas desvantagens, as facetas podem ficar muito pequenas quando h√° muitas delas.

```{r fig-vetor-brasil-tmap-facted, fig.align='center', fig.cap="Mapa vetor facetado dos estados brasileiros ao longo do tempo com o pacote *tmap*.", out.width="100%"}
# dados
br_anos <- NULL
for(i in c(1872, 1900, 1911, 1920, 1933, 1940, 1950, 1960, 1970, 1980, 1991, 2001, 2010, 2019)){
  br_anos <- geobr::read_state(code_state = "all", year = i, showProgress = FALSE) %>% 
    dplyr::mutate(year = i) %>% 
    dplyr::bind_rows(br_anos, .)
}

# numero de estados ao longo do tempo
br_anos$year %>% table

# mapa facetado
map_brasil_tmap <- tm_shape(br_anos) + 
  tm_polygons() + 
  tm_facets(by = "year", nrow = 4)
map_brasil_tmap
```

Uma solu√ß√£o √© a composi√ß√£o de mapas animados. Apesar de dependerem da publica√ß√£o digital, os mapas animados podem aprimorar relat√≥rios f√≠sicos √† medida que o v√≠nculo a uma p√°gina da web contendo a vers√£o animada torna-se simples. Existem v√°rias maneiras de gerar anima√ß√µes em R, uma forma √© com o pacote *gganimate* e *ggplot2*. Entretanto, aqui veremos a cria√ß√£o de mapas animados com *tmap*.

Podemos criar mapas animados alterando dois argumentos da fun√ß√£o `tm_facets()`:

- trocando o **by** = "year" por **along** = "year"
- indicando o **free.coords** = FALSE

Por fim, podemos exportar o mapa animado no formato de .gif utilizando a fun√ß√£o `tmap::tmap_animation()`, indicando a taxa de atualiza√ß√£o com o argumento **delay** (Figura \@ref(fig:fig-vetor-brasil-tmap-animated)).

```{r eval=FALSE}
# mapa animado
map_brasil_tmap_ani <- tm_shape(br_anos) + 
  tm_polygons() + 
  tm_facets(along = "year", free.coords = FALSE)

# exportar
tmap::tmap_animation(tm = map_brasil_tmap_ani, filename = here::here("dados", "mapas", "elev_rc_tmap_ani.gif"), delay = 30)
```

```{r fig-vetor-brasil-tmap-animated, fig.align='center', fig.cap="Mapa vetor animado dos estados brasileiros ao longo do tempo com o pacote *tmap*.", out.width="100%", echo=FALSE, warning=FALSE}
knitr::include_graphics("img/map_animated.gif")
```

### Mapas interativos

Mapas interativos podem assumir muitas formas, sendo que a mais comum e √∫til √© a capacidade de deslocar e ampliar qualquer parte de um conjunto de dados geogr√°ficos sobreposto em um "mapa da web". Diversos pacotes nos permitem criar esse tipo de mapa, sendo mais comuns e que vamos explorar nesta se√ß√£o ser√£o o *tmap*, *mapview* e *leaflet*. √â importante destacar ainda que esses mapas ir√£o ser compostos numa janela especial do RStudio chamada "Viewer".

#### Pacote tmap

Um recurso exclusivo do *tmap* √© sua capacidade de criar mapas est√°ticos e interativos usando o mesmo c√≥digo. Os mapas podem ser visualizados interativamente em qualquer ponto mudando para o modo de visualiza√ß√£o, usando a fun√ß√£o `tmap::tmap_mode(mode = "view")` (Figura \@ref(fig:fig-raster-mapa-tmap-int)).

```{r eval=FALSE}
# mudar o modo de exibicao do tmap
tmap::tmap_mode(mode = "view")
map_elev_rc_tmap_int <- map_elev_rc_tmap
map_elev_rc_tmap_int
```

```{r fig-raster-mapa-tmap-int, fig.align='center', fig.cap="Mapa vetorial interativo com o pacote *tmap*.", out.width="100%", echo=FALSE}
knitr::include_url("img/fig-raster-mapa-tmap-int.html")
```

Para exportar mapas interativos criados com o pacote *tmap*, podemos utilizar novamente a fun√ß√£o `tmap::tmap_save()`, indicando a extens√£o como `.html`.

```{r, eval=FALSE}
# exportar mapa tmap interativo
tmap::tmap_save(tm = map_elev_rc_tmap_int, 
                filename = here::here("dados", "mapas", "elev_rc_tmap_int.html"))
```

#### Pacote mapview

O pacote *mapview* cria rapidamente mapas interativos simples com a fun√ß√£o `mapvew::mapview()` (Figura \@ref(fig:fig-raster-mapa-mapview-int)). Entretanto, outras caracter√≠sticas podem ser mudadas para criar mapas bem elaborados, como pode ser visto atrav√©s do [site do pacote](https://r-spatial.github.io/mapview).

```{r eval=FALSE}
map_elev_rc_mapview_int <- mapview::mapview(ra_rc, col.regions = viridis::viridis(100))
map_elev_rc_mapview_int
```

```{r fig-raster-mapa-mapview-int, fig.align='center', fig.cap="Mapa vetorial interativo com o pacote *mapview*.", out.width="100%", echo=FALSE}
knitr::include_url("img/fig-raster-mapa-mapview-int.html")
```

Para exportar mapas interativos criados com o pacote *mapview*, podemos utilizar a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r, eval=FALSE}
# exportar mapa tmap interativo
mapview::mapshot(x = map_elev_rc_mapview_int, 
                 url = here::here("dados", "mapas", "elev_rc_mapview_int.html"))
```

#### Pacote leaflet

O *leaflet* √© o pacote de mapeamento interativo mais utilizado e completo em R. Esse pacote fornece uma interface utilizando a biblioteca JavaScript e muitos argumentos podem ser compreendidos lendo a documenta√ß√£o da [biblioteca original](leafletjs.com).

Mapas interativos usando esse pacote s√£o criados utilizando a fun√ß√£o `leaflet::leaflet()`. O resultado dessa fun√ß√£o √© um objeto da classe leaflet, que pode ser alterado por outras fun√ß√µes deste pacote, permitindo que v√°rias camadas e configura√ß√µes de controle sejam adicionadas interativamente (Figura \@ref(fig:fig-raster-mapa-leaflet-int)).

Mais sobre o pacote *leaflet* pode ser consultado em seu [site](https://rstudio.github.io/leaflet/) e [CheatSheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/leaflet.pdf).

```{r fig-raster-mapa-leaflet-int, fig.align='center', fig.cap="Mapa vetorial interativo com o pacote *leaflet*.", out.width="100%", warning=FALSE}
# paleta de cores
pal <- colorNumeric(viridis::viridis(10), raster::values(ra_rc))

# mapa
map_elev_rc_leaflet_int <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>% 
  addRasterImage(ra_rc, colors = pal, opacity = .8) %>%
  addLegend(pal = pal, values = raster::values(ra_rc), title = "Eleva√ß√£o (m)") %>% 
  addPolygons(data = rc_2019, col = "red", fill = NA)
map_elev_rc_leaflet_int
```

Para exportar mapas interativos criados com o pacote *leaflet*, podemos utilizar novamente a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r, eval=FALSE}
# exportar mapa tmap interativo
mapview::mapshot(x = map_elev_rc_leaflet_int, 
                 url = here::here("dados", "mapas", "elev_rc_leaflet_int.html"))
```

## Exemplos de aplica√ß√µes de an√°lises geogr√°ficas para dados ecol√≥gicos

Agora que vimos os conceitos e aplica√ß√µes b√°sicas de manejo e visualiza√ß√£o de dados geogr√°ficos, podemos avan√ßar para realizar tr√™s exemplos de aplica√ß√µes para dados ecol√≥gicos. Para isso, usaremos novamente os dados de comunidades de anf√≠bios da Mata Atl√¢ntica (Atlantic Amphibians, Vancine et al. 2018). Primeiramente, veremos como resumir informa√ß√µes de biodiversidade (n√∫mero de ocorr√™ncias e riqueza) para hex√°gonos. Num segundo momento, veremos como associar dados ambientais para coordenadas de esp√©cies ou comunidades. Por fim, iremos realizar predi√ß√µes espaciais cont√≠nuas de adequabilidade de habitat e n√∫mero de esp√©cies.

### Resumir informa√ß√µes de biodiversidade para unidades espaciais

Resumir informa√ß√µes para unidades espaciais √© um passo muito frequente em an√°lises em Macroecologia, Biogeogradia ou Ecologia da Paisagem. Nesta se√ß√£o, iremos contabilizar o n√∫mero de ocorr√™ncias e a riqueza de anf√≠bios para hex√°gonos na Mata Atl√¢ntica.

Primeiramente, vamos importar e preparar os dados de biodiversidade que usaremos nesses exemplos. Vamos come√ßar importanto os locais de amostragens de anf√≠bios na Mata Atl√¢ntica e selecionando apenas as colunas de interesse.

```{r}
# importar locais
aa_locais <- readr::read_csv(here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv")) %>%
  dplyr::select(id, longitude, latitude, species_number)
```

Agora vamos importar as esp√©cies das comunidades, selecionando apenas as esp√©cies com nomes v√°lidos, e transformando a coluna de indiv√≠duos para 1, para compor posteriormente uma matriz de comunidades de esp√©cies.

```{r}
# importar especies
aa_especies <- readr::read_csv(here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_species.csv")) %>%
  tidyr::drop_na(valid_name) %>% 
  dplyr::select(id, valid_name, individuals) %>% 
  dplyr::distinct(id, valid_name, .keep_all = TRUE) %>% 
  dplyr::mutate(individuals = tidyr::replace_na(individuals, 1),
                individuals = ifelse(individuals > 0, 1, 1))
```

Podemos agora juntar a tabela de locais, que possui as coordenadas √† tabela de esp√©cies. Em seguida convertemos essa √∫nica tabela na classe vetor sf.

```{r}
# join das coordenadas e classe sf
aa_especies_locais_ve <- aa_especies %>% 
  dplyr::left_join(aa_locais) %>% 
  dplyr::relocate(longitude, latitude, .after = 1) %>% 
  dplyr::mutate(lon = longitude, lat = latitude) %>% 
  sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Agora vamos baixar o limite do Bioma da Mata Atl√¢ntica para o Brasil, converter o GCS para WGS84/Geo e ajustar sua extens√£o para remover as ilhas.

```{r}
# mata atlantica
mata_atlantica <- geobr::read_biomes(showProgress = FALSE) %>% 
  dplyr::filter(name_biome == "Mata Atl√¢ntica") %>% 
  sf::st_transform(crs = 4326) %>% 
  sf::st_crop(xmin = -55, ymin = -30, xmax = -34, ymax = -5)
```

Podemos vericar se as coordenadas e o limite do bioma est√£o todos corretos compondo um mapa preliminar, usando o pacote *tmap* (Figura \@ref(fig:fig-vetor-aa-ma)).

```{r fig-vetor-aa-ma, fig.align='center', fig.cap="Mapa dos locais do Atlantic Amphibians e do limite da Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa
tm_shape(mata_atlantica, bbox = aa_especies_locais_ve) +
  tm_polygons() +
  tm_shape(aa_especies_locais_ve) +
  tm_bubbles(size = .1, col = "forestgreen")
```

Como o limite utilizado para reunir informa√ß√µes das comunidade de anf√≠bios foi o mais abrangente poss√≠vel (Muylaert et al. 2018, Vancine et al. 2018), iremos selecionar apenas os locais que caem dentro do limite da Mata Atl√¢ntica que estamos utilizando aqui.

```{r}
# selecionar os locais dentro do limite
aa_especies_locais_ve_ma <- aa_especies_locais_ve[mata_atlantica, ]
```

Podemos refazer o mapa mostrando as coordenadas retiradas em vermelho e as que ficaram em verde (Figura \@ref(fig:fig-vetor-aa-ma-sel)).

```{r fig-vetor-aa-ma-sel, fig.align='center', fig.cap="Mapa dos locais do Atlantic Amphibians que caem dentro do limite da Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa
tm_shape(mata_atlantica, bbox = aa_especies_locais_ve) +
  tm_polygons() +
  tm_shape(aa_especies_locais_ve) +
  tm_bubbles(size = .1, col = "red") +
  tm_shape(aa_especies_locais_ve_ma) +
  tm_bubbles(size = .1, col = "forestgreen")
```

O pr√≥ximo passo √© criar um gride de hex√°gonos para o Bioma da Mata Atl√¢ntica. Usaremos a fun√ß√£o `sf::st_make_grid()` que pode criar quadr√≠culas ou hex√°gonos. Esses ex√°gonos ter√£o a √°rea equicalente √† quadr√≠ulas de 1¬∫ de tamanho (aproximadamente 110 km). Usaremos a fun√ß√£o `sf::st_area()` para calcular as √°reas dos hex√°gonos e a fun√ß√£o `tibble::rowid_to_column()` para criar uma identifica√ß√£o para cada fei√ß√£o.

```{r}
# criar os hexagonos
mata_atlantica_hex <- sf::st_make_grid(x = mata_atlantica, 
                                       cellsize = 1, 
                                       square = FALSE) %>% 
  sf::st_as_sf() %>% 
  dplyr::mutate(areakm2 = sf::st_area(.)/1e6) %>% 
  tibble::rowid_to_column("id_hex")

# selecionar os hexagonos para dentro do limite da mata atlantica
mata_atlantica_hex <- mata_atlantica_hex[mata_atlantica,]
```

Podemos conferir os hex√°gonos criados fazendo um mapa (Figura \@ref(fig:fig-vetor-aa-ma-sel-hex)).

```{r fig-vetor-aa-ma-sel-hex, fig.align='center', fig.cap="Mapa dos hex√°gonos para o limite da Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa
tm_shape(mata_atlantica, bbox = mata_atlantica_hex) +
  tm_polygons() +
  tm_shape(mata_atlantica_hex) +
  tm_borders()
```

Podemos agora associar as esp√©cies aos hex√°gonos fazendo um "join" espacial, utilizando a fun√ß√£o `sf::st_join()`.

```{r}
mata_atlantica_hex_especies <- sf::st_join(x = mata_atlantica_hex, 
                                           y = aa_especies_locais_ve_ma,
                                           left = TRUE)
```

Por fim, podemos agregar os dados para ter o n√∫mero de ocorr√™ncias e de esp√©cies por hex√°gono.

```{r}
mata_atlantica_hex_especies_oco_riq <- mata_atlantica_hex_especies %>% 
  dplyr::group_by(id_hex) %>% 
  dplyr::summarise(ocorrencias = length(valid_name[!is.na(valid_name)]),
                   riqueza = n_distinct(valid_name, na.rm = TRUE))
```

Finalmente podemos compor o mapa final mostrando os hex√°gonos com cores e valores do n√∫mero de ocorr√™ncias e de esp√©cies \@ref(fig:fig-vetor-aa-ma-sel-hex-oco-riq)).

```{r fig-vetor-aa-ma-sel-hex-oco-riq, fig.align='center', fig.cap="Mapa com o n√∫mero de ocorr√™ncias e riqueza de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa de ocorrencias
mapa_oco <- tm_shape(mata_atlantica_hex_especies_oco_riq) +
  tm_polygons(title = "Ocorr√™ncia de anf√≠bios", col = "ocorrencias", 
              pal = "-RdYlBu", style = "pretty") +
  tm_text("ocorrencias", size = .4) +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# mapa de riqueza
mapa_riq <- tm_shape(mata_atlantica_hex_especies_oco_riq) +
  tm_polygons(title = "Riqueza de anf√≠bios", col = "riqueza", 
              pal = "-Spectral", style = "pretty") +
  tm_text("riqueza", size = .4) +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# uniao dos mapas
tmap_arrange(mapa_oco, mapa_riq)
```

### Atribui√ß√£o de dados clim√°ticos para pontos

Atribuir informa√ß√µes ambientais √† ocorr√™ncias √© um passo fundamental para diversas an√°lises. Nesta se√ß√£o, iremos atribuir os valores das vari√°veis bioclim√°ticas aos locais de amostragem de anf√≠bios na Mata Atl√¢ntica.

J√° realizamos o download das vari√°veis bioclim√°ticas na se√ß√£o xx. Vamos importar novamente esses dados, primeiramente listando as camadas e depois importando com a fun√ß√£o `raster:stack()`.

```{r}
# listar arquivos
fi <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
  grep(".tif", ., value = TRUE)

# importar
var <- raster::stack(here::here("dados", "raster", fi))

# renomear
names(var) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))
```

Da se√ß√£o antetior, j√° temos o objeto com a tabela de coordenadas dos locais de amostragem das comunidades de anf√≠bios. Vamos agora criar um objeto vetorial das coordenadas e em seguida selecionar os locais dentro do limite do bioma da Mata Atl√¢ntica.

```{r}
# importar locais
aa_locais_ve <- aa_locais %>% 
  dplyr::mutate(lon = longitude, lat = latitude) %>% 
  sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)

# selecionar locais para o limite
aa_locais_ve
```

Usaremos agora a fun√ß√£o `raster::extract()` para extrair e associar os valores das vari√°veis bioclim√°ticas para os locais de amostragem.

```{r}
# extract
aa_locais_ve_var <- aa_locais_ve %>% 
  dplyr::mutate(raster::extract(var, ., df = TRUE)) %>% 
  dplyr::select(-ID) %>% 
  dplyr::relocate(bio02:bio09, .after = bio01)
```

Podemos ver esses dados na Tabela \@ref(tab:tab-aa-var).

```{r tab-aa-var, echo=FALSE}
aa_locais_ve_var %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(id:bio05) %>% 
  dplyr::slice(1:6) %>% 
  knitr::kable(caption = "Dados extra√≠dos e atribu√≠dos aos locais de amostragens de comunidades de anf√≠bios na Mata Atl√¢ntica")
```

Podemos ainda fazer mapas para espacializar essas vari√°veis (Figura \@ref(fig:fig-vetor-aa-var)).

```{r fig-vetor-aa-var, fig.align='center', fig.cap="Mapa mostrando os valores das vari√°veis bioclim√°ticas (BIO01:BIO06) para os locais amostrados de comunidades de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa
aa_locais_ve_var %>% 
  dplyr::select(bio01:bio06) %>% 
  tidyr::gather(var, val, -geometry) %>% 
  tm_shape() +
  tm_bubbles(size = .1, col = "val", pal = "-Spectral") +
  tm_facets("var", free.scales = TRUE) +
  tm_layout(legend.outside = FALSE)
```

### Predi√ß√µes espaciais de objetos raster
O pacote raster al√©m de permitir realizar manejo e visualiza√ß√£o de dados raster no R, tamb√©m permite a extrapola√ß√£o de ajuste de an√°lises, como GLMs, GAMs dentre outras. Aqui, faremos uma pequena demostra√ß√£o utilizando a fun√ß√£o `raster::predict()` predizendo o resultado de dois ajustes de GLMs para a presen√ßa/aus√™ncia de uma esp√©cie de anuro e a extrapola√ß√£o do n√∫mero de esp√©cies de anf√≠bios para o Bioma da Mata Atl√¢ntica.

Para ajutar um GLM para dados de presen√ßa/aus√™ncia, podemos usar a tabela j√° criada anteriormente, com as esp√©cies e as coordenadas, e fazer um join com a √∫ltima que criamos com os dados bioclim√°ticos. 

```{r}
aa_locais_ve_var_especies <- aa_especies %>% 
  dplyr::left_join(., sf::st_drop_geometry(aa_locais_ve_var), by = "id")
```

Agora, vamos selecionar ocorr√™ncias da esp√©cie *Haddadus binotatus*, atribuindo **1** quando ela ocorre e **0** quando ela n√£o ocorre. Essa esp√©cie √© relativamente comum na serrapilheira de florestas da Mata Atl√¢ntica, e recebe esse nome em homenagem a um grande pesquisador de anf√≠bios da Mata Atl√¢ntica, o Prof. C√©lio Fernando Baptista Haddad, e que foi meu orientador. 
```{r}
aa_locais_ve_var_especies_hb <- aa_locais_ve_var_especies %>% 
  dplyr::mutate(pa = ifelse(valid_name == "Haddadus binotatus", 1, 0), .after = individuals) %>% 
  dplyr::distinct(id, .keep_all = TRUE)
```

Vamos utilizar apenas as vari√°veis n√£o correlacionadas para o √≠ndice de correla√ß√£o de Pearson para r < 0,7.

```{r}
# correlacao
corr <- aa_locais_ve_var_especies_hb %>% 
  dplyr::select(bio01:bio19) %>% 
  cor() %>% 
  caret::findCorrelation(.7, names = TRUE)

# selecao das variaveis nao correlacionadas
aa_locais_ve_var_especies_hb_cor <- aa_locais_ve_var_especies_hb %>% 
  dplyr::select(pa, bio01:bio19) %>% 
  dplyr::select(-c(corr))
```

Agora sim, podemos ajustar um modelo simples da presen√ßa e aus√™ncia dessa esp√©cie, utilizando as vari√°veis n√£o correlacionadas, atrav√©s de um GLM para a fam√≠lia **binomial** (para mais detalhes volte para o cap√≠tulo xx).
```{r}
# ajustar glm
modelo_pa <- glm(formula = pa ~ ., data = aa_locais_ve_var_especies_hb_cor, family = binomial("logit"))
```

Antes de fazermos a predi√ß√£o da distribui√ß√£o potencial da esp√©cie √© fundamental que o objeto raster esteja ajustado para o limite da Mata Atl√¢ntica. Para isso vamos utilizar as fun√ß√µes `raster::crop()` e `raster::mask()` para fazer esse ajuste \@ref(fig:fig-raster-bio-ajuste)).

```{r}
# ajuste da extensao e limite
var_mata_atlantica <- var %>% 
  raster::crop(mata_atlantica) %>% 
  raster::mask(mata_atlantica)
```

```{r fig-raster-bio-ajuste, fig.align='center', fig.cap="Mapa de dois rasters ajustados ao limite da Mata Atl√¢ntica.", out.width="100%"}
# map
tm_shape(var_mata_atlantica[[c(1, 4)]]) +
  tm_raster(pal = "viridis", title = c("bio01", "bio12")) +
  tm_facets(free.scales.raster = TRUE)
```

Agora podemos fazer a predi√ß√£o desse modelo para todo o bioma da Mata Atl√¢ntica. Essa fun√ß√£o vai utilizar os coeficinetes do modelo ajustado para gerar um raster de predi√ß√£o para todos os pixels da Mata Atl√¢ntica.

```{r}
# predicoes
modelo_pa_pred <- raster::predict(model = modelo_pa, object = var_mata_atlantica)
modelo_pa_pred
```

Por fim, no √∫ltimo passo podemos usar as ocorr√™ncias para tornar esse modelo bin√°rio, ou seja, apenas com valores 0 ou 1. Para isso vamos extrair os valores da predi√ß√£o para as ocorr√™ncias da esp√©cies e escolher o menor como sendo o corte. A partir desse valor consideraremos o pixels com 1 e abaixo como 0 (Pearson et al. 2007). 

```{r}
# menor valor da predicao
menor_valor <- modelo_pa_pred %>% 
  raster::extract(aa_locais_ve_var_especies_hb[, c("longitude", "latitude")]) %>% 
  min(na.rm = TRUE)

# selecao dos pixels de presenca/ausencia potencial
modelo_pa_pred_corte <- modelo_pa_pred >= menor_valor
```

Por fim, vamos produzir dois mapas mostrando os valores das preci√ß√µes e o mapa bin√°rio.
\@ref(fig:fig-raster-pred-modelo-bin)).

```{r fig-raster-pred-modelo-bin, fig.align='center', fig.cap="Mapa da predi√ß√£o cont√≠nua e bin√°ria do modelo ajustado para a presen√ßa/aus√™ncia da esp√©cie *Haddadus binotatus* na Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# ocorrencias de hb
hb <- aa_locais_ve_var_especies_hb %>% 
  dplyr::filter(pa == 1) %>% 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# mapa predicao continua
mapa_pred_cont <- tm_shape(modelo_pa_pred) +
  tm_raster(title = "Predi√ß√£o cont√≠nua", pal = "-Spectral") +
  tm_shape(hb) +
  tm_bubbles(size = .2) +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# mapa predicao binaria
mapa_pred_bin <- tm_shape(modelo_pa_pred_corte) +
  tm_raster(title = "Predi√ß√£o bin√°ria", pal = "-Spectral", 
            labels = c("Potencialmente ausente", "Potencialmente presente")) +
  tm_shape(hb) +
  tm_bubbles(size = .2) +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# uniao dos mapas
tmap_arrange(mapa_pred_cont, mapa_pred_bin)
```

Em nossa segunda an√°lise, vamos predizer os dados de riqueza para todo o bioma da Mata Atl√¢ntica. Para isso, temos de retirar as vari√°veis correlacionadas.

```{r}
# correlacao
corr <- aa_locais_ve_var %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(bio01:bio19) %>% 
  cor() %>% 
  caret::findCorrelation(.7, names = TRUE)

# selecao das variaveis nao correlacionadas
aa_locais_var_cor <- aa_locais_ve_var %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(species_number, bio01:bio19) %>% 
  dplyr::select(-c(corr))
```

Agora sim, podemos criar os GLMs com fam√≠lias de distribui√ß√£o apropriadas para dados de contabem como **Poisson**, **Quasipoisson** e **Binomial Negativa**.

```{r}
# modelo poisson
modelo_riq_pois <- glm(formula = species_number ~ ., data = aa_locais_var_cor, family = poisson)

# modelo binomial negativo
modelo_riq_nb <- MASS::glm.nb(formula = species_number ~ ., data = aa_locais_var_cor)
```

Com os modelos ajustados, podemos fazer as predi√ß√µes utilizando os objetos raster e as vari√°veis ambientais tamb√©m em raster.

```{r}
# predicao do modelo poisson
modelo_riq_pois <- predict(model = modelo_riq_pois, object = var_mata_atlantica)
modelo_riq_pois_contagem <- exp(modelo_riq_pois)

# predicao do modelo binomial negativo
modelo_riq_nb <- predict(model = modelo_riq_nb, object = var_mata_atlantica)
modelo_riq_nb_contagem <- exp(modelo_riq_nb)
```

Por fim, podemos compor os tr√™s mapa de predi√ß√µes (Figura \@ref(fig:fig-raster-pred-modelo-riq)).

```{r fig-raster-pred-modelo-riq, fig.align='center', fig.cap="Mapa da predi√ß√£o cont√≠nua e bin√°ria do modelo ajustado para a presen√ßa/aus√™ncia da esp√©cie *Haddadus binotatus* na Mata Atl√¢ntica.", out.width="100%", warning=FALSE}
# mapa predicao poisson
mapa_pred_riq_pois <- tm_shape(modelo_riq_pois) +
  tm_raster(title = "N√∫mero de esp√©cies (Poisson)", pal = "-Spectral") +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# mapa predicao binomial negativo
mapa_pred_riq_nb <- tm_shape(modelo_riq_nb) +
  tm_raster(title = "N√∫mero de esp√©cies (Binomial Negativo)", pal = "-Spectral") +
  tm_graticules(lines = FALSE) +
  tm_compass() +
  tm_scale_bar() +
  tm_layout(legend.title.size = 2,
            legend.title.fontface = "bold",
            legend.position = c("left", "top"))

# uniao dos mapas
tmap_arrange(mapa_pred_riq_pois, mapa_pred_riq_nb)
```

## Para se aprofundar

Listamos aqui as principais refer√™ncias sobre manipula√ß√£o, visualiza√ß√£o de dados geogr√°ficos e an√°lises espaciais no R.

Lovelace, Nowosad & Muenchow (2019) [Geocomputation with R](https://geocompr.robinlovelace.net/). Chapman & Hall/CRC Biostatistics Series

Mas et al. (2019) [An√°lise espacial com R](https://bit.ly/2KpSI7C). 

Pebesma & Bivand (2020) [Spatial Data Science](https://keen-swartz-3146c4.netlify.app/).

Moraga, Paula (2019) [Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/). Chapman & Hall/CRC Biostatistics Series

Brunsdon & Comber (2019) [An Introduction to Spatial Analysis and Mapping in R](https://bookdown.org/lexcomber/brunsdoncomber2e/). 2nd edition.

Mieno (2020) [R as GIS for Economists](https://tmieno2.github.io/R-as-GIS-for-Economists/).

Gimond (2021) [Intro to GIS and Spatial Analysis](https://mgimond.github.io/Spatial/index.html).

Engel (2019) [Using Spatial Data with R](https://cengel.github.io/R-spatial/).

Dorman (2021) [Using R for Spatial Data Analysis](https://michaeldorman.github.io/R-Spatial-Workshop-at-CBS-2021/main.html#Setup:_sample_data)

Rowe, Arribas-Bel (2021) [Spatial Modelling for Data Scientists](https://gdsl-ul.github.io/san/)

Wegmann, Leutner & Dech (2016) Remote Sensing and GIS for Ecologists: Using Open Source Software

Wegmann, Schwalb-Willmann & Dech (2020) An Introduction to Spatial Data Analysis Remote Sensing and GIS with Open Source Software.

Fletcher & Fortin (2018) Spatial ecology and conservation modeling: Applications with r. Springer International Publishing.

Lapaine, Miljenko, Usery, E. Lynn (2017) Choosing a Map Projection. Spring.

<!--chapter:end:14_visualizacao_dados_geoespaciais.Rmd-->

# Reprodutibilidade em pesquisa e gerenciamento de dados

## Gest√£o de projetos acad√™micos no RStudio
## Documentos din√¢micos (R Markdown)
## Controle de vers√£o, Git e GitHub

<!--chapter:end:15_reprodutibilidade_pesquisa_gerenciamento_de_dados.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:99-references.Rmd-->

